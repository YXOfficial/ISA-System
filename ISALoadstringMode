if game.PlaceId == 3198259055 then
-----------------------------------------------------------------------------------
------------------DO NOT EDIT OR IT WILL BREAK-------------------------------------
-----------------------------------------------------------------------------------
--------------------------Custom Character System--------------------
local Dio
if YX == "Dio" then
Dio = true
YX = "Frisk"
end






























---------------------------------------------
if NaNButton then
local pass = getrenv()._G.Pass
local player = game.Players.LocalPlayer
local character = player.Character
local uis = game:GetService("UserInputService")
local function spamk()

	local target = player.Backpack:WaitForChild("Main").LockOnScript.LockOn.Value

	local A_1 = pass
	local A_2 = target
	local A_3 = {
		["HitTime"] = 1,
		["Type"] = "Knockback", 
		["HitEffect"] = "KnifeHitEffect",
		["HurtAnimation"] = game:GetService("ReplicatedStorage").Animations.HurtAnimations.Hurt3,  
		["Sound"] = game:GetService("ReplicatedStorage").Sounds.KnifeHit,
		["CombatInv"] = true,
		["Velocity"] = Vector3.new(0, -1, 0),
		["Damage"] = "NaN"
	}
	local Event = game:GetService("ReplicatedStorage").Remotes.Damage
	Event:InvokeServer(A_1, A_2, A_3)

end

uis.InputBegan:Connect(function(inputs, event)
	if event == true then return end

	if inputs.KeyCode == Enum.KeyCode.B then

			spamk()


	end

end)
end
if SmokeAhhButton then
local mouse = game.Players.LocalPlayer:GetMouse()
mouse.KeyDown:Connect(function(k) 
	if k == "v" then

       local A_1 = getrenv()._G.Pass
                            local A_2 = game:GetService("Players").LocalPlayer.Backpack.Main.LockOnScript.LockOn.Value
                            local A_3 = 
                                {
                                    ["HitTime"] = 2.5,
                                    ["Type"] = "Knockback", 
                                    ["HitEffect"] = "LightHitEffect3",
                                    ["Effect"] = "ImSoCool",
                                    ["BlockAble"] = false,
                                    ["HurtAnimation"] = game:GetService("ReplicatedStorage").Animations.HurtAnimations.PerfectBlock,
                                    ["Sound"] = game:GetService("ReplicatedStorage").Sounds.BassDrop,
                                    ["CombatInv"] = true,
                                    ["Damage"] = 0
                                }
                            local Event = game:GetService("ReplicatedStorage").Remotes.Damage
                            Event:InvokeServer(A_1, A_2, A_3)
end
end)
end
if FlingButton then
local mouse = game.Players.LocalPlayer:GetMouse()
mouse.KeyDown:Connect(function(k) 
	if k == "e" then
            local A_1 = getrenv()._G.Pass
            local A_2 = game:GetService("Players").LocalPlayer.Backpack.Main.LockOnScript.LockOn.Value
            local A_3 = 
                {
                    ["HitTime"] = 1, 
                    ["Type"] = "Normal", 
                    ["HitEffect"] = "LightHitEffect", 
                    ["HurtAnimation"] = game:GetService("ReplicatedStorage").Animations.HurtAnimations.Knockback2, 
                    ["Velocity"] = Vector3.new(0, 0.000001, 0),
                    ["CombatInv"] = true,
                    ["Effect"] = "HiReset",
                    ["BlockAble"] = false,
                    ["Sound"] = game:GetService("ReplicatedStorage").Sounds.Knockback, 
                    ["Damage"] = 0
                }
            local Event = game:GetService("ReplicatedStorage").Remotes.Damage
            Event:InvokeServer(A_1, A_2, A_3)
end
end)
end







if Orca then
loadstring(
  game:HttpGetAsync("https://raw.githubusercontent.com/richie0866/orca/master/public/latest.lua")
)()
end
setfflag("AbuseReportScreenshotPercentage", 0)
setfflag("DFFlagAbuseReportScreenshot", "False")
setfflag("AbuseReportScreenshot", "False")
setfflag("CrashPadUploadToBacktraceToBacktraceBaseUrl", "")
setfflag("CrashUploadToBacktracePercentage", "0")
setfflag("CrashUploadToBacktraceBlackholeToken", "")
setfflag("CrashUploadToBacktraceWindowsPlayerToken", "")
workspace.FallenPartsDestroyHeight = 0/0
--loadstring(game:HttpGet("https://paste.ee/r/RLi6i"))() --ISA no health bar
--loadstring(game:HttpGet("https://paste.ee/r/abU1f"))() --Xester
--loadstring(game:HttpGet("https://paste.ee/r/SnoMa"))() --ISA
--loadstring(game:HttpGet("https://paste.ee/r/W8rGd"))() --stand on head
--loadstring(game:HttpGet("https://paste.ee/r/p3stx"))() --map
-------------------------------------
--loadstring(game:HttpGet("https://paste.ee/r/eEnzm"))() --Rainbowking
local Vector3_101 = Vector3.new(1, 0, 1)
local netless_Y = Vector3.new(0, 25.1, 0)
local function getNetlessVelocity(realPartVelocity)
    local mag = realPartVelocity.Magnitude
    if (mag > 1) and (mag < 100) then
        local unit = realPartVelocity.Unit
        if (unit.Y > 0.25) or (unit.Y < -0.75) then
            return realPartVelocity * (25.1 / realPartVelocity.Y)
        end
        realPartVelocity = unit * 100
    end
    return (realPartVelocity * Vector3_101) + netless_Y
end


function randomstring()
	local e = {}
	for i = 1,math.random(1,10) do
		table.insert(e,#e+1,utf8.char(math.random(0,10175)))
	end
	return table.concat(e)
end

if HYPERISA then
AnimationTest = false
end
if StopCharacterFromLoadingV2 then
StopFromLoading = false
end
if WalkOnWall then
VR = false
end
if VR then
spawnonly = true
WalkOnWall = false
end

if CustomHealth then
NaNHealth = false
end
if NothingWithoutCharacter then
BikeAndGunAHHHH = false
FreezeAnim = true 
jojo = false
nofuckinghatsmesh = false 
NoClothes = false 
end
if YX == "GTFrisk" or "DeltaSans" or "Undyne" then
Tier5 = false
end
if not game:IsLoaded() then
    game.Loaded:Wait()
end
for i,v in pairs(game:GetService("StarterPlayer").StarterPlayerScripts:GetChildren()) do
     v:Destroy()
end
if ahhSky then
local Bloom = Instance.new("BloomEffect")
Bloom.Intensity = 0.1
Bloom.Threshold = 0
Bloom.Size = 100

local Tropic = Instance.new("Sky")
Tropic.Name = "Tropic"
Tropic.SkyboxUp = "http://www.roblox.com/asset/?id=169210149"
Tropic.SkyboxLf = "http://www.roblox.com/asset/?id=169210133"
Tropic.SkyboxBk = "http://www.roblox.com/asset/?id=169210090"
Tropic.SkyboxFt = "http://www.roblox.com/asset/?id=169210121"
Tropic.StarCount = 100
Tropic.SkyboxDn = "http://www.roblox.com/asset/?id=169210108"
Tropic.SkyboxRt = "http://www.roblox.com/asset/?id=169210143"
Tropic.Parent = Bloom

local Sky = Instance.new("Sky")
Sky.SkyboxUp = "http://www.roblox.com/asset/?id=196263782"
Sky.SkyboxLf = "http://www.roblox.com/asset/?id=196263721"
Sky.SkyboxBk = "http://www.roblox.com/asset/?id=196263721"
Sky.SkyboxFt = "http://www.roblox.com/asset/?id=196263721"
Sky.CelestialBodiesShown = false
Sky.SkyboxDn = "http://www.roblox.com/asset/?id=196263643"
Sky.SkyboxRt = "http://www.roblox.com/asset/?id=196263721"
Sky.Parent = Bloom

Bloom.Parent = game:GetService("Lighting")

local Bloom = Instance.new("BloomEffect")
Bloom.Enabled = false
Bloom.Intensity = 0.35
Bloom.Threshold = 0.2
Bloom.Size = 56

local Tropic = Instance.new("Sky")
Tropic.Name = "Tropic"
Tropic.SkyboxUp = "http://www.roblox.com/asset/?id=169210149"
Tropic.SkyboxLf = "http://www.roblox.com/asset/?id=169210133"
Tropic.SkyboxBk = "http://www.roblox.com/asset/?id=169210090"
Tropic.SkyboxFt = "http://www.roblox.com/asset/?id=169210121"
Tropic.StarCount = 100
Tropic.SkyboxDn = "http://www.roblox.com/asset/?id=169210108"
Tropic.SkyboxRt = "http://www.roblox.com/asset/?id=169210143"
Tropic.Parent = Bloom

local Sky = Instance.new("Sky")
Sky.SkyboxUp = "http://www.roblox.com/asset/?id=196263782"
Sky.SkyboxLf = "http://www.roblox.com/asset/?id=196263721"
Sky.SkyboxBk = "http://www.roblox.com/asset/?id=196263721"
Sky.SkyboxFt = "http://www.roblox.com/asset/?id=196263721"
Sky.CelestialBodiesShown = false
Sky.SkyboxDn = "http://www.roblox.com/asset/?id=196263643"
Sky.SkyboxRt = "http://www.roblox.com/asset/?id=196263721"
Sky.Parent = Bloom

Bloom.Parent = game:GetService("Lighting")
local Blur = Instance.new("BlurEffect")
Blur.Size = 1.2

Blur.Parent = game:GetService("Lighting")
local Efecto = Instance.new("BlurEffect")
Efecto.Name = "Efecto"
Efecto.Enabled = false
Efecto.Size = 1.5

Efecto.Parent = game:GetService("Lighting")
local Inaritaisha = Instance.new("ColorCorrectionEffect")
Inaritaisha.Name = "Inari taisha"
Inaritaisha.Saturation = 0.05
Inaritaisha.TintColor = Color3.fromRGB(255, 224, 219)

Inaritaisha.Parent = game:GetService("Lighting")
local Normal = Instance.new("ColorCorrectionEffect")
Normal.Name = "Normal"
Normal.Enabled = false
Normal.Saturation = -0.2
Normal.TintColor = Color3.fromRGB(255, 232, 215)

Normal.Parent = game:GetService("Lighting")
local SunRays = Instance.new("SunRaysEffect")
SunRays.Intensity = 0.05

SunRays.Parent = game:GetService("Lighting")
local Sunset = Instance.new("Sky")
Sunset.Name = "Sunset"
Sunset.SkyboxUp = "rbxassetid://323493360"
Sunset.SkyboxLf = "rbxassetid://323494252"
Sunset.SkyboxBk = "rbxassetid://323494035"
Sunset.SkyboxFt = "rbxassetid://323494130"
Sunset.SkyboxDn = "rbxassetid://323494368"
Sunset.SunAngularSize = 14
Sunset.SkyboxRt = "rbxassetid://323494067"

Sunset.Parent = game:GetService("Lighting")
local Takayama = Instance.new("ColorCorrectionEffect")
Takayama.Name = "Takayama"
Takayama.Enabled = false
Takayama.Saturation = -0.3
Takayama.Contrast = 0.1
Takayama.TintColor = Color3.fromRGB(235, 214, 204)

Takayama.Parent = game:GetService("Lighting")
local L = game:GetService("Lighting")
L.Brightness = 2.14
L.ColorShift_Bottom = Color3.fromRGB(11, 0, 20)
L.ColorShift_Top = Color3.fromRGB(240, 127, 14)
L.OutdoorAmbient = Color3.fromRGB(34, 0, 49)
L.ClockTime = 6.7
L.FogColor = Color3.fromRGB(94, 76, 106)
L.FogEnd = 1000
L.FogStart = 0
L.ExposureCompensation = 0.24
L.ShadowSoftness = 0
L.Ambient = Color3.fromRGB(59, 33, 27)

local Bloom = Instance.new("BloomEffect")
Bloom.Intensity = 0.1
Bloom.Threshold = 0
Bloom.Size = 100

local Tropic = Instance.new("Sky")
Tropic.Name = "Tropic"
Tropic.SkyboxUp = "http://www.roblox.com/asset/?id=169210149"
Tropic.SkyboxLf = "http://www.roblox.com/asset/?id=169210133"
Tropic.SkyboxBk = "http://www.roblox.com/asset/?id=169210090"
Tropic.SkyboxFt = "http://www.roblox.com/asset/?id=169210121"
Tropic.StarCount = 100
Tropic.SkyboxDn = "http://www.roblox.com/asset/?id=169210108"
Tropic.SkyboxRt = "http://www.roblox.com/asset/?id=169210143"
Tropic.Parent = Bloom

local Sky = Instance.new("Sky")
Sky.SkyboxUp = "http://www.roblox.com/asset/?id=196263782"
Sky.SkyboxLf = "http://www.roblox.com/asset/?id=196263721"
Sky.SkyboxBk = "http://www.roblox.com/asset/?id=196263721"
Sky.SkyboxFt = "http://www.roblox.com/asset/?id=196263721"
Sky.CelestialBodiesShown = false
Sky.SkyboxDn = "http://www.roblox.com/asset/?id=196263643"
Sky.SkyboxRt = "http://www.roblox.com/asset/?id=196263721"
Sky.Parent = Bloom

Bloom.Parent = game:GetService("Lighting")

local Bloom = Instance.new("BloomEffect")
Bloom.Enabled = false
Bloom.Intensity = 0.35
Bloom.Threshold = 0.2
Bloom.Size = 56

local Tropic = Instance.new("Sky")
Tropic.Name = "Tropic"
Tropic.SkyboxUp = "http://www.roblox.com/asset/?id=169210149"
Tropic.SkyboxLf = "http://www.roblox.com/asset/?id=169210133"
Tropic.SkyboxBk = "http://www.roblox.com/asset/?id=169210090"
Tropic.SkyboxFt = "http://www.roblox.com/asset/?id=169210121"
Tropic.StarCount = 100
Tropic.SkyboxDn = "http://www.roblox.com/asset/?id=169210108"
Tropic.SkyboxRt = "http://www.roblox.com/asset/?id=169210143"
Tropic.Parent = Bloom

local Sky = Instance.new("Sky")
Sky.SkyboxUp = "http://www.roblox.com/asset/?id=196263782"
Sky.SkyboxLf = "http://www.roblox.com/asset/?id=196263721"
Sky.SkyboxBk = "http://www.roblox.com/asset/?id=196263721"
Sky.SkyboxFt = "http://www.roblox.com/asset/?id=196263721"
Sky.CelestialBodiesShown = false
Sky.SkyboxDn = "http://www.roblox.com/asset/?id=196263643"
Sky.SkyboxRt = "http://www.roblox.com/asset/?id=196263721"
Sky.Parent = Bloom

Bloom.Parent = game:GetService("Lighting")
local Blur = Instance.new("BlurEffect")
Blur.Size = 2

Blur.Parent = game:GetService("Lighting")
local Efecto = Instance.new("BlurEffect")
Efecto.Name = "Efecto"
Efecto.Enabled = false
Efecto.Size = 2

Efecto.Parent = game:GetService("Lighting")
local Inaritaisha = Instance.new("ColorCorrectionEffect")
Inaritaisha.Name = "Inari taisha"
Inaritaisha.Saturation = 0.05
Inaritaisha.TintColor = Color3.fromRGB(255, 224, 219)

Inaritaisha.Parent = game:GetService("Lighting")
local Normal = Instance.new("ColorCorrectionEffect")
Normal.Name = "Normal"
Normal.Enabled = false
Normal.Saturation = -0.2
Normal.TintColor = Color3.fromRGB(255, 232, 215)

Normal.Parent = game:GetService("Lighting")
local SunRays = Instance.new("SunRaysEffect")
SunRays.Intensity = 0.05

SunRays.Parent = game:GetService("Lighting")
local Sunset = Instance.new("Sky")
Sunset.Name = "Sunset"
Sunset.SkyboxUp = "rbxassetid://323493360"
Sunset.SkyboxLf = "rbxassetid://323494252"
Sunset.SkyboxBk = "rbxassetid://323494035"
Sunset.SkyboxFt = "rbxassetid://323494130"
Sunset.SkyboxDn = "rbxassetid://323494368"
Sunset.SunAngularSize = 14
Sunset.SkyboxRt = "rbxassetid://323494067"

Sunset.Parent = game:GetService("Lighting")
local Takayama = Instance.new("ColorCorrectionEffect")
Takayama.Name = "Takayama"
Takayama.Enabled = false
Takayama.Saturation = -0.3
Takayama.Contrast = 0.1
Takayama.TintColor = Color3.fromRGB(235, 214, 204)

Takayama.Parent = game:GetService("Lighting")
local L = game:GetService("Lighting")
L.Brightness = 2.14
L.ColorShift_Bottom = Color3.fromRGB(11, 0, 20)
L.ColorShift_Top = Color3.fromRGB(240, 127, 14)
L.OutdoorAmbient = Color3.fromRGB(34, 0, 49)
L.ClockTime = 6.7
L.FogColor = Color3.fromRGB(94, 76, 106)
L.FogEnd = 1000
L.FogStart = 0
L.ExposureCompensation = 0.24
L.ShadowSoftness = 0
L.Ambient = Color3.fromRGB(59, 33, 27)
end


 local player = game.Players.LocalPlayer
local Players = game:GetService("Players")
local rs = game:GetService("RunService")
local mouse = game.Players.LocalPlayer:GetMouse()

local detect 
detect = rs.Heartbeat:Connect(function()
game:GetService("Players").LocalPlayer.PlayerGui.CharacterSelection.Frame.TextLabel.Text = randomstring()
for i,v in pairs(player.PlayerGui.CharacterSelection.Frame.Gui:GetChildren()) do
	if v.ClassName == "TextButton" then
		v.Text = randomstring()
	end
end
end)
game:GetService("ReplicatedStorage").Remotes.Functions:InvokeServer({getrenv()._G.Pass,"ChangeSetting","DeathScene",false})
game:GetService("Players").LocalPlayer.PlayerData.DeathScene:Destroy()
if MorphEnabled then
game:GetService("ReplicatedStorage").Remotes.Functions:InvokeServer({getrenv()._G.Pass,"ChangeSetting","MorphEnabled",true})
end
game:GetService("ReplicatedStorage").Remotes.Functions:InvokeServer({getrenv()._G.Pass,"ChangeSetting","PrivateServerOwner",true})
if DisableCameraShake then
game:GetService("ReplicatedStorage").Remotes.Functions:InvokeServer({getrenv()._G.Pass,"ChangeSetting","CameraShake",false})
end
if StopFromLoading then
game:GetService("ReplicatedStorage").Remotes.Functions:InvokeServer({getrenv()._G.Pass,"ChangeSetting","MorphEnabled",true})
game:GetService("Players").LocalPlayer.PlayerData.MorphEnabled:Destroy()
end
game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
game.StarterGui:SetCoreGuiEnabled('Backpack', true)
game.StarterGui:SetCoreGuiEnabled('PlayerList', true)
game.StarterGui:SetCoreGuiEnabled('Chat', true)
game.StarterGui:SetCore('ResetButtonCallback', true)
game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
game.Chat.BubbleChatEnabled = true
--loadstring(game:HttpGet("https://pastebin.com/raw/tz7HD8cQ", true))()
game.Players.LocalPlayer.PlayerGui.CharacterSelection.Character.Value = YX


local PlayerInstance;
local getgenv = getgenv or function() return _G end
local gethiddenprop, sethiddenprop = (gethiddenproperty or get_hidden_property or gethiddenprop or get_hidden_prop), (sethiddenproperty or set_hidden_property or sethiddenprop or set_hidden_prop)
local setsimulationrad = setsimulationradius or set_simulation_radius or function(Radius) sethiddenprop(PlayerInstance, "SimulationRadius", Radius) end
if not getgenv or not gethiddenprop or not setsimulationrad then return false end -- Not supported
if getgenv().NETWORKOWNER then getgenv().NETWORKOWNER:Disconnect() getgenv().NETWORKPLAYERCHECK:Disconnect() end

-- Grab services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
PlayerInstance = Players.LocalPlayer

-- Optimize
local inf = math.huge
local PlayerList = {}
for _, Plr in pairs(Players:GetPlayers()) do
    if Plr ~= PlayerInstance then
        PlayerList[#PlayerList + 1] = Plr
    end
end

getgenv().NETWORKPLAYERCHECK = Players.PlayerAdded:Connect(function(Plr)
    PlayerList[#PlayerList + 1] = Plr
end)

-- Configure network services
settings().Physics.AllowSleep = false -- Keep the current physics system from sleeping. (Non-moving parts lose ownership.)
settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled -- Keep the physics from throttling.
PlayerInstance.ReplicationFocus = workspace

-- Start network runtime
getgenv().NETWORKOWNER = RunService.Stepped:Connect(function()
    -- Revoke ownership from others
    for _, Plr in pairs(PlayerList) do
        sethiddenprop(Plr, "MaximumSimulationRadius", 0.01)
        sethiddenprop(Plr, "SimulationRadius", 0.01)
    end

    -- Claim ownership for me
    sethiddenprop(PlayerInstance, "MaximumSimulationRadius", inf)
    setsimulationrad(inf)
end)
----------------






































wait(1)
if LoopSpawnPoint then
local secondsElapsed = 0
local timeout = 50
spawn(function()
while true do
	print("Looping...")
	wait()
	secondsElapsed = secondsElapsed + 1
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(865.471069, 324.923798, -157.677597, -0.995842397, 1.3732715e-09, 0.0910930857, 4.24818669e-09, 1, 3.1366298e-08, -0.0910930857, 3.16228714e-08, -0.995842397)
	if secondsElapsed == timeout then
		break
	end
end
end)
end
if Dio then
spawn(function()
wait(3)
anchored = true
dmg = true
debug = false
local rep = game:GetService("ReplicatedStorage")
local plr = game.Players.LocalPlayer
local pass = getrenv()._G.Pass
local remotes = rep:WaitForChild("Remotes")
local module = {}
random = Random.new()
local CameraShaker = require(game.ReplicatedStorage.ClientModules.CameraShaker)
local camera = game.Workspace.CurrentCamera
local camShake = CameraShaker.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
    camera.CFrame = camera.CFrame * shakeCf
end)
camShake:Start()
function sh(val) camShake:Shake(CameraShaker.Presets[val]) end
function module.Damage(p1, p2)
	if not locked then
		for i, v in pairs(workspace:GetChildren()) do
			if v:FindFirstChild("HumanoidRootPart") and v ~= plr.Character.HumanoidRootPart.Parent and (plr.Character.HumanoidRootPart.Position + plr.Character.HumanoidRootPart.CFrame.lookVector * 5 - v.HumanoidRootPart.Position).magnitude <= 6 then
				if not p2.DodgeAble then p2.DodgeAble = true end
				if p2.Type == "Normal" or p2.Type == "Light" and p2.Damage >= 10.1 then p2.Damage = math.random(1,10) end
				p2.BlockAble = false
				p2.CombatInv = true
				if remotes.Damage:InvokeServer(pass, v, p2) then
					return v
				else
					break
				end
			end
		end
	else
		p2.BlockAble = false
		p2.CombatInv = true
		if not p2.DodgeAble then p2.DodgeAble = true end
		if p2.Type == "Normal" or p2.Type == "Light" and p2.Damage >= 10.1 then p2.Damage = math.random(1,10) end
		remotes.Damage:InvokeServer(pass, locked, p2)
	end
	return nil
end
function at(p1,p2,p3)
if module.Damage(p1, p2) then
    sh(p3);
    return;
end;
end

wait(1)
plr.Chatted:connect(function(p4) game.ReplicatedStorage.Remotes.Events:FireServer({ pass, "Chatted", p4, Color3.fromRGB(255, 128, 1) }); end);
local cf, v3, euler, sin, sine, abs = CFrame.new, Vector3.new, CFrame.fromEulerAnglesXYZ, math.sin, 0, math.abs
local con = nil
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local ReplicatedFirst = game:GetService("ReplicatedFirst")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")
local instance = Instance.new
local vector3 = Vector3.new
local color3 = Color3.fromRGB
local angles = CFrame.Angles
local cf = CFrame.new
local euler = CFrame.fromEulerAnglesXYZ
local rad = math.rad
local sin = math.sin
local random = math.random
local huge = math.huge
local clamp = math.clamp
player = Players.LocalPlayer
mouse = player:GetMouse()
local Camera = workspace.CurrentCamera
local character = player.Character or player.CharacterAdded:Wait()
local rootPart, humanoid = character:WaitForChild("HumanoidRootPart"), character:WaitForChild("Humanoid")
local head, torso = character:WaitForChild("Head"), character:WaitForChild("Torso")
local leftArm, rightArm = character:WaitForChild("Left Arm"), character:WaitForChild("Right Arm")
local leftLeg, rightLeg = character:WaitForChild("Left Leg"), character:WaitForChild("Right Leg")
local LS, LH, RS, RH, Neck, RootJoint = torso["Left Shoulder"], torso["Left Hip"], torso["Right Shoulder"], torso["Right Hip"], torso.Neck, rootPart.RootJoint
local face = head.face
local RSC0, LSC0, RHC0, LHC0, NeckC0, RootJointC0 = RS.C0, LS.C0, RH.C0, LH.C0, Neck.C0, RootJoint.C0
local standLS, standLH, standRS, standRH, standNeck, standRootJoint
local standRSC0, standLSC0, standRHC0, standLHC0, standNeckC0, standRootJointC0
local standleftArm, standrightArm
local standleftLeg, standrightLeg
local standhead, standtorso
local standrootPart
local stand
local standActive = false
local unColored = true

for i,v in pairs(humanoid:GetPlayingAnimationTracks()) do
	v:Stop()
end

local timeStop = false
for i,v in pairs(humanoid:GetPlayingAnimationTracks()) do
	v:Stop()
end
if character:FindFirstChild("Animate") then
	character:FindFirstChild("Animate"):Destroy()
end
wait(0.25)

humanoid.MaxHealth = math.huge
humanoid.Health = math.huge
humanoid.Name = "NotHumanoid"

local billBoard = Instance.new("BillboardGui",head)
billBoard.AlwaysOnTop = true
billBoard.Size = UDim2.new(20,35,2,35)
billBoard.StudsOffset = Vector3.new(0,3,0)
billBoard.Adornee = head
billBoard.Name = "GUI"
--[[local UI = Instance.new("TextLabel",billBoard)
UI.BackgroundTransparency = 1
UI.TextScaled = true
UI.BorderSizePixel = 0
UI.Text = "Dio"
UI.Font = "Merriweather"
UI.TextSize = 30
UI.TextTransparency = 0
UI.TextStrokeTransparency = 0
UI.TextColor3 = Color3.new(0,0,0)
UI.TextStrokeColor3 = Color3.new(255, 170, 0)
UI.Size = UDim2.new(1,0,0.5,0)
UI.Parent = billBoard]]

local billBoard2 = Instance.new("BillboardGui",head)
billBoard2.AlwaysOnTop = true
billBoard2.Size = UDim2.new(20,35,2,35)
billBoard2.StudsOffset = Vector3.new(0,5,0)
billBoard2.Adornee = head
billBoard2.Name = "GUI"
local TalkText = Instance.new("TextLabel",billBoard2)
TalkText.BackgroundTransparency = 1
TalkText.TextScaled = true
TalkText.BorderSizePixel = 0
TalkText.Text = ""
TalkText.Font = "Arcade"
TalkText.TextSize = 30
TalkText.TextTransparency = 0
TalkText.TextStrokeTransparency = 0
TalkText.TextColor3 = Color3.new(0,0,0)
TalkText.TextStrokeColor3 = Color3.new(1,0,0)
TalkText.Size = UDim2.new(1,0,0.5,0)
TalkText.Parent = billBoard2

local stopAnimationsValue = Instance.new("BoolValue", script)
local standanimationAction = 1
local playingAnimation = ""

local tsActivate = Instance.new("BoolValue", script)

local animationAction = 1
local baseC1 = rootPart:WaitForChild("RootJoint").C1

--[Variables]--
local debounce = true
local running = false
local moving = false
local holding = true
local move1deb = true
local move2deb = true
local move3deb = true
local adjustSpeed = Instance.new("NumberValue", script)
local follow = false
--[[Type Part: size, name, color, material, transparency, anchored, cancollide
    Type Mesh: meshType, Scale, MeshId, TextureId
    Type BodyVelocity: velocity, maxForce, P
    Type BodyPosition: position, maxForce, P
    Type BodyGyro: cframe, maxForce, P
--]]
function DisableEffects(parent)
	for i,v in pairs(parent:GetChildren()) do
		if v:IsA("ParticleEmitter") then
			v.Enabled = false
		end
	end
end
function NilEffects(parent)
	for i,v in pairs(parent:GetChildren()) do
		if v:IsA("ParticleEmitter") then
			v.Parent = nil
		end
	end
end
function NilSounds(parent)
	for i,v in pairs(parent:GetChildren()) do
		if v:IsA("Sound") then
			v.PlayOnRemove = false
			v.Parent       = nil
		end
	end
end

local particleTable = {}
local soundTable = {}
local partTable = {}

function findParticle()
	for i,v in pairs(particleTable) do
		if v and not v.Parent then
			local success, message = pcall(function()
				v.Parent = game:GetService("Lighting")
			end)
			if not success then return false end
			v.Parent = nil
			return v end
	end
	return false
end
function findSound(parent)
	for i,v in pairs(soundTable) do
		if v and not v.Parent then
			v.PlayOnRemove = false
			local success, message = pcall(function()
				v.Parent = parent
			end)
			if not success then return false end
			v.Parent = nil
			return v end
	end
	return false
end
function findPart()
	for i,v in pairs(partTable) do
		if v and not v.Parent then
			local success, message = pcall(function()
				v.Parent = game:GetService("Lighting")
			end)
			if not success then return false end
			v.Parent = nil
			return v end
	end
	return false
end
function NilPart(part)
	for i,v in pairs(part:GetChildren()) do
		v:Destroy()
	end
	part.Parent = nil
end
function sizePLR(p, size)   
	local pchar = p.Character
	if pchar then
		local function scale(chr,scl)
			local Head = chr['Head']
			local Torso = chr['Torso']
			local LA = chr['Left Arm']
			local RA = chr['Right Arm']
			local LL = chr['Left Leg']
			local RL = chr['Right Leg']
			local HRP = chr['HumanoidRootPart']

			wait(0.1)
			Head.formFactor = 3
			Torso.formFactor = 3
			LA.formFactor = 3
			RA.formFactor = 3
			LL.formFactor = 3
			RL.formFactor = 3
			HRP.formFactor = 3

			Head.Size = Vector3.new(scl * 2, scl, scl)
			Torso.Size = Vector3.new(scl * 2, scl * 2, scl)
			LA.Size = Vector3.new(scl, scl * 2, scl)
			RA.Size = Vector3.new(scl, scl * 2, scl)
			LL.Size = Vector3.new(scl, scl * 2, scl)
			RL.Size = Vector3.new(scl, scl * 2, scl)
			HRP.Size = Vector3.new(scl * 2, scl * 2, scl)

			Neck.C0 = CFrame.new(0, 1 * scl, 0) * CFrame.Angles(-1.6, 0, 3.1)
			Neck.C1 = CFrame.new(0, -0.5 * scl, 0) * CFrame.Angles(-1.6, 0, 3.1)

			LS.C0 = CFrame.new(-1 * scl, 0.5 * scl, 0) * CFrame.Angles(0, -1.6, 0)
			LS.C1 = CFrame.new(0.5 * scl, 0.5 * scl, 0) * CFrame.Angles(0, -1.6, 0)

			RS.C0 = CFrame.new(1 * scl, 0.5 * scl, 0) * CFrame.Angles(0, 1.6, 0)
			RS.C1 = CFrame.new(-0.5 * scl, 0.5 * scl, 0) * CFrame.Angles(0, 1.6, 0)

			LH.C0 = CFrame.new(-1 * scl, -1 * scl, 0) * CFrame.Angles(0, -1.6, 0)
			LH.C1 = CFrame.new(-0.5 * scl, 1 * scl, 0) * CFrame.Angles(0, -1.6, 0)

			RH.C0 = CFrame.new(1 * scl, -1 * scl, 0) * CFrame.Angles(0, 1.6, 0)
			RH.C1 = CFrame.new(0.5 * scl, 1 * scl, 0) * CFrame.Angles(0, 1.6, 0)

			RootJoint.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(-1.6, 0, -3.1)
			RootJoint.C1 = CFrame.new(0, 0, 0) * CFrame.Angles(-1.6, 0, -3.1)
			RSC0, LSC0, RHC0, LHC0, NeckC0, RootJointC0 = RS.C0, LS.C0, RH.C0, LH.C0, Neck.C0, RootJoint.C0   
		end
		scale(pchar, size)
	end
end

function removeAccessories()
	for i,v in pairs(character:GetChildren()) do
		if v:IsA("Accessory") then
			v:Destroy()
		end
	end
end

function bodyColor(color)
	for i,v in pairs(character:GetChildren()) do
		if v.Name == "Head" or v.Name == "Left Arm" or v.Name == "Right Arm" or v.Name == "Left Leg" or v.Name == "Right Leg" or v.Name == "Torso" then
			v.BrickColor = BrickColor.new(color)
		end
	end
end

function CreateInstance(Type, ...)
	if Type == "Part" then
		local size, name, color, material, transparency, anchored, cancollide = unpack(...)
		local part = findPart()
		if not part then
			part = instance("Part")
			table.insert(partTable, part)
		end
		if part:FindFirstChild("Mesh") then part.Mesh:Destroy() end
		part:ClearAllChildren()
		part.Size = size
		part.Name = name
		part.Transparency = transparency
		part.Color = color
		part.Material = material
		part.Anchored = anchored
		part.CanCollide = cancollide
		return part
	elseif Type == "Mesh" then
		local meshType, Scale, MeshId, TextureId = unpack(...)
		local mesh = instance("SpecialMesh")
		mesh.MeshType = meshType
		mesh.Scale = Scale
		mesh.MeshId = MeshId or ""
		mesh.TextureId = TextureId or ""
		return mesh
	elseif Type == "BodyVelocity" then
		local velocity, maxForce, P = unpack(...)
		local bv = instance("BodyVelocity")
		bv.MaxForce = maxForce
		bv.P = P
		bv.Velocity = velocity
		return bv
	elseif Type == "BodyPosition" then
		local position, maxForce, P = unpack(...)
		local bp = instance("BodyPosition")
		bp.MaxForce = maxForce
		bp.P = P
		bp.Position = position
		return bp
	elseif Type == "BodyGyro" then
		local cframe, maxTorque, P = unpack(...)
		local bg = instance("BodyGyro")
		bg.MaxTorque = maxTorque
		bg.P = P
		bg.CFrame = cframe
		return bg
	elseif Type == "Weld" then
		local part0, part1, C0 = unpack(...)
		local weld = instance("Weld")
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C0 = C0
		weld.Parent = part0
		return weld
	elseif Type == "Motor6D" then
		local part0, part1, C0 = unpack(...)
		local weld = instance("Motor6D")
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C0 = C0
		weld.Parent = part0
		return weld
	elseif Type == "StringValue" then
		local name, value = unpack(...)
		local strin = instance("StringValue")
		strin.Name = name
		strin.Value = value or ""
		return strin
	elseif Type == "ParticleEmitter" then
		local tabl = ...
		local particle = findParticle()
		if not particle then
			particle = instance("ParticleEmitter")
			table.insert(particleTable, particle)
		end
		particle.Enabled = true
		particle.Color = tabl.Color or ColorSequence.new(color3(255, 255, 255))
		particle.LightEmission = tabl.LightEmission or 0
		particle.LockedToPart = tabl.LockedToPart or false
		particle.Size = tabl.Size or NumberSequence.new(1)
		particle.Texture = tabl.Texture or ""
		particle.Transparency = tabl.Transparency or NumberSequence.new(0)
		particle.Lifetime = tabl.Lifetime or NumberRange.new(1)
		particle.Rate = tabl.Rate or 1
		particle.Speed = tabl.Speed or NumberRange.new(1)
		particle.SpreadAngle = tabl.SpreadAngle or Vector2.new(0,0)
		particle.Rotation = tabl.Rotation or NumberRange.new(0,0)
		particle.Parent = tabl.Parent or nil
		particle.Drag = tabl.Drag
		particle.ZOffset = tabl.ZOffset or 0
		particle.Acceleration = tabl.Acceleration or Vector3.new(0,0,0)
		return particle
	elseif Type == "Beam" then
		local tabl = ...
		local beam = instance("Beam")
		beam.Segments = 100
		beam.LightEmission = tabl.LightEmission or 0
		beam.Color = tabl.Color or ColorSequence.new(color3(255, 255, 255))
		beam.Texture = tabl.Texture or ""
		beam.TextureLength = tabl.TextureLength or 1
		beam.TextureSpeed = tabl.TextureSpeed or 1
		beam.TextureMode = tabl.TextureMode or "Stretch"
		beam.Transparency = tabl.Transparency or NumberSequence.new(0)
		beam.Attachment0 = tabl.Attachment0 or nil
		beam.Attachment1 = tabl.Attachment1 or nil
		beam.CurveSize0 = tabl.CurveSize0 or 0
		beam.CurveSize1 = tabl.CurveSize1 or 0
		beam.FaceCamera = tabl.FaceCamera or false
		beam.Width0 = tabl.Width0 or 1
		beam.Width1 = tabl.Width1 or 1
		beam.Parent = tabl.Parent or nil
		return beam
	elseif Type == "Trail" then
		local tabl = ...
		local trail = instance("Trail")
		trail.LightEmission = tabl.LightEmission or 0
		trail.Color = tabl.Color or ColorSequence.new(color3(255, 255, 255))
		trail.Texture = tabl.Texture or ""
		trail.Lifetime = tabl.Lifetime or 1
		trail.TextureLength = tabl.TextureLength or 1
		trail.TextureMode = tabl.TextureMode or "Stretch"
		trail.Transparency = tabl.Transparency or NumberSequence.new(0)
		trail.Attachment0 = tabl.Attachment0 or nil
		trail.Attachment1 = tabl.Attachment1 or nil
		trail.FaceCamera = tabl.FaceCamera or false
		trail.WidthScale = tabl.WidthScale or NumberSequence.new(1)
		trail.Parent = tabl.Parent or nil
		return trail
	elseif Type == "Attachment" then
		local parent, position = unpack(...)
		local attachment = instance("Attachment")
		attachment.Parent = parent
		attachment.Position = position
		return attachment
	elseif Type == "Sound" then
		local tabl = ...
		local sound = findSound(head)
		if not sound then
			local success = pcall(function()
				sound = instance("Sound")
				table.insert(soundTable, sound)
			end)
			if not success then return nil end
		end
		sound.Volume = tabl.Volume or 1
		sound.SoundId = tabl.SoundId or ""
		sound.Looped = tabl.Looped or false
		sound.TimePosition = tabl.TimePosition or 0
		sound.Parent = tabl.Parent or head
		if tabl.Play then
			sound:Play()
			coroutine.wrap(function()
				sound.Stopped:Wait()
				sound.Parent = nil
			end)
		elseif tabl.PlayOnRemove then
			sound.PlayOnRemove = true
			sound.Parent       = nil
		end
		return sound
	end
end

function createHitEffect(position)
	coroutine.wrap(function()
		for i = 1,2 do
			coroutine.wrap(function()
				local part = CreateInstance("Part",{vector3(1, 1, 1), "HitEffect", color3(255,255,255), "Neon", 0.5, true, false}) -- size, name, color, material, transparency, anchored, cancollide
				part.CFrame = CFrame.new(position + vector3(random(-20,20)/10, random(-20,20)/10, random(-20,20)/10), position)
				part.Parent = character
				local mesh = CreateInstance("Mesh", {"Sphere", vector3(1,1,1)}) -- meshType, Scale, MeshId, TextureId
				mesh.Parent = part
				local Tween = CreateTween(part, {0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0},{ --[Info]: length, style, direction, repeatTimes, willRepeat, waitTime
					Size = vector3(1, 1, 3),
					Transparency = 1,
					CFrame = part.CFrame + part.CFrame.lookVector * 5
				}) 
				Tween:Play()
				Tween.Completed:Wait()
				NilPart(part)
			end)()
		end
	end)()
end
function createBigHitEffect(position)
	coroutine.wrap(function()
		local part = CreateInstance("Part",{vector3(1, 1, 1), "Part", color3(255,255,255), "Neon", 0.8, true, false}) -- size, name, color, material, transparency, anchored, cancollide
		part.CFrame = CFrame.new(position)
		part.Parent = character
		local mesh = CreateInstance("Mesh", {"Sphere", vector3(1,1,1)}) -- meshType, Scale, MeshId, TextureId
		mesh.Parent = part
		local Tween = CreateTween(part, {0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.InOut, 0, false, 0},{ --[Info]: length, style, direction, repeatTimes, willRepeat, waitTime
			Size = vector3(20, 20, 20),
			Transparency = 1,
		}) 
		Tween:Play()
		for i = 1,15 do
			coroutine.wrap(function()
				local part = CreateInstance("Part",{vector3(1, 1, 1), "Part", color3(255,0,0), "Neon", 0.5, true, false}) -- size, name, color, material, transparency, anchored, cancollide
				part.CFrame = CFrame.new(position + vector3(random(-20,20)/10, random(-20,20)/10, random(-20,20)/10), position)
				part.Parent = character
				local mesh = CreateInstance("Mesh", {"Sphere", vector3(1,1,1)}) -- meshType, Scale, MeshId, TextureId
				mesh.Parent = part
				local Tween = CreateTween(part, {0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0},{ --[Info]: length, style, direction, repeatTimes, willRepeat, waitTime
					Size = vector3(1, 1, 10),
					Transparency = 1,
					CFrame = part.CFrame + part.CFrame.lookVector * 30
				}) 
				Tween:Play()
				Tween.Completed:Wait()
				NilPart(part)
			end)()
		end
		Tween.Completed:Wait()
		NilPart(part)
	end)()
end
function CheckIfPartInPlayer(part)
	for i,v in pairs(character:GetDescendants()) do
		if v == part then
			return true
		end
	end
	return false
end
function GetPartsInRegion(Position, Size)
	local SizeOffset = Size/2
	local Point1 = Position - SizeOffset
	local Point2 = Position + SizeOffset
	local region = Region3.new(Point1,Point2)
	local partsInRegion = workspace:FindPartsInRegion3(region,nil,math.huge)
	local Parts = {}
	for _,Part in pairs(partsInRegion) do
		if not CheckIfPartInPlayer(Part) and Part.Name ~= "Base" and not Part.Parent:FindFirstChild("Humanoid") and not Part.Parent:FindFirstChild("Accessory") then
			table.insert(Parts, Part)
		end
	end
	return Parts
end

function Damage(pos, mag, damage)
	coroutine.wrap(function()
		local partDamaged = false
		if timeStop then
			tsActivate.Changed:Wait()
		end
		if damage < 20 then
			for i,v in pairs(GetPartsInRegion(pos, vector3(5,5,5))) do
				partDamaged = true
				if not anchored then
				    v.Anchored = false
				end
				if not dmg then
				    v.Velocity = rootPart.CFrame.lookVector * 50
				elseif dmg then
				    if mag <= 3 then
				    --wait(math.random(1,2))
				    if debug then
				        notify("Damage Delay", "Output".." ".."Received", 2)
				    end
				    --spawn(function()
				    at(plr.Character,{
	HitEffect = "BurstEffect", 
    Sound = nil, 
    Velocity = plr.Character.HumanoidRootPart.CFrame.lookVector * 0.5, 
    Type = "Light", 
    HitTime = 1,
    HurtAnimation = rep.Animations.HurtAnimations["Hurt" .. math.random(1, 3)], 
    VictimCFrame = plr.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(180), 0) + plr.Character.HumanoidRootPart.CFrame.lookVector * 6, 
    Damage = 10
},"Bump") elseif mag >= 4 then
				    wait(1)
				    if debug then
				        notify("Damage Connection", "Heavy Hit", 2)
				    end
				    --spawn(function()
at(plr.Character,{
	HitEffect = "BiggerBurstEffect", 
    Sound = nil, 
    Velocity = plr.Character.HumanoidRootPart.CFrame.lookVector * 50, 
    Type = "Knockback", 
    HitTime = 1,
    HurtAnimation = rep.Animations.HurtAnimations["Hurt" .. math.random(1, 3)], 
    VictimCFrame = plr.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(180), 0) + plr.Character.HumanoidRootPart.CFrame.lookVector * 6, 
    Damage = 40
},"Explosion") --end)
end

				end
				if v:FindFirstChildOfClass("Weld") then
					v:FindFirstChildOfClass("Weld"):Destroy()
				end
			end
			if partDamaged then
				local slashSound = CreateInstance("Sound", {
					SoundId = "rbxassetid://262562442",
					Looped = false,
					Volume = 5,
					Parent = head,
					Play = false,
					TimePosition = 0,
					PlayOnRemove = true
				})
				createHitEffect(pos)
			end
		else
			for i,v in pairs(GetPartsInRegion(pos, vector3(5,5,5))) do
				partDamaged = true
				if not anchored then
				    v.Anchored = false
				end
				if not dmg then
				    v.Velocity = rootPart.CFrame.lookVector * 200
				end
			end
			if partDamaged then
				local slashSound = CreateInstance("Sound", {
					SoundId = "rbxassetid://258057783",
					Looped = false,
					Volume = 5,
					Parent = head,
					Play = false,
					TimePosition = 0,
					PlayOnRemove = true
				})
				createBigHitEffect(pos)
			end
		end
	end)()
	for i,v in pairs(workspace:GetChildren()) do
		if v:FindFirstChildOfClass("Humanoid") and v ~= character and v:FindFirstChildOfClass("Humanoid").Health > 0 then
			coroutine.wrap(function()
				if timeStop then
					tsActivate.Changed:Wait()
				end
				local victim = v
				local rootPart2 = v:FindFirstChild("HumanoidRootPart")
				local humanoid2 = v:FindFirstChildOfClass("Humanoid")
				if rootPart2 and (pos - rootPart2.Position).magnitude <= mag and humanoid2 then
				    if not anchored then
					    rootPart2.Anchored = false
					end
					for i,v in pairs(rootPart2:GetChildren()) do
						if v:IsA("BodyMover") then
							v:Destroy()
						end
					end
                    if not dmg then
					    local bv = CreateInstance("BodyVelocity",{rootPart.CFrame.lookVector * damage, vector3(100000,100000,100000), 10000})
					    bv.Parent = rootPart2
					    Debris:AddItem(bv, 1)
					end
					if humanoid2.MaxHealth > 100 then
						humanoid2.MaxHealth = 100
						humanoid2.Health = 100
					end
					humanoid2.Health = humanoid2.Health + damage
					if damage < 20 then
						createHitEffect(rootPart2.Position)
						local slashSound = CreateInstance("Sound", {
							SoundId = "rbxassetid://3201554155",
							Looped = false,
							Volume = 5,
							Parent = head,
							Play = false,
							TimePosition = 0,
							PlayOnRemove = true
						})
					else
						bv.MaxForce = vector3(100000,0,100000)
						createBigHitEffect(rootPart2.Position)
						humanoid2.PlatformStand = true
						rootPart2.CFrame = rootPart2.CFrame * CFrame.Angles(math.rad(math.random(-200,200)), math.rad(math.random(-200,200)), math.rad(math.random(-200,200)))
						local slashSound        = CreateInstance("Sound", {
							SoundId = "rbxassetid://3201554385",
							Looped = false,
							Volume = 5,
							Parent = head,
							Play = false,
							TimePosition = 0,
							PlayOnRemove = true
						})
						coroutine.wrap(function()
							wait(2)
							humanoid2.PlatformStand = false
						end)()
					end
				end
			end)()
		end
	end
end

function AddClothes(shirtID, pantsID)
	if character:FindFirstChildOfClass("Shirt") then
		character:FindFirstChildOfClass("Shirt").ShirtTemplate = shirtID
	else
		local shirt = instance("Shirt")
		shirt.ShirtTemplate = shirtID
		shirt.Parent = character
	end
	if character:FindFirstChildOfClass("Pants") then
		character:FindFirstChildOfClass("Pants").PantsTemplate = pantsID
	else
		local shirt = instance("Pants")
		shirt.PantsTemplate = pantsID
		shirt.Parent = character
	end
end
local timeStopItems = {}
local timeStopColors = {}
local anchoredObjects = {}
function Paint(Brick)
	if Brick.Name == "NewBase" then return end
	if Brick.Name == "Base" then
		Brick.Transparency = 1
		local newBase = Brick:FindFirstChild("NewBase")
		if not newBase then
			local newBase = Brick:Clone()
			newBase.Name = "NewBase"
			newBase.CanCollide = true
			newBase.CFrame = Brick.CFrame
			newBase.Transparency = 0
			newBase.Parent = Brick
			Brick = newBase
		else
			return
		end
	end

	local s = CreateInstance("StringValue", {"Colored", nil})
	s.Parent = Brick
	table.insert(timeStopItems, Brick)
	table.insert(timeStopColors, Brick.Color)
	local Constant = (Brick.BrickColor.r + Brick.BrickColor.b + Brick.BrickColor.g)/3
	Brick.Color    = Color3.new(Constant, Constant, Constant)
end
function Anchor(Brick, ws)
	local s = CreateInstance("StringValue", {"Anchoreds", nil})
	s.Parent = Brick
	table.insert(anchoredObjects, Brick)
	if not ws then
		Brick.Anchored = true
	end
end
function timeStopColor(Object)
	unColored = false
	if Object:IsA("BasePart") and not Object:FindFirstChild("Colored") and Object.Name ~= "NewBase" and Object.Name ~= "HitEffect" then Paint(Object) end
	for _, Thing in ipairs(Object:GetChildren()) do
		if Thing:IsA("BasePart") and not Thing:FindFirstChild("Colored") and Thing.Name ~= "NewBase" and Thing.Name ~= "HitEffect" then Paint(Thing) end
		if Thing ~= character and Thing.Name ~= "HitEffect" and Thing.Name ~= "NewBase" then
			timeStopColor(Thing)
		end
	end
end
function anchorObject(Object)
	if Object:IsA("BasePart") and not Object:FindFirstChild("Anchoreds") and Object.Name ~= "NewBase" and Object.Name ~= "HitEffect" and not Object.Anchored then Object.Anchored = true Anchor(Object) end
	for _, Thing in ipairs(Object:GetChildren()) do
		if Thing:IsA("BasePart") and not Thing.Parent:FindFirstChildOfClass("Humanoid") and not Thing:FindFirstChild("Anchoreds") and Thing.Name ~= "NewBase" and Thing.Name ~= "HitEffect" and not Thing.Anchored then
			Thing.Anchored = true
			Anchor(Thing)
		elseif Thing.Parent:FindFirstChildOfClass("Humanoid") then
			Thing.Parent:FindFirstChildOfClass("Humanoid").WalkSpeed = 1
			Thing.Parent:FindFirstChildOfClass("Humanoid").JumpPower = 0
			Anchor(Thing, true)
		end
		if Thing ~= character and Thing.Name ~= "HitEffect" and Thing.Name ~= "NewBase" and not Thing.Parent:FindFirstChildOfClass("Humanoid") then
			anchorObject(Thing)
		end
	end
end
function returnUnAnchored()
	for i = 1, #anchoredObjects do
		if anchoredObjects[i]:IsA("BasePart") then
		    if not anchored then
			    anchoredObjects[i].Anchored = false
		    end
		end
		if anchoredObjects[i]:FindFirstChild("Anchoreds") then
			anchoredObjects[i].Anchoreds:Destroy()
		end
		if anchoredObjects[i].Parent and anchoredObjects[i].Parent:FindFirstChildOfClass("Humanoid") then
			anchoredObjects[i].Parent:FindFirstChildOfClass("Humanoid").WalkSpeed = 16
			anchoredObjects[i].Parent:FindFirstChildOfClass("Humanoid").JumpPower = 50
		end
	end
	for i = 1, #anchoredObjects do
		table.remove(anchoredObjects, i)
	end
end
function returnColors()
	unColored = true
	if timeStopItems[1] then
		for i = 1, #timeStopItems do
			if timeStopItems[i].Name ~= "NewBase" then
				if timeStopItems[i]:FindFirstChild("Colored") then
					timeStopItems[i].Colored:Destroy()
				end
				local item = timeStopItems[i]
				local color2 = timeStopColors[i]
				item.Color   = color2
			else
				if workspace:FindFirstChild("Base") then workspace:FindFirstChild("Base").Transparency = 0 end timeStopItems[i]:Destroy()
			end
		end
		for i = 1, #timeStopItems do
			table.remove(timeStopItems, i)
		end
		for i = 1, #timeStopColors do
			table.remove(timeStopColors, i)
		end
	end
end
local talking = false
local newtalk = false
function Talk(text, speed, Color)
	coroutine.wrap(function()
	    spawn(function()
	        if debug then
	            notify("Text Responce", text.." ".."Received", 2)
	       end
	       game.ReplicatedStorage.Remotes.Events:FireServer({ pass, "Chatted", text, Color3.fromRGB(255, 128, 1)})
	    end)
		newtalk = true
		TalkText.Text = ""
		TalkText.Position = UDim2.new(0,0,0,0)
		TalkText.TextStrokeTransparency = 1
		TalkText.TextTransparency = 0
		TalkText.TextColor3 = Color
		TalkText.TextStrokeColor3 = Color
		for i = 1,string.len(text),1 do
			if i == 5 then newtalk = false end
			if i > 5 and newtalk then break end
			TalkText.Text = string.sub(text,1,i)
			TalkText.Rotation = random(-10,10)
			talking = true
			wait(speed)
		end
		talking = false
		for i = 1, 5 do
			if talking then break end
			TalkText.Rotation = random(-10,10)
			wait() end
		for i = 1,10 do
			if talking then break end
			TalkText.Position = TalkText.Position + UDim2.new(0,0.1,0,0)
			TalkText.TextTransparency = TalkText.TextTransparency + 1/10
			wait() end
	end)()
end
plr.Chatted:connect(function(p4) Talk(p4,0.1,Color3.new(1, 1, 1)); end);
function TimeStop()
	local attachment0 = CreateInstance("Attachment", {torso, vector3(0, 0, 0)})
	local particle1 = CreateInstance("ParticleEmitter",{
		Color = ColorSequence.new(color3(255,255,255)),
		LightEmission = 0,
		Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0), NumberSequenceKeypoint.new(1,500)}),
		Transparency = NumberSequence.new(0.95),
		Texture = "rbxassetid://232918622",
		Lifetime = NumberRange.new(0.5),
		Rate = 100,
		Speed = NumberRange.new(0),
		Rotation = NumberRange.new(0,360),
		SpreadAngle = Vector2.new(0,0),
		Parent = attachment0,
		Drag = 0,
		ZOffset = 2,
		Acceleration = Vector3.new(0,0,0),
		EmissionDirection = "Top",
		LockedToPart = false
	})
	local particle2 = CreateInstance("ParticleEmitter",{
		Color = ColorSequence.new(color3(255,255,255)),
		LightEmission = 0,
		Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0), NumberSequenceKeypoint.new(1,500)}),
		Transparency = NumberSequence.new(0),
		Texture = "rbxassetid://1460900924",
		Lifetime = NumberRange.new(0.5),
		Rate = 100,
		Speed = NumberRange.new(0),
		Rotation = NumberRange.new(0,360),
		SpreadAngle = Vector2.new(0,0),
		Parent = attachment0,
		Drag = 0,
		ZOffset = 2,
		Acceleration = Vector3.new(0,0,0),
		EmissionDirection = "Top",
		LockedToPart = false
	})
	local originalColor = Color3.new(0,0,0)
	for i = 1,30 do
		if i < 10 then
			Lighting.Ambient = Lighting.Ambient:lerp(Color3.fromRGB(34,202,202),0.1)
			Lighting.ColorShift_Bottom = Lighting.ColorShift_Bottom:lerp(Color3.fromRGB(34,202,202),0.1)
			Lighting.ColorShift_Top = Lighting.ColorShift_Top:lerp(Color3.fromRGB(34,202,202),0.1)
			Lighting.OutdoorAmbient = Lighting.OutdoorAmbient:lerp(Color3.fromRGB(34,202,202),0.1)
		elseif i > 10 and i < 30 then
			Lighting.Ambient = Lighting.Ambient:lerp(Color3.fromRGB(202,23,202),0.1)
			Lighting.ColorShift_Bottom = Lighting.ColorShift_Bottom:lerp(Color3.fromRGB(202,23,202),0.1)
			Lighting.ColorShift_Top = Lighting.ColorShift_Top:lerp(Color3.fromRGB(202,23,202),0.1)
			Lighting.OutdoorAmbient = Lighting.OutdoorAmbient:lerp(Color3.fromRGB(202,23,202),0.1)
		end
		wait() end
	if particle1 then
		particle1.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,500), NumberSequenceKeypoint.new(1,0)})
	end
	if particle2 then
		particle2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,500), NumberSequenceKeypoint.new(1,0)})
	end
	for i = 1,20 do
		if i < 10 then
			Lighting.Ambient = Lighting.Ambient:lerp(Color3.fromRGB(255,154,20),0.1)
			Lighting.ColorShift_Bottom = Lighting.ColorShift_Bottom:lerp(Color3.fromRGB(255,154,20),0.1)
			Lighting.ColorShift_Top = Lighting.ColorShift_Top:lerp(Color3.fromRGB(255,154,20),0.1)
			Lighting.OutdoorAmbient = Lighting.OutdoorAmbient:lerp(Color3.fromRGB(255,154,20),0.1)
		elseif i > 10 then
			Lighting.Ambient = Lighting.Ambient:lerp(originalColor,0.2)
			Lighting.ColorShift_Bottom = Lighting.ColorShift_Bottom:lerp(originalColor,0.2)
			Lighting.ColorShift_Top = Lighting.ColorShift_Top:lerp(originalColor,0.2)
			Lighting.OutdoorAmbient = Lighting.OutdoorAmbient:lerp(originalColor,0.2)
		end
		wait() end
	if particle1 then
		particle1.Enabled = false
	end
	if particle2 then
		particle2.Enabled = false
	end
	coroutine.wrap(function()
		wait(0.5)
		NilEffects(attachment0)
	end)()
end

function checkIfStringExists(parent, name)
	for i,v in pairs(parent:GetChildren()) do
		if v.Name == name then
			return true
		end
	end
	return false
end

function CreateTween(part, info, goal, play) --[Info]: length, style, direction, repeatTimes, willRepeat, waitTime
	local Goal = goal
	local TwInfo = TweenInfo.new(unpack(info))
	local Tween = TweenService:Create(part, TwInfo, Goal)
	if play then Tween:Play() end
	return Tween
end

function cameraShake(power)
	coroutine.wrap(function()
		local base = Workspace:FindFirstChild("Base")
		if base then
			base.Transparency = 0
			local newBase = workspace:FindFirstChild("NewBase")
			if not newBase then
				local newBase = base:Clone()
				newBase.Name = "NewBase"
				newBase.CanCollide = true
				newBase.CFrame = base.CFrame
				newBase.Transparency = 0
				newBase.Parent = workspace
			end
			newBase = workspace:FindFirstChild("NewBase")
			local reduce = power
			local original = reduce
			local orgCF = base.CFrame
			for i = 1, 5 do
				if not newBase then break end
				newBase.CFrame = orgCF + Vector3.new(random(-reduce,reduce)/5, random(-reduce,reduce)/5, random(-reduce,reduce)/5)
				reduce = reduce - original/5
				wait() end
			newBase.CFrame = orgCF
		end
	end)()
end

function activateStand(activate)
	if activate then
		if rootPart:FindFirstChild("Weld") then
			rootPart.Weld:Destroy()
		end
		stand.HumanoidRootPart.Anchored = true
		local Sound = CreateInstance("Sound", {
			SoundId = "rbxassetid://1438146024",
			Looped = false,
			Pitch = .5,
			Volume = 10,
			Parent = head,
			Play = false,
			TimePosition = 0,
			PlayOnRemove = true
		})
		for i = 1,10 do
			for i,v in pairs(stand:GetDescendants()) do
				if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then
					v.Transparency = v.Transparency - 1/10
				elseif v.Name == "Snap" or v:IsA("Snap") then
					v:Destroy()
				elseif v.Name == "BurstStart" then
					coroutine.wrap(function()
						v.Enabled = true
						wait(0.1)
						v.Enabled = false
					end)()
				end
			end
			wait() end
	else
		for i = 1,10 do
			for i,v in pairs(stand:GetDescendants()) do
				if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then
					v.Transparency = v.Transparency + 1/10
				elseif v.Name == "Snap" or v:IsA("Snap") then
					v:Destroy()
				end
			end
			wait() end
		stand.HumanoidRootPart.Anchored = false
		CreateInstance("Weld",{rootPart, stand.HumanoidRootPart, CFrame.new()})
	end
end
local Animations = {}
--[Animations]--

function Animations.TimeStopPlayer(speed)
	local stopped = false
	local nex = false
	local origSpeed = speed
	local event = stopAnimationsValue.Changed:Connect(function(changedTo) if changedTo then stopAnimationsValue.Value = false stopped = true end end)
	local event2 = adjustSpeed.Changed:Connect(function(changedTo) speed = origSpeed - changedTo end)

	local RSTween = CreateTween(RS, {speed, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0},{
		C0 = RSC0 * CFrame.Angles(math.rad(15.527), math.rad(48.701), math.rad(49.905)),
	}, true)
	local LSTween = CreateTween(LS, {speed, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0},{
		C0 = LSC0 * CFrame.Angles(math.rad(-0.974), math.rad(-59.015), math.rad(-52.368)),
	}, true)
	local NeckTween = CreateTween(Neck, {speed, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0},{
		C0 = NeckC0 * CFrame.Angles(math.rad(24.809), 0, 0),
	}, true)
	local RootJointTween = CreateTween(RootJoint, {speed, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0},{
		C0 = RootJointC0 * CFrame.new(0, -0.301, -0.073),
	}, true)
	local LHTween = CreateTween(LH, {speed, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0},{
		C0 = LHC0 * CFrame.new(-0.449, 0.131, -0.02) * CFrame.Angles(math.rad(-9.225), math.rad(0.115), math.rad(-2.235)),
	}, true)
	local RHTween = CreateTween(RH, {speed, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0},{
		C0 = RHC0 * CFrame.new(0.492, 0.172, -0.004) * CFrame.Angles(math.rad(-9.167), math.rad(-2.521), math.rad(1.891)),
	}, true)
	RootJointTween.Completed:Connect(function() nex = true end)
	repeat wait() until nex or stopped
	if stopped then event2:disconnect() event:disconnect() RSTween:Cancel() LSTween:Cancel() NeckTween:Cancel() RootJointTween:Cancel() LHTween:Cancel() RHTween:Cancel() return end nex = false
	-------------------------------------------------------------------------------
	local RSTween = CreateTween(RS, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.In, 0, false, 0},{
		C0 = RSC0 * CFrame.new(0.161, 0.362, -0.175) * CFrame.Angles(math.rad(6.99), math.rad(53.572), math.rad(141.349)),
	}, true)
	local LSTween = CreateTween(LS, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.In, 0, false, 0},{
		C0 = LSC0 * CFrame.new(-0.085, 0.373, -0.148) * CFrame.Angles(math.rad(-0.974), math.rad(-59.015), math.rad(-156.188)),
	}, true)
	local NeckTween = CreateTween(Neck, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.In, 0, false, 0},{
		C0 = NeckC0 * CFrame.new(0, -0.001, -0.004) * CFrame.Angles(math.rad(-0.458), 0, 0),
	}, true)
	local RootJointTween = CreateTween(RootJoint, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.In, 0, false, 0},{
		C0 = RootJointC0 * CFrame.new(0, -0.301, -0.019),
	}, true)
	local LHTween = CreateTween(LH, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.In, 0, false, 0},{
		C0 = LHC0 * CFrame.new(-0.26, -0.027, 0.04) * CFrame.Angles(math.rad(-6.532), 0, math.rad(-2.235)),
	}, true)
	local RHTween = CreateTween(RH, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.In, 0, false, 0},{
		C0 = RHC0 * CFrame.new(0.183, 0.078, 0.034) * CFrame.Angles(math.rad(-9.167), math.rad(-2.521), math.rad(1.891)),
	}, true)
	RootJointTween.Completed:Connect(function() nex = true end)
	repeat wait() until nex or stopped
	if stopped then event2:disconnect() event:disconnect() RSTween:Cancel() LSTween:Cancel() NeckTween:Cancel() RootJointTween:Cancel() LHTween:Cancel() RHTween:Cancel() return end nex = false
	-------------------------------------------------------------------------------
	local RSTween = CreateTween(RS, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = RSC0 * CFrame.new(0.012, -0.025, 0.152) * CFrame.Angles(math.rad(60.734), math.rad(-12.949), math.rad(149.886)),
	}, true)
	local LSTween = CreateTween(LS, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = LSC0 * CFrame.new(-0.025, 0.055, 0.138) * CFrame.Angles(math.rad(67.437), math.rad(-0.974), math.rad(-150.86)),
	}, true)
	local NeckTween = CreateTween(Neck, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = NeckC0 * CFrame.Angles(math.rad(-31.971), 0, 0),
	}, true)
	local RootJointTween = CreateTween(RootJoint, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = RootJointC0 * CFrame.new(0, -0.301, 0.081) * CFrame.Angles(math.rad(-2.12), 0, 0),
	}, true)
	local LHTween = CreateTween(LH, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = LHC0 * CFrame.new(-0.26, -0.027, 0.04) * CFrame.Angles(math.rad(-6.532), 0, math.rad(9.683)),
	}, true)
	local RHTween = CreateTween(RH, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = RHC0 * CFrame.new(0.183, 0.078, 0.034) * CFrame.Angles(math.rad(-9.167), math.rad(-2.521), math.rad(-5.042)),
	}, true)
	RootJointTween.Completed:Connect(function() nex = true end)
	repeat wait() until nex or stopped
	if stopped then event2:disconnect() event:disconnect() RSTween:Cancel() LSTween:Cancel() NeckTween:Cancel() RootJointTween:Cancel() LHTween:Cancel() RHTween:Cancel() return end nex = false
	-------------------------------------------------------------------------------
	event:disconnect()
	event2:disconnect()
end

function Animations.StandBarrage(speed)
	local stopped = false
	local nex = false
	local origSpeed = speed
	local event = stopAnimationsValue.Changed:Connect(function(changedTo) if changedTo then stopAnimationsValue.Value = false stopped = true end end)
	local event2 = adjustSpeed.Changed:Connect(function(changedTo) speed = origSpeed - changedTo end)

	local RSTween = CreateTween(standRS, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, false, 0},{
		C0 = standRSC0 * CFrame.new(-0.59, -0.112, 0.008) * CFrame.Angles(math.rad(math.random(-60,0)), math.rad(-16.272), math.rad(100.841)),
	}, true)
	local LSTween = CreateTween(standLS, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, false, 0},{
		C0 = standLSC0 * CFrame.new(-0.536, -0.165, 0.365) * CFrame.Angles(math.rad(math.random(-30,30)), math.rad(72.021), math.rad(-57.697)),
	}, true)
	local NeckTween = CreateTween(standNeck, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, false, 0},{
		C0 = standNeckC0 * CFrame.Angles(math.rad(6.875), math.rad(15.298), math.rad(88.293)),
	}, true)
	local RootJointTween = CreateTween(standRootJoint, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, false, 0},{
		C0 = standRootJointC0 * CFrame.new(0, -3.391, 0) * CFrame.Angles(math.rad(-7.62), math.rad(1.604), math.rad(-94.71)),
	}, true)
	local LHTween = CreateTween(standLH, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, false, 0},{
		C0 = standLHC0 * CFrame.new(-0.443, 0.07, 0.499) * CFrame.Angles(math.rad(1.261), math.rad(49.733), math.rad(59.187)),
	}, true)
	local RHTween = CreateTween(standRH, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, false, 0},{
		C0 = standRHC0 * CFrame.Angles(math.rad(-27.158), math.rad(-50.191), math.rad(-9.397)),
	}, true)
	RootJointTween.Completed:Connect(function() nex = true end)
	repeat wait() until nex or stopped
	if stopped then event2:disconnect() event:disconnect() RSTween:Cancel() LSTween:Cancel() NeckTween:Cancel() RootJointTween:Cancel() LHTween:Cancel() RHTween:Cancel() return end nex = false
	-------------------------------------------------------------------------------
	local RSTween = CreateTween(standRS, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, false, 0},{
		C0 = standRSC0 * CFrame.new(0.729, 0.192, 0.312) * CFrame.Angles(math.rad(math.random(-30,30)), math.rad(-69.786), math.rad(93.679)),
	}, true)
	local LSTween = CreateTween(standLS, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, false, 0},{
		C0 = standLSC0 * CFrame.new(0.182, -0.04, -0.012) * CFrame.Angles(math.rad(math.random(-60,0)), math.rad(18.621), math.rad(-101.929)),
	}, true)
	local NeckTween = CreateTween(standNeck, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, false, 0},{
		C0 = standNeckC0 * CFrame.Angles(math.rad(1.547), math.rad(7.334), math.rad(-79.813)),
	}, true)
	local RootJointTween = CreateTween(standRootJoint, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, false, 0},{
		C0 = standRootJointC0 * CFrame.new(0, -3.391, 0) * CFrame.Angles(math.rad(8.881), math.rad(-3.782), math.rad(82.162)),
	}, true)
	local LHTween = CreateTween(standLH, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, false, 0},{
		C0 = standLHC0 * CFrame.new(-1.679, 0.202, -0.392) * CFrame.Angles(math.rad(7.792), math.rad(-36.096), math.rad(58.957)),
	}, true)
	local RHTween = CreateTween(standRH, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, false, 0},{
		C0 = standRHC0 * CFrame.new(-0.447, -0.129, -0.73) * CFrame.Angles(math.rad(162.777), math.rad(-23.663), math.rad(-173.434)),
	}, true)
	RootJointTween.Completed:Connect(function() nex = true end)
	repeat wait() until nex or stopped
	if stopped then event2:disconnect() event:disconnect() RSTween:Cancel() LSTween:Cancel() NeckTween:Cancel() RootJointTween:Cancel() LHTween:Cancel() RHTween:Cancel() return end nex = false
	-------------------------------------------------------------------------------
	event:disconnect()
	event2:disconnect()
end

function Animations.StandBarrageFinal(speed)
	local stopped = false
	local nex = false
	local origSpeed = speed
	local event = stopAnimationsValue.Changed:Connect(function(changedTo) if changedTo then stopAnimationsValue.Value = false stopped = true end end)
	local event2 = adjustSpeed.Changed:Connect(function(changedTo) speed = origSpeed - changedTo end)

	local RSTween = CreateTween(standRS, {speed, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standRSC0 * CFrame.new(-0.59, -0.112, 0.008) * CFrame.Angles(math.rad(-16.043), math.rad(-16.272), math.rad(100.841)),
	}, true)
	local LSTween = CreateTween(standLS, {speed, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standLSC0 * CFrame.new(-0.536, -0.165, 0.365) * CFrame.Angles(math.rad(7.678), math.rad(20.569), math.rad(-79.87)),
	}, true)
	local NeckTween = CreateTween(standNeck, {speed, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standNeckC0 * CFrame.Angles(math.rad(-0.286), math.rad(5.901), math.rad(21.429)),
	}, true)
	local RootJointTween = CreateTween(standRootJoint, {speed, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standRootJointC0 * CFrame.new(0, -3.391, 0) * CFrame.Angles(math.rad(-7.62), math.rad(1.604), math.rad(-15.814)),
	}, true)
	local LHTween = CreateTween(standLH, {speed, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standLHC0 * CFrame.new(-0.443, 0.07, 0.499) * CFrame.Angles(math.rad(1.261), math.rad(49.733), math.rad(59.187)),
	}, true)
	local RHTween = CreateTween(standRH, {speed, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standRHC0 * CFrame.Angles(math.rad(-27.158), math.rad(-50.191), math.rad(-9.397)),
	}, true)
	RootJointTween.Completed:Connect(function() nex = true end)
	repeat wait() until nex or stopped
	if stopped then event2:disconnect() event:disconnect() RSTween:Cancel() LSTween:Cancel() NeckTween:Cancel() RootJointTween:Cancel() LHTween:Cancel() RHTween:Cancel() return end nex = false
	-------------------------------------------------------------------------------
	local RSTween = CreateTween(standRS, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standRSC0 * CFrame.new(-0.59, -0.112, 0.008) * CFrame.Angles(math.rad(-5.787), math.rad(-51.452), math.rad(106.857)),
	}, true)
	local LSTween = CreateTween(standLS, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standLSC0 * CFrame.new(-0.536, -0.165, 0.365) * CFrame.Angles(math.rad(-65.317), math.rad(80.214), math.rad(-13.178)),
	}, true)
	local NeckTween = CreateTween(standNeck, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standNeckC0 * CFrame.Angles(math.rad(-0.286), math.rad(5.901), math.rad(66.979)),
	}, true)
	local RootJointTween = CreateTween(standRootJoint, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standRootJointC0 * CFrame.new(0, -3.391, 0) * CFrame.Angles(math.rad(-7.62), math.rad(1.604), math.rad(-74.886)),
	}, true)
	local LHTween = CreateTween(standLH, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standLHC0 * CFrame.new(-0.443, 0.07, 0.499) * CFrame.Angles(math.rad(-4.354), math.rad(42.743), math.rad(63.197)),
	}, true)
	local RHTween = CreateTween(standRH, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standRHC0 * CFrame.Angles(math.rad(-43.258), math.rad(-47.212), math.rad(-21.543)),
	}, true)
	RootJointTween.Completed:Connect(function() nex = true end)
	repeat wait() until nex or stopped
	if stopped then event2:disconnect() event:disconnect() RSTween:Cancel() LSTween:Cancel() NeckTween:Cancel() RootJointTween:Cancel() LHTween:Cancel() RHTween:Cancel() return end nex = false
	-------------------------------------------------------------------------------
	local RSTween = CreateTween(standRS, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standRSC0 * CFrame.new(0.807, -0.171, 0.19) * CFrame.Angles(math.rad(-1.547), math.rad(-58.728), math.rad(85.829)),
	}, true)
	local LSTween = CreateTween(standLS, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standLSC0 * CFrame.new(-0.009, 0.02, -0.108) * CFrame.Angles(math.rad(21.314), math.rad(-46.066), math.rad(-76.261)),
	}, true)
	local NeckTween = CreateTween(standNeck, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standNeckC0 * CFrame.Angles(math.rad(5.5), math.rad(-14.095), math.rad(-73.568)),
	}, true)
	local RootJointTween = CreateTween(standRootJoint, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standRootJointC0 * CFrame.new(0, -3.391, 0) * CFrame.Angles(math.rad(-7.62), math.rad(1.604), math.rad(84.168)),
	}, true)
	local LHTween = CreateTween(standLH, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standLHC0 * CFrame.new(-1.086, -0.018, -0.217) * CFrame.Angles(math.rad(-27.158), math.rad(-11.058), math.rad(70.302)),
	}, true)
	local RHTween = CreateTween(standRH, {speed, Enum.EasingStyle.Quad, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standRHC0 * CFrame.Angles(math.rad(-43.258), math.rad(-47.212), math.rad(-21.543)),
	}, true)
	RootJointTween.Completed:Connect(function() nex = true end)
	repeat wait() until nex or stopped
	if stopped then event2:disconnect() event:disconnect() RSTween:Cancel() LSTween:Cancel() NeckTween:Cancel() RootJointTween:Cancel() LHTween:Cancel() RHTween:Cancel() return end nex = false
	-------------------------------------------------------------------------------
	local RSTween = CreateTween(standRS, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standRSC0 * CFrame.new(0.807, -0.171, 0.19) * CFrame.Angles(math.rad(-5.844), math.rad(62.682), math.rad(105.825)),
	}, true)
	local LSTween = CreateTween(standLS, {speed+0.1, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standLSC0 * CFrame.new(-0.009, 0.02, -0.108) * CFrame.Angles(math.rad(26.241), math.rad(50.191), math.rad(-125.306)),
	}, true)
	local NeckTween = CreateTween(standNeck, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standNeckC0 * CFrame.Angles(math.rad(-0.286), math.rad(-16.616), math.rad(-115.107)),
	}, true)
	local RootJointTween = CreateTween(standRootJoint, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standRootJointC0 * CFrame.new(0, -3.391, 0) * CFrame.Angles(math.rad(-5.099), math.rad(-5.901), math.rad(144.901)),
	}, true)
	local LHTween = CreateTween(standLH, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standLHC0 * CFrame.new(-1.086, -0.018, -0.217) * CFrame.Angles(math.rad(-27.158), math.rad(-11.058), math.rad(70.302)),
	}, true)
	local RHTween = CreateTween(standRH, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standRHC0 * CFrame.Angles(math.rad(-43.258), math.rad(-47.212), math.rad(-21.543)),
	}, true)
	LSTween.Completed:Connect(function() nex = true end)
	repeat wait() until nex or stopped
	if stopped then event2:disconnect() event:disconnect() RSTween:Cancel() LSTween:Cancel() NeckTween:Cancel() RootJointTween:Cancel() LHTween:Cancel() RHTween:Cancel() return end nex = false
	-------------------------------------------------------------------------------
	event:disconnect()
	event2:disconnect()
end

function Animations.WRYYY(speed)
	local stopped = false
	local nex = false
	local origSpeed = speed
	local event = stopAnimationsValue.Changed:Connect(function(changedTo) if changedTo then stopAnimationsValue.Value = false stopped = true end end)
	local event2 = adjustSpeed.Changed:Connect(function(changedTo) speed = origSpeed - changedTo end)

	local RSTween = CreateTween(RS, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standRSC0 * CFrame.new(0.096, 0.217, 0) * CFrame.Angles(math.rad(-25.611), math.rad(60.39), math.rad(117.284)),
	}, true)
	local LSTween = CreateTween(LS, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standLSC0 * CFrame.new(-0.084, 0.19, 0) * CFrame.Angles(math.rad(-21.486), math.rad(-55.577), math.rad(-115.165)),
	}, true)
	local NeckTween = CreateTween(Neck, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standNeckC0 * CFrame.Angles(math.rad(20.283), 0, 0),
	}, true)
	local RootJointTween = CreateTween(RootJoint, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standRootJointC0 * CFrame.new(0, 0, -0.501) * CFrame.Angles(math.rad(-24.637), 0, 0),
	}, true)
	local LHTween = CreateTween(LH, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standLHC0 * CFrame.new(-0.114, 0.382, 0) * CFrame.Angles(math.rad(-13.923), math.rad(15.126), math.rad(34.721)),
	}, true)
	local RHTween = CreateTween(RH, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.In, 0, false, 0},{
		C0 = standRHC0 * CFrame.new(0.15, 0.385, 0) * CFrame.Angles(math.rad(-17.647), math.rad(-17.189), math.rad(-32.2)),
	}, true)
	RootJointTween.Completed:Connect(function() nex = true end)
	repeat wait() until nex or stopped
	if stopped then event2:disconnect() event:disconnect() RSTween:Cancel() LSTween:Cancel() NeckTween:Cancel() RootJointTween:Cancel() LHTween:Cancel() RHTween:Cancel() return end nex = false
	-------------------------------------------------------------------------------
	local RSTween = CreateTween(RS, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standRSC0 * CFrame.new(-0.348, -0.174, 0.037) * CFrame.Angles(math.rad(0.917), math.rad(-39.706), math.rad(123.129)),
	}, true)
	local LSTween = CreateTween(LS, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standLSC0 * CFrame.new(0.067, -0.179, -0.066) * CFrame.Angles(math.rad(15.069), math.rad(45.092), math.rad(-133.786)),
	}, true)
	local NeckTween = CreateTween(Neck, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standNeckC0 * CFrame.Angles(math.rad(-1.948), 0, 0),
	}, true)
	local RootJointTween = CreateTween(RootJoint, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standRootJointC0 * CFrame.new(0, 0, -0.754) * CFrame.Angles(math.rad(-36.841), 0, 0),
	}, true)
	local LHTween = CreateTween(LH, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standLHC0 * CFrame.new(-0.211, 0.51, 0) * CFrame.Angles(math.rad(-16.558), math.rad(12.147), math.rad(45.951)),
	}, true)
	local RHTween = CreateTween(RH, {speed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0},{
		C0 = standRHC0 * CFrame.new(0.245, 0.512, 0) * CFrame.Angles(math.rad(-20.798), math.rad(-13.121), math.rad(-44.29)),
	}, true)
	RootJointTween.Completed:Connect(function() nex = true end)
	repeat wait() until nex or stopped
	if stopped then event2:disconnect() event:disconnect() RSTween:Cancel() LSTween:Cancel() NeckTween:Cancel() RootJointTween:Cancel() LHTween:Cancel() RHTween:Cancel() return end nex = false
	-------------------------------------------------------------------------------
	event:disconnect()
	event2:disconnect()
end

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
local typeFolder = {Core = 1, Idle = 2, Movement = 3, Action = 4}

function playAnimation(Type, speed, rep, func)
	if typeFolder[Type] < animationAction then return end
	if rep then
		adjustSpeed.Value = 0
		local stopped = false
		local event = stopAnimationsValue.Changed:Connect(function(changedTo) if changedTo then stopped = true end end)
		local origSpeed = speed
		local event2 = adjustSpeed.Changed:Connect(function(changedTo)
			speed = origSpeed - changedTo
		end)
		repeat
			if stopped then break end
			Animations[func](speed)
		until typeFolder[Type] < animationAction or stopped
		event:disconnect()
		event2:disconnect()
	else
		Animations[func](speed)
	end
end

--[Hair]--
mas                    = Instance.new("Model",game:GetService("Lighting"))
Model0                 = Instance.new("Model")
Part1                  = Instance.new("Part")
SpecialMesh2           = Instance.new("SpecialMesh")
Part3                  = Instance.new("Part")
SpecialMesh4           = Instance.new("SpecialMesh")
ManualWeld5            = Instance.new("ManualWeld")
Model0.Name            = "Hair"
Model0.Parent          = mas
Model0.PrimaryPart     = Part1
Part1.Name             = "Base"
Part1.Parent           = Model0
Part1.CFrame           = CFrame.new(-13.9904289, 4.38703632, -42.9299927, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part1.Position         = Vector3.new(-13.9904289, 4.38703632, -42.9299927)
Part1.Transparency     = 1
Part1.Locked           = true
Part1.Size             = Vector3.new(2, 1, 1)
Part1.TopSurface       = Enum.SurfaceType.Smooth
Part1.FormFactor       = Enum.FormFactor.Symmetric
Part1.formFactor       = Enum.FormFactor.Symmetric
SpecialMesh2.Parent    = Part1
SpecialMesh2.Scale     = Vector3.new(1.25, 1.25, 1.25)
Part3.Name             = "Hair"
Part3.Parent           = Model0
Part3.Locked           = true
Part3.CFrame           = CFrame.new(-13.9156923, 4.36601019, -42.6050339, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part3.Position         = Vector3.new(-13.9156923, 4.36601019, -42.6050339)
Part3.Size             = Vector3.new(1, 1, 1)
Part3.BottomSurface    = Enum.SurfaceType.Smooth
Part3.TopSurface       = Enum.SurfaceType.Smooth
SpecialMesh4.Parent    = Part3
SpecialMesh4.MeshId    = "rbxassetid://886288384"
SpecialMesh4.Scale     = Vector3.new(0.109999999, 0.101000004, 0.0900000036)
SpecialMesh4.TextureId = "rbxassetid://886289004"
SpecialMesh4.MeshType  = Enum.MeshType.FileMesh
ManualWeld5.Name       = "Weld"
ManualWeld5.Parent     = Part3
ManualWeld5.C1         = CFrame.new(0.0747365952, -0.0210261345, 0.324958801, 1, 0, 0, 0, 1, 0, 0, 0, 1)
ManualWeld5.Part0      = Part3
ManualWeld5.Part1      = Part1
ManualWeld5.part1      = Part1
for i,v in pairs(mas:GetChildren()) do
	v.Parent = character
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
CreateInstance("Weld", {head, Model0.PrimaryPart, CFrame.new()})
-------------------------------------------------------------------------------------
--[Stand]--
mas = Instance.new("Model",game:GetService("Lighting"))
Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
SpecialMesh2 = Instance.new("SpecialMesh")
Part3 = Instance.new("Part")
SpecialMesh4 = Instance.new("SpecialMesh")
ManualWeld5 = Instance.new("ManualWeld")
Part6 = Instance.new("Part")
Motor6D7 = Instance.new("Motor6D")
Motor6D8 = Instance.new("Motor6D")
Motor6D9 = Instance.new("Motor6D")
Motor6D10 = Instance.new("Motor6D")
Motor6D11 = Instance.new("Motor6D")
Part12 = Instance.new("Part")
SpecialMesh13 = Instance.new("SpecialMesh")
ManualWeld14 = Instance.new("ManualWeld")
Part15 = Instance.new("Part")
SpecialMesh16 = Instance.new("SpecialMesh")
Part17 = Instance.new("Part")
SpecialMesh18 = Instance.new("SpecialMesh")
ManualWeld19 = Instance.new("ManualWeld")
ManualWeld20 = Instance.new("ManualWeld")
Part21 = Instance.new("Part")
Part22 = Instance.new("Part")
SpecialMesh23 = Instance.new("SpecialMesh")
Part24 = Instance.new("Part")
SpecialMesh25 = Instance.new("SpecialMesh")
ManualWeld26 = Instance.new("ManualWeld")
ManualWeld27 = Instance.new("ManualWeld")
Part28 = Instance.new("Part")
Part29 = Instance.new("Part")
SpecialMesh30 = Instance.new("SpecialMesh")
Part31 = Instance.new("Part")
SpecialMesh32 = Instance.new("SpecialMesh")
ManualWeld33 = Instance.new("ManualWeld")
ManualWeld34 = Instance.new("ManualWeld")
Part35 = Instance.new("Part")
Part36 = Instance.new("Part")
SpecialMesh37 = Instance.new("SpecialMesh")
Part38 = Instance.new("Part")
SpecialMesh39 = Instance.new("SpecialMesh")
ManualWeld40 = Instance.new("ManualWeld")
ManualWeld41 = Instance.new("ManualWeld")
Part42 = Instance.new("Part")
Part43 = Instance.new("Part")
SpecialMesh44 = Instance.new("SpecialMesh")
Part45 = Instance.new("Part")
SpecialMesh46 = Instance.new("SpecialMesh")
ManualWeld47 = Instance.new("ManualWeld")
ManualWeld48 = Instance.new("ManualWeld")
Part49 = Instance.new("Part")
Motor6D50 = Instance.new("Motor6D")
Model0.Name = "TheWorld"
Model0.Parent = mas
Model0.PrimaryPart = Part49
Part1.Name = "Head"
Part1.Parent = Model0
Part1.CFrame = CFrame.new(-11, 4.49999905, -140.712997, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part1.Position = Vector3.new(-11, 4.49999905, -140.712997)
Part1.Size = Vector3.new(2, 1, 1)
Part1.TopSurface = Enum.SurfaceType.Smooth
Part1.FormFactor = Enum.FormFactor.Symmetric
Part1.formFactor = Enum.FormFactor.Symmetric
SpecialMesh2.Parent = Part1
SpecialMesh2.Scale = Vector3.new(1.25, 1.25, 1.25)
Part3.Name = "MeshPart"
Part3.Parent = Part1
Part3.CFrame = CFrame.new(-10.9981527, 5.12989998, -140.826462, 0.999999583, -1.07846752e-25, -0.00114512106, -1.07846777e-25, 1, -1.8851529e-22, 0.00114512106, 1.88515226e-22, 0.999999583)
Part3.Orientation = Vector3.new(0, -0.0700000003, 0)
Part3.Position = Vector3.new(-10.9981527, 5.12989998, -140.826462)
Part3.Rotation = Vector3.new(0, -0.0700000003, 0)
Part3.Color = Color3.new(1, 1, 0)
Part3.Size = Vector3.new(1.88429964, 1.28681386, 1.6029284)
Part3.BrickColor = BrickColor.new("New Yeller")
Part3.CanCollide = false
Part3.brickColor = BrickColor.new("New Yeller")
SpecialMesh4.Parent = Part3
SpecialMesh4.MeshId = "rbxassetid://1143300560"
SpecialMesh4.Scale = Vector3.new(0.0104999999, 0.0104999999, 0.0104999999)
SpecialMesh4.MeshType = Enum.MeshType.FileMesh
ManualWeld5.Name = "Weld"
ManualWeld5.Parent = Part1
ManualWeld5.C1 = CFrame.new(-0.00171756744, -0.629900932, 0.113464355, 0.999999583, -1.07846777e-25, 0.00114512106, -1.07846752e-25, 1, 1.88515226e-22, -0.00114512106, -1.8851529e-22, 0.999999583)
ManualWeld5.Part0 = Part1
ManualWeld5.Part1 = Part3
ManualWeld5.part1 = Part3
Part6.Name = "Torso"
Part6.Parent = Model0
Part6.CFrame = CFrame.new(-11, 2.99999905, -140.712997, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part6.Position = Vector3.new(-11, 2.99999905, -140.712997)
Part6.Size = Vector3.new(2, 2, 1)
Part6.LeftParamA = 0
Part6.LeftParamB = 0
Part6.LeftSurface = Enum.SurfaceType.Weld
Part6.RightParamA = 0
Part6.RightParamB = 0
Part6.RightSurface = Enum.SurfaceType.Weld
Part6.FormFactor = Enum.FormFactor.Symmetric
Part6.formFactor = Enum.FormFactor.Symmetric
Motor6D7.Name = "Right Shoulder"
Motor6D7.Parent = Part6
Motor6D7.MaxVelocity = 0.10000000149012
Motor6D7.C0 = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
Motor6D7.C1 = CFrame.new(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
Motor6D7.Part0 = Part6
Motor6D7.Part1 = Part28
Motor6D7.part1 = Part28
Motor6D8.Name = "Left Shoulder"
Motor6D8.Parent = Part6
Motor6D8.MaxVelocity = 0.10000000149012
Motor6D8.C0 = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
Motor6D8.C1 = CFrame.new(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
Motor6D8.Part0 = Part6
Motor6D8.Part1 = Part21
Motor6D8.part1 = Part21
Motor6D9.Name = "Right Hip"
Motor6D9.Parent = Part6
Motor6D9.MaxVelocity = 0.10000000149012
Motor6D9.C0 = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
Motor6D9.C1 = CFrame.new(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
Motor6D9.Part0 = Part6
Motor6D9.Part1 = Part42
Motor6D9.part1 = Part42
Motor6D10.Name = "Left Hip"
Motor6D10.Parent = Part6
Motor6D10.MaxVelocity = 0.10000000149012
Motor6D10.C0 = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
Motor6D10.C1 = CFrame.new(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
Motor6D10.Part0 = Part6
Motor6D10.Part1 = Part35
Motor6D10.part1 = Part35
Motor6D11.Name = "Neck"
Motor6D11.Parent = Part6
Motor6D11.MaxVelocity = 0.10000000149012
Motor6D11.C0 = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
Motor6D11.C1 = CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
Motor6D11.Part0 = Part6
Motor6D11.Part1 = Part1
Motor6D11.part1 = Part1
Part12.Name = "MeshPart"
Part12.Parent = Part6
Part12.CFrame = CFrame.new(-11.0002317, 2.3847816, -141.258575, 1.0000031, -1.07514136e-25, -0.0011451242, -1.07520053e-25, 1, -1.88510039e-22, 0.00114512409, 1.88510254e-22, 1.0000031)
Part12.Orientation = Vector3.new(0, -0.0700000003, 0)
Part12.Position = Vector3.new(-11.0002317, 2.3847816, -141.258575)
Part12.Rotation = Vector3.new(0, -0.0700000003, 0)
Part12.Color = Color3.new(0, 1, 0)
Part12.Size = Vector3.new(0.497487307, 0.716963172, 0.246030912)
Part12.BrickColor = BrickColor.new("Lime green")
Part12.CanCollide = false
Part12.brickColor = BrickColor.new("Lime green")
SpecialMesh13.Parent = Part12
SpecialMesh13.MeshId = "rbxassetid://1143316712"
SpecialMesh13.Scale = Vector3.new(0.0104999999, 0.0104999999, 0.0104999999)
SpecialMesh13.MeshType = Enum.MeshType.FileMesh
ManualWeld14.Name = "Weld"
ManualWeld14.Parent = Part12
ManualWeld14.C0 = CFrame.new(0, 0, 0, 1.00000238, -1.07871761e-25, 0.00114512327, -1.07866018e-25, 1, 1.88510329e-22, -0.00114512339, -1.88509824e-22, 1.00000238)
ManualWeld14.C1 = CFrame.new(0.00993347168, -0.730722427, -1.00549316, 1.00000012, 8.63063134e-29, 0, 8.63063134e-29, 1, -5.04870979e-29, 0, -5.04870979e-29, 1.00000012)
ManualWeld14.Part0 = Part12
ManualWeld14.Part1 = Part15
ManualWeld14.part1 = Part15
Part15.Name = "MeshPart"
Part15.Parent = Part6
Part15.CFrame = CFrame.new(-11.0101652, 3.11550403, -140.253082, 1.0000006, 2.6564891e-28, 0, 2.6564891e-28, 1, -1.64083068e-28, 0, -1.64083068e-28, 1.0000006)
Part15.Position = Vector3.new(-11.0101652, 3.11550403, -140.253082)
Part15.Color = Color3.new(1, 1, 0)
Part15.Size = Vector3.new(1.6600045, 1.75000441, 0.244600952)
Part15.BrickColor = BrickColor.new("New Yeller")
Part15.CanCollide = false
Part15.brickColor = BrickColor.new("New Yeller")
SpecialMesh16.Parent = Part15
SpecialMesh16.MeshId = "rbxassetid://1141141111"
SpecialMesh16.Scale = Vector3.new(0.0104999999, 0.0104999999, 0.0104999999)
SpecialMesh16.MeshType = Enum.MeshType.FileMesh
Part17.Name = "MeshPart"
Part17.Parent = Part6
Part17.CFrame = CFrame.new(-11.0012236, 3.09906697, -140.490601, 1.00000024, -1.07494858e-25, -0.00114512176, -1.07495043e-25, 1, -1.88515492e-22, 0.00114512176, 1.88515138e-22, 1.00000024)
Part17.Orientation = Vector3.new(0, -0.0700000003, 0)
Part17.Position = Vector3.new(-11.0012236, 3.09906697, -140.490601)
Part17.Rotation = Vector3.new(0, -0.0700000003, 0)
Part17.Color = Color3.new(1, 1, 0)
Part17.Size = Vector3.new(2.08657074, 2.21194625, 1.97540927)
Part17.BrickColor = BrickColor.new("New Yeller")
Part17.CanCollide = false
Part17.brickColor = BrickColor.new("New Yeller")
SpecialMesh18.Parent = Part17
SpecialMesh18.MeshId = "rbxassetid://1143311149"
SpecialMesh18.Scale = Vector3.new(0.0104999999, 0.0104999999, 0.0104999999)
SpecialMesh18.MeshType = Enum.MeshType.FileMesh
ManualWeld19.Name = "Weld"
ManualWeld19.Parent = Part17
ManualWeld19.C0 = CFrame.new(0, 0, 0, 0.999999583, -1.07846752e-25, 0.00114512094, -1.0784674e-25, 1, 1.88515214e-22, -0.00114512094, -1.88515277e-22, 0.999999583)
ManualWeld19.C1 = CFrame.new(0.00894165039, -0.0164370537, -0.237518311, 1.00000012, 8.63063134e-29, 0, 8.63063134e-29, 1, -5.04870979e-29, 0, -5.04870979e-29, 1.00000012)
ManualWeld19.Part0 = Part17
ManualWeld19.Part1 = Part15
ManualWeld19.part1 = Part15
ManualWeld20.Name = "Weld"
ManualWeld20.Parent = Part6
ManualWeld20.C1 = CFrame.new(0.0101652145, -0.11550498, -0.459915161, 1.0000006, 2.6564891e-28, 0, 2.6564891e-28, 1, -1.64083068e-28, 0, -1.64083068e-28, 1.0000006)
ManualWeld20.Part0 = Part6
ManualWeld20.Part1 = Part15
ManualWeld20.part1 = Part15
Part21.Name = "Left Arm"
Part21.Parent = Model0
Part21.CFrame = CFrame.new(-12.5, 2.99999905, -140.712997, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part21.Position = Vector3.new(-12.5, 2.99999905, -140.712997)
Part21.Size = Vector3.new(1, 2, 1)
Part21.CanCollide = false
Part21.FormFactor = Enum.FormFactor.Symmetric
Part21.formFactor = Enum.FormFactor.Symmetric
Part22.Name = "MeshPart"
Part22.Parent = Part21
Part22.CFrame = CFrame.new(-12.9999304, 2.81063819, -140.730469, -1, 2.40999197e-28, 1.16413962e-10, 2.40999221e-28, 1, 8.82741684e-29, -1.16413962e-10, 8.82741684e-29, -1)
Part22.Orientation = Vector3.new(0, 180, 0)
Part22.Position = Vector3.new(-12.9999304, 2.81063819, -140.730469)
Part22.Rotation = Vector3.new(-180, 0, -180)
Part22.Color = Color3.new(0, 1, 0)
Part22.Size = Vector3.new(0.0506704524, 0.512147725, 0.553264797)
Part22.BrickColor = BrickColor.new("Lime green")
Part22.CanCollide = false
Part22.brickColor = BrickColor.new("Lime green")
SpecialMesh23.Parent = Part22
SpecialMesh23.MeshId = "rbxassetid://1143324911"
SpecialMesh23.Scale = Vector3.new(0.0104999999, 0.0104999999, 0.0104999999)
SpecialMesh23.MeshType = Enum.MeshType.FileMesh
Part24.Name = "MeshPart"
Part24.Parent = Part21
Part24.CFrame = CFrame.new(-12.5000677, 3.04943538, -140.736847, -1.00000525, 4.13587196e-28, 0.00114500744, 8.64543813e-29, 1, 1.51206638e-28, -0.00114500744, 1.25435215e-29, -1.00000525)
Part24.Orientation = Vector3.new(0, 179.929993, 0)
Part24.Position = Vector3.new(-12.5000677, 3.04943538, -140.736847)
Part24.Rotation = Vector3.new(-180, 0.0700000003, -180)
Part24.Color = Color3.new(1, 1, 0)
Part24.Size = Vector3.new(1.1845758, 2.05767751, 1.09631383)
Part24.BrickColor = BrickColor.new("New Yeller")
Part24.CanCollide = false
Part24.brickColor = BrickColor.new("New Yeller")
SpecialMesh25.Parent = Part24
SpecialMesh25.MeshId = "rbxassetid://1143321694"
SpecialMesh25.Scale = Vector3.new(0.0104999999, 0.0104999999, 0.0104999999)
SpecialMesh25.MeshType = Enum.MeshType.FileMesh
ManualWeld26.Name = "Weld"
ManualWeld26.Parent = Part24
ManualWeld26.C0 = CFrame.new(0, 0, 0, -1.00000513, -6.83982464e-29, -0.00114500721, 8.62816615e-29, 1, -2.5243549e-29, 0.00114500721, 1.26217745e-29, -1.00000513)
ManualWeld26.C1 = CFrame.new(-0.499862671, 0.238797188, 0.00637817383, -1.00000012, -8.63063134e-29, 0, 8.63063134e-29, 1, -5.04870979e-29, 0, 5.04870979e-29, -1.00000012)
ManualWeld26.Part0 = Part24
ManualWeld26.Part1 = Part22
ManualWeld26.part1 = Part22
ManualWeld27.Name = "Weld"
ManualWeld27.Parent = Part21
ManualWeld27.C1 = CFrame.new(-0.499930382, 0.189360857, -0.0174713135, -1, 2.40999221e-28, -1.16413962e-10, 2.40999197e-28, 1, 8.82741684e-29, 1.16413962e-10, 8.82741684e-29, -1)
ManualWeld27.Part0 = Part21
ManualWeld27.Part1 = Part22
ManualWeld27.part1 = Part22
Part28.Name = "Right Arm"
Part28.Parent = Model0
Part28.CFrame = CFrame.new(-9.5, 2.99999905, -140.712997, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part28.Position = Vector3.new(-9.5, 2.99999905, -140.712997)
Part28.Size = Vector3.new(1, 2, 1)
Part28.CanCollide = false
Part28.FormFactor = Enum.FormFactor.Symmetric
Part28.formFactor = Enum.FormFactor.Symmetric
Part29.Name = "MeshPart"
Part29.Parent = Part28
Part29.CFrame = CFrame.new(-8.99591541, 2.81063819, -140.743225, 1.0000006, 3.01732796e-28, 0, 3.01674898e-28, 1, -1.34476132e-28, 0, -1.34476132e-28, 1.0000006)
Part29.Position = Vector3.new(-8.99591541, 2.81063819, -140.743225)
Part29.Color = Color3.new(0, 1, 0)
Part29.Size = Vector3.new(0.0506704524, 0.512147725, 0.553264797)
Part29.BrickColor = BrickColor.new("Lime green")
Part29.CanCollide = false
Part29.brickColor = BrickColor.new("Lime green")
SpecialMesh30.Parent = Part29
SpecialMesh30.MeshId = "rbxassetid://1143324911"
SpecialMesh30.Scale = Vector3.new(0.0104999999, 0.0104999999, 0.0104999999)
SpecialMesh30.MeshType = Enum.MeshType.FileMesh
Part31.Name = "MeshPart"
Part31.Parent = Part28
Part31.CFrame = CFrame.new(-9.43703556, 3.04943538, -140.736862, 1.00000024, -3.05980313e-22, -0.00114512153, 3.0598102e-22, 1, -1.75451367e-25, 0.00114512153, -1.75387938e-25, 1.00000024)
Part31.Orientation = Vector3.new(0, -0.0700000003, 0)
Part31.Position = Vector3.new(-9.43703556, 3.04943538, -140.736862)
Part31.Rotation = Vector3.new(0, -0.0700000003, 0)
Part31.Color = Color3.new(1, 1, 0)
Part31.Size = Vector3.new(1.1845758, 2.05767751, 1.09631383)
Part31.BrickColor = BrickColor.new("New Yeller")
Part31.CanCollide = false
Part31.brickColor = BrickColor.new("New Yeller")
SpecialMesh32.Parent = Part31
SpecialMesh32.MeshId = "rbxassetid://1143321694"
SpecialMesh32.Scale = Vector3.new(0.0104999999, 0.0104999999, 0.0104999999)
SpecialMesh32.MeshType = Enum.MeshType.FileMesh
ManualWeld33.Name = "Weld"
ManualWeld33.Parent = Part31
ManualWeld33.C0 = CFrame.new(0, 0, 0, 0.999999583, 3.05980642e-22, 0.00114512071, -3.0598049e-22, 1, -1.75202852e-25, -0.00114512071, -1.7526596e-25, 0.999999583)
ManualWeld33.C1 = CFrame.new(-0.441120148, 0.238797188, 0.00636291504, 1.00000012, 8.63063134e-29, 0, 8.63063134e-29, 1, -5.04870979e-29, 0, -5.04870979e-29, 1.00000012)
ManualWeld33.Part0 = Part31
ManualWeld33.Part1 = Part29
ManualWeld33.part1 = Part29
ManualWeld34.Name = "Weld"
ManualWeld34.Parent = Part28
ManualWeld34.C1 = CFrame.new(-0.504084587, 0.189360857, 0.0302276611, 1.0000006, 3.01674898e-28, 0, 3.01732796e-28, 1, -1.34476132e-28, 0, -1.34476132e-28, 1.0000006)
ManualWeld34.Part0 = Part28
ManualWeld34.Part1 = Part29
ManualWeld34.part1 = Part29
Part35.Name = "Left Leg"
Part35.Parent = Model0
Part35.CFrame = CFrame.new(-11.5, 0.999999046, -140.712997, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part35.Position = Vector3.new(-11.5, 0.999999046, -140.712997)
Part35.Size = Vector3.new(1, 2, 1)
Part35.BottomSurface = Enum.SurfaceType.Smooth
Part35.CanCollide = false
Part35.FormFactor = Enum.FormFactor.Symmetric
Part35.formFactor = Enum.FormFactor.Symmetric
Part36.Name = "MeshPart"
Part36.Parent = Part35
Part36.CFrame = CFrame.new(-11.6320038, 1.01576853, -140.689758, -1.00000286, 8.63063134e-29, 9.98028554e-07, -6.32321319e-29, 1, 1.26217745e-29, -9.98028554e-07, -5.04870979e-29, -1.00000286)
Part36.Orientation = Vector3.new(0, 180, 0)
Part36.Position = Vector3.new(-11.6320038, 1.01576853, -140.689758)
Part36.Rotation = Vector3.new(-180, 0, -180)
Part36.Color = Color3.new(1, 1, 0)
Part36.Size = Vector3.new(1.31867778, 2.05399609, 1.22587061)
Part36.BrickColor = BrickColor.new("New Yeller")
Part36.CanCollide = false
Part36.brickColor = BrickColor.new("New Yeller")
SpecialMesh37.Parent = Part36
SpecialMesh37.MeshId = "rbxassetid://1143339099"
SpecialMesh37.Scale = Vector3.new(0.0104999999, 0.0104999999, 0.0104999999)
SpecialMesh37.MeshType = Enum.MeshType.FileMesh
Part38.Name = "MeshPart"
Part38.Parent = Part35
Part38.CFrame = CFrame.new(-11.4904623, 1.15133142, -141.164368, 1.00000525, -1.07697818e-25, -0.00114512746, -1.07697288e-25, 1, -1.8851534e-22, 0.00114512746, 1.88516236e-22, 1.00000525)
Part38.Orientation = Vector3.new(0, -0.0700000003, 0)
Part38.Position = Vector3.new(-11.4904623, 1.15133142, -141.164368)
Part38.Rotation = Vector3.new(0, -0.0700000003, 0)
Part38.Color = Color3.new(0, 1, 0)
Part38.Size = Vector3.new(0.439961642, 0.407265335, 0.217581689)
Part38.BrickColor = BrickColor.new("Lime green")
Part38.CanCollide = false
Part38.brickColor = BrickColor.new("Lime green")
SpecialMesh39.Parent = Part38
SpecialMesh39.MeshId = "rbxassetid://1143349005"
SpecialMesh39.Scale = Vector3.new(0.0104999999, 0.0104999999, 0.0104999999)
SpecialMesh39.MeshType = Enum.MeshType.FileMesh
ManualWeld40.Name = "Weld"
ManualWeld40.Parent = Part38
ManualWeld40.C0 = CFrame.new(0, 0, 0, 0.999999583, -1.07846752e-25, 0.00114512094, -1.0784674e-25, 1, 1.88515214e-22, -0.00114512094, -1.88515277e-22, 0.999999583)
ManualWeld40.C1 = CFrame.new(-0.141540527, 0.135562897, 0.474609375, -1.00000286, -6.32321319e-29, -9.98028554e-07, 8.63063134e-29, 1, -5.04870979e-29, 9.98028554e-07, 1.26217745e-29, -1.00000286)
ManualWeld40.Part0 = Part38
ManualWeld40.Part1 = Part36
ManualWeld40.part1 = Part36
ManualWeld41.Name = "Weld"
ManualWeld41.Parent = Part35
ManualWeld41.C1 = CFrame.new(-0.132003784, -0.0157694817, 0.0232391357, -1.00000286, -6.32321319e-29, -9.98028554e-07, 8.63063134e-29, 1, -5.04870979e-29, 9.98028554e-07, 1.26217745e-29, -1.00000286)
ManualWeld41.Part0 = Part35
ManualWeld41.Part1 = Part36
ManualWeld41.part1 = Part36
Part42.Name = "Right Leg"
Part42.Parent = Model0
Part42.CFrame = CFrame.new(-10.5, 0.999999046, -140.712997, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part42.Position = Vector3.new(-10.5, 0.999999046, -140.712997)
Part42.Size = Vector3.new(1, 2, 1)
Part42.BottomSurface = Enum.SurfaceType.Smooth
Part42.CanCollide = false
Part42.FormFactor = Enum.FormFactor.Symmetric
Part42.formFactor = Enum.FormFactor.Symmetric
Part43.Name = "MeshPart"
Part43.Parent = Part42
Part43.CFrame = CFrame.new(-10.5014668, 1.15133142, -141.163223, 0.999999881, -1.07521618e-25, -0.00114512153, -1.07992802e-25, 1, -1.88515454e-22, 0.00114512153, 1.88515327e-22, 0.999999881)
Part43.Orientation = Vector3.new(0, -0.0700000003, 0)
Part43.Position = Vector3.new(-10.5014668, 1.15133142, -141.163223)
Part43.Rotation = Vector3.new(0, -0.0700000003, 0)
Part43.Color = Color3.new(0, 1, 0)
Part43.Size = Vector3.new(0.439961642, 0.407265335, 0.217581689)
Part43.BrickColor = BrickColor.new("Lime green")
Part43.CanCollide = false
Part43.brickColor = BrickColor.new("Lime green")
SpecialMesh44.Parent = Part43
SpecialMesh44.MeshId = "rbxassetid://1143349005"
SpecialMesh44.Scale = Vector3.new(0.0104999999, 0.0104999999, 0.0104999999)
SpecialMesh44.MeshType = Enum.MeshType.FileMesh
Part45.Name = "MeshPart"
Part45.Parent = Part42
Part45.CFrame = CFrame.new(-10.3331394, 1.01576853, -140.689758, 1.0000093, 5.87035773e-28, 5.82076609e-10, 9.6857328e-29, 1, -3.39525734e-27, -8.14907253e-10, 3.00398233e-27, 1.0000093)
Part45.Position = Vector3.new(-10.3331394, 1.01576853, -140.689758)
Part45.Color = Color3.new(1, 1, 0)
Part45.Size = Vector3.new(1.31831443, 2.05419517, 1.22550547)
Part45.BrickColor = BrickColor.new("New Yeller")
Part45.CanCollide = false
Part45.brickColor = BrickColor.new("New Yeller")
SpecialMesh46.Parent = Part45
SpecialMesh46.MeshId = "rbxassetid://1143339099"
SpecialMesh46.Scale = Vector3.new(0.0104999999, 0.0104999999, 0.0104999999)
SpecialMesh46.MeshType = Enum.MeshType.FileMesh
ManualWeld47.Name = "Weld"
ManualWeld47.Parent = Part45
ManualWeld47.C0 = CFrame.new(0, 0, 0, 1.00000858, 6.33553915e-29, -1.0477379e-09, 8.25099203e-29, 1, 3.05446943e-27, 8.14907253e-10, -3.1175783e-27, 1.00000858)
ManualWeld47.C1 = CFrame.new(0.168869019, -0.135562897, 0.473266602, 0.999999583, -1.07846752e-25, 0.00114512094, -1.0784674e-25, 1, 1.88515214e-22, -0.00114512094, -1.88515277e-22, 0.999999583)
ManualWeld47.Part0 = Part45
ManualWeld47.Part1 = Part43
ManualWeld47.part1 = Part43
ManualWeld48.Name = "Weld"
ManualWeld48.Parent = Part42
ManualWeld48.C0 = CFrame.new(0, 0, 0, 1.00000048, 1.79342596e-28, 0, 1.79342596e-28, 1, -1.1359597e-28, 0, -1.1359597e-28, 1.00000048)
ManualWeld48.C1 = CFrame.new(0.0019826889, -0.151332378, 0.45022583, 0.999999404, -1.08172009e-25, 0.00114512094, -1.07700911e-25, 1, 1.88515353e-22, -0.00114512094, -1.8851534e-22, 0.999999404)
ManualWeld48.Part0 = Part42
ManualWeld48.Part1 = Part43
ManualWeld48.part1 = Part43
Part49.Name = "HumanoidRootPart"
Part49.Parent = Model0
Part49.CFrame = CFrame.new(-11, 2.99999905, -140.712997, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part49.Position = Vector3.new(-11, 2.99999905, -140.712997)
Part49.Transparency = 1
Part49.Size = Vector3.new(2, 2, 1)
Part49.Anchored = false
Part49.BottomSurface = Enum.SurfaceType.Smooth
Part49.CanCollide = false
Part49.LeftParamA = 0
Part49.LeftParamB = 0
Part49.RightParamA = 0
Part49.RightParamB = 0
Part49.TopSurface = Enum.SurfaceType.Smooth
Part49.FormFactor = Enum.FormFactor.Symmetric
Part49.formFactor = Enum.FormFactor.Symmetric
Motor6D50.Name = "RootJoint"
Motor6D50.Parent = Part49
Motor6D50.MaxVelocity = 0.10000000149012
Motor6D50.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
Motor6D50.C1 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
Motor6D50.Part0 = Part49
Motor6D50.Part1 = Part6
Motor6D50.part1 = Part6
for i,v in pairs(mas:GetChildren()) do
	v.Parent = character
	stand = v
	for i,v in pairs(v:GetDescendants()) do
		if v:IsA("BasePart") then
			v.CanCollide    = false
			v.Massless      = true
			v.Locked        = true
			v.Transparency  = 1
			v.TopSurface    = 0
			v.BottomSurface = 0
			v.FrontSurface  = 0
			v.BackSurface   = 0
			v.LeftSurface   = 0
			v.RightSurface  = 0
		elseif v.Name == "Snap" or v:IsA("Snap") then
			v:Destroy()
		end
	end
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
CreateInstance("Weld",{rootPart, stand.HumanoidRootPart, CFrame.new()})
standrootPart = stand:WaitForChild("HumanoidRootPart")
standhead, standtorso = stand:WaitForChild("Head"), stand:WaitForChild("Torso")
standleftArm, standrightArm = stand:WaitForChild("Left Arm"), stand:WaitForChild("Right Arm")
standleftLeg, standrightLeg = stand:WaitForChild("Left Leg"), stand:WaitForChild("Right Leg")
standLS, standLH, standRS, standRH, standNeck, standRootJoint = standtorso["Left Shoulder"], standtorso["Left Hip"], standtorso["Right Shoulder"], standtorso["Right Hip"], standtorso.Neck, standrootPart.RootJoint
standRSC0, standLSC0, standRHC0, standLHC0, standNeckC0, standRootJointC0 = standRS.C0, standLS.C0, standRH.C0, standLH.C0, standNeck.C0, standRootJoint.C0
ParticleEmitter0 = Instance.new("ParticleEmitter")
ParticleEmitter1 = Instance.new("ParticleEmitter")
ParticleEmitter2 = Instance.new("ParticleEmitter")
ParticleEmitter0.Name = "BurstStart"
ParticleEmitter0.Parent = standtorso
ParticleEmitter0.Speed = NumberRange.new(0, 0)
ParticleEmitter0.Color = ColorSequence.new(Color3.new(1, 0.854902, 0.0196078),Color3.new(1, 0.854902, 0.0196078))
ParticleEmitter0.LightEmission = 1
ParticleEmitter0.Transparency = NumberSequence.new(0,1)
ParticleEmitter0.ZOffset = 2
ParticleEmitter0.Size = NumberSequence.new(0,0,4.9375,0,0)
ParticleEmitter0.Lifetime = NumberRange.new(0.5, 0.5)
ParticleEmitter0.Rate = 5000000
ParticleEmitter0.SpreadAngle = Vector2.new(-360, 360)
ParticleEmitter0.VelocitySpread = -360
ParticleEmitter1.Name = "BurstStart"
ParticleEmitter1.Parent = standtorso
ParticleEmitter1.Speed = NumberRange.new(20, 20)
ParticleEmitter1.Color = ColorSequence.new(Color3.new(1, 0.854902, 0.0196078),Color3.new(1, 0.854902, 0.0196078))
ParticleEmitter1.LightEmission = 1
ParticleEmitter1.Transparency = NumberSequence.new(0,0,1)
ParticleEmitter1.ZOffset = 2
ParticleEmitter1.Size = NumberSequence.new(2.375,0)
ParticleEmitter1.Lifetime = NumberRange.new(0.5, 0.5)
ParticleEmitter1.Rate = 10000000
ParticleEmitter1.SpreadAngle = Vector2.new(-360, 360)
ParticleEmitter1.VelocitySpread = -360
ParticleEmitter2.Name = "BurstStart"
ParticleEmitter2.Parent = standtorso
ParticleEmitter2.Speed = NumberRange.new(0, 0)
ParticleEmitter2.Rotation = NumberRange.new(-200, 200)
ParticleEmitter2.LightEmission = 1
ParticleEmitter2.Texture = "rbxassetid://1327566582"
ParticleEmitter2.Transparency = NumberSequence.new(0,1)
ParticleEmitter2.ZOffset = 2
ParticleEmitter2.Size = NumberSequence.new(0,10)
ParticleEmitter2.Lifetime = NumberRange.new(0.20000000298023, 0.20000000298023)
ParticleEmitter2.Rate = 200
ParticleEmitter2.SpreadAngle = Vector2.new(-360, 360)
ParticleEmitter2.VelocitySpread = -360
ParticleEmitter0.Enabled = false
ParticleEmitter1.Enabled = false
ParticleEmitter2.Enabled = false
-------------------------------------------------------------------------------------
AddClothes("rbxassetid://1118382676", "rbxassetid://298260668")
local taunt = CreateInstance("Sound", {
	SoundId = "rbxassetid://6691517184",
	Looped = false,
	Pitch = 1,
	Volume = 10,
	Parent = character.HumanoidRootPart,
	Play = true,
	TimePosition = 0,
	PlayOnRemove = true
})
Talk("Heh..", 0.05, Color3.new(1, 0, 0))
--[[local music = CreateInstance("Sound", {
	SoundId = "rbxassetid://172313730",
	Looped = true,
	Volume = 10,
	Parent = head,
	Play = true,
	PlayOnRemove = false
})]]
local event
mouse.KeyDown:Connect(function(key)
	if key == "leftcontrol" and humanoid.MoveDirection.X ~= 0 and debounce and not running and humanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
		running = true
		holding = true
		--debounce = false
		local walkSpeed = 6
		local runSpeed = 50
		animationAction = 2

		local num = (runSpeed - walkSpeed)/100
		local originalFOV = Camera.FieldOfView
		humanoid.WalkSpeed = 30
		for i = 1, 30 do
			if not running or not debounce then break end
			Camera.FieldOfView = clamp(Camera.FieldOfView + num, 70, 120)
			wait() end
		repeat wait() until not running or humanoid.MoveDirection.X == 0 or not debounce
		running = false
		humanoid.WalkSpeed = walkSpeed
		for i = 1, 10 do
			Camera.FieldOfView =  clamp(Camera.FieldOfView - (num*2), 70, 120)
			wait() end
		humanoid.WalkSpeed = walkSpeed
		Camera.FieldOfView = originalFOV
		--debounce = true
		animationAction = 2
	elseif key == "leftcontrol" and running and debounce then
		running = false
	elseif key == "q" and debounce then
		debounce = false
		if not standActive then
			standActive = true
			activateStand(standActive)
		else
			standActive = false
			activateStand(standActive)
		end
		debounce = true
	elseif key == "f" and debounce and not timeStop then
		debounce = false
		animationAction = 4
		playingAnimation = "TimeStopPlayer"
		stopAnimationsValue.Value = false
		stopAnimationsValue.Value = true
		coroutine.wrap(function() playAnimation("Action", 0.5, false, playingAnimation) end)()
		local ZaWarudoSound = CreateInstance("Sound", {
			SoundId = "rbxassetid://6043825885",
			Looped = false,
			Pitch = .5,
			Volume = 8,
			Parent = head,
			Play = false,
			TimePosition = 0,
			PlayOnRemove = true
		})
		Talk("ZA WARUDO...!", 0.05, Color3.new(1, 1, 0))
		wait(1)
		local TimeStopSound = CreateInstance("Sound", {
			SoundId = "rbxassetid://4580051203",
			Looped = false,
			Pitch = .5,
			Volume = 10,
			Parent = workspace,
			Play = false,
			TimePosition = 0,
			PlayOnRemove = true
		})
		Talk("You Fool, You shall know that the world's true power is indeed, The power to rule all over the world!", 0.1, Color3.new(1, 0, 0))
		TimeStop()
		timeStop = true
		tsActivate.Value = true
		--character.Head.Sound.PlaybackSpeed = 0.5
		--character.Head.Sound.Volume = 5
		local TickTok = CreateInstance("Sound", {
			SoundId = "rbxassetid://8966275754",
			Looped = true,
			Pitch = .5,
			Volume = 10,
			Parent = torso,
			Play = true,
			TimePosition = 0,
			PlayOnRemove = false
		})
		event = workspace.ChildAdded:Connect(function(object)
			if object.Name ~= "HitEffect" then
				timeStopColor(object)
				anchorObject(object)
			end
		end)
		wait(1)
		animationAction = 2
		debounce = true
	elseif key == "e" and debounce and standActive then
		debounce = false
		holding = true
		standanimationAction = 4
		coroutine.wrap(function() playAnimation("Action", 0.08, true, "StandBarrage") end)()
		follow = true
		local MudaSound = CreateInstance("Sound", {
			SoundId = "rbxassetid://4663034522",
			Looped = true,
			Pitch = .5,
			Volume = 10,
			Parent = head,
			Play = true,
			TimePosition = 0,
			PlayOnRemove = false
		})
		local talkDebounce = true
		repeat
			coroutine.wrap(function()
				if talkDebounce then
					talkDebounce = false
					Talk("HUN! USELESS USELESS USELESS USELESS USELESS", 0.02, Color3.new(1,1,1))
					wait(1.5)
					talkDebounce = true
				end
			end)()
			local pos = standtorso.Position + standrootPart.CFrame.lookVector * 4
			local mag = 3
			local damage = 0
			Damage(pos, mag, damage)
			--[BarrageEffect]--
			coroutine.wrap(function()
				for i = 1,3 do
					local part = CreateInstance("Part",{vector3(1.5, 1.5, 3), "Part", color3(255,255,50), "SmoothPlastic", 0.4, true, false}) -- size, name, color, material, transparency, anchored, cancollide
					part.CFrame = (standrootPart.CFrame - standrootPart.Position) * CFrame.Angles(rad(random(-35,35)), rad(random(-35,35)), rad(random(-35,35))) + standtorso.CFrame.p + standrootPart.CFrame.lookVector * 2 + vector3(random(-20,20)/10, random(-20,20)/10, random(-20,20)/10)
					part.Parent = character
					local Tween = CreateTween(part, {0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0},{ --[Info]: length, style, direction, repeatTimes, willRepeat, waitTime
						Size = vector3(.5, .5, 4),
						CFrame = part.CFrame + part.CFrame.lookVector * 2,
						Transparency = 1
					}, true) 
					Tween.Completed:Wait()
					NilPart(part)
				end
			end)()
			wait(0.05) until not holding
		MudaSound:Stop()
		stopAnimationsValue.Value = false
		stopAnimationsValue.Value = true

		coroutine.wrap(function() playAnimation("Action", 0.15, false, "StandBarrageFinal") end)()
		local MudaSound = CreateInstance("Sound", {
			SoundId = "rbxassetid://1277342512",
			Looped = false,
			Pitch = .5,
			Volume = 10,
			Parent = head,
			Play = false,
			TimePosition = 0,
			PlayOnRemove = true
		})
		Talk("USELESS!", 0.1, Color3.new(1,1,1))
		wait(1)
		local pos    = standtorso.Position + standrootPart.CFrame.lookVector * 4
		local mag    = 4
		local damage = 0
		Damage(pos, mag, damage)
		wait(0.5)
		standanimationAction = 2
		wait(1)
		Talk("If we were playing chess, You would've been in checkmate!", 0.1, Color3.new(1,1,1))
		local Sound = CreateInstance("Sound", {
			SoundId = "rbxassetid://616594208",
			Looped = false,
			Pitch = .5,
			Volume = 10,
			Parent = head,
			Play = false,
			TimePosition = 0,
			PlayOnRemove = true
		})
		standanimationAction = 2
		debounce = true
	elseif key == "f" and debounce and timeStop then
		timeStop = false
		character.Torso.Sound:Destroy()
		local ResumeSound = CreateInstance("Sound", {
			SoundId = "rbxassetid://4580052068",
			Looped = false,
			Pitch = .5,
			Volume = 10,
			Parent = head,
			Play = false,
			TimePosition = 0,
			PlayOnRemove = true
		})
		Talk("Time Flows", 0.1, Color3.new(1,1,1))
		wait(0.1)
		tsActivate.Value = false
		local TimeResumeSound = CreateInstance("Sound", {
			SoundId = "rbxassetid://3101648169",
			Looped = false,
			Pitch = .5,
			Volume = 1,
			Parent = workspace,
			Play = false,
			TimePosition = 0,
			PlayOnRemove = true
		})
		--character.Head.Sound.PlaybackSpeed = 1
		--character.Head.Sound.Volume = 10
		if event then
			event:disconnect()
			event = nil
		end
	elseif key == "p" and debounce then
		debounce = false
		animationAction = 4
		playingAnimation = "WRYYY"
		stopAnimationsValue.Value = false
		stopAnimationsValue.Value = true
		coroutine.wrap(function() playAnimation("Action", 0.5, false, playingAnimation) end)()
		local Sound = CreateInstance("Sound", {
			SoundId = "rbxassetid://2390708317",
			Looped = false,
			Pitch = .5,
			Volume = 10,
			Parent = head,
			Play = false,
			TimePosition = 0,
			PlayOnRemove = true
		})
		Talk("WRRRYYYYYY", 0.1, Color3.new(1,1,1))
		wait(2.5)
		animationAction = 2
		debounce = true
	end
end)

mouse.KeyUp:Connect(function(key)
	if key == "e" then
		holding = false
	end
end)

humanoid.WalkSpeed = 10
local sine = 0
local speed = 1
coroutine.wrap(function()
	while wait() do
		if timeStop and unColored then
			timeStopColor(workspace)
			anchorObject(workspace)
		elseif not timeStop and not unColored then
			returnColors()
			returnUnAnchored()
		end
		sine = sine + speed
		local rotVelocity = rootPart.RotVelocity
		local rs = rootPart.CFrame:VectorToObjectSpace(rootPart.Velocity)
		local walkSpeed = humanoid.WalkSpeed/5
		if humanoid.MoveDirection.X == 0 and humanoid.MoveDirection.Z == 0 then
			if animationAction < 3 then
				RootJoint.C0 = RootJoint.C0:Lerp(RootJointC0 * CFrame.new(0,0,0 + 0.1 * math.sin(sine / 25)/2) * CFrame.Angles(math.rad(-9.626), math.rad(12.49), math.rad(-51.853)), 0.1)
				Neck.C0 = Neck.C0:Lerp(NeckC0 * CFrame.Angles(math.rad(17.246 + 2 * math.sin(sine / 25)), math.rad(-1.662), math.rad(52.769)), 0.1)
				RS.C0 = RS.C0:Lerp(RSC0 * CFrame.new(0,0 + 0.05 * math.sin(sine / 25),0 + 0.05 * math.sin(sine / 25)) * CFrame.Angles(math.rad(19.481), math.rad(8.365), math.rad(9.454)), 0.1)
				LS.C0 = LS.C0:Lerp(LSC0 * CFrame.new(0,0 + 0.05 * math.sin(sine / 25),0 + 0.05 * math.sin(sine / 25)) * CFrame.Angles(math.rad(21.199), math.rad(-5.157), math.rad(-13.063)), 0.1)
				RH.C0 = RH.C0:Lerp(RHC0 * CFrame.new(0,0 - 0.1 * math.sin(sine / 25)/(2),0) * CFrame.Angles(math.rad(-21.028), math.rad(-20.168), math.rad(-23.72)), 0.1)
				LH.C0 = LH.C0:Lerp(LHC0 * CFrame.new(0,0 - 0.1 * math.sin(sine / 25)/(2),0) * CFrame.Angles(math.rad(-20.225), math.rad(25.497), math.rad(31.742)), 0.1)
			end
			if standActive and standanimationAction < 3 then
				standrootPart.CFrame = standrootPart.CFrame:Lerp(rootPart.CFrame, 0.1)
				standRootJoint.C0 = standRootJoint.C0:Lerp(standRootJointC0 * CFrame.new(1.697, 4.035 + 0.1 * math.sin(sine / 10), 0.924 + 0.5 * math.sin(sine / 25)) * CFrame.Angles(math.rad(15.183 - 5 * math.sin(sine / 25)), math.rad(-16.558), math.rad(-46.352)), 0.1)
				standNeck.C0 = standNeck.C0:Lerp(standNeckC0 * CFrame.Angles(math.rad(-13.407), math.rad(-2.406), math.rad(52.426)), 0.1)
				standRS.C0 = standRS.C0:Lerp(standRSC0 * CFrame.new(0.192, -0.362 + 0.2 * math.sin(sine / 24), 0) * CFrame.Angles(math.rad(-16.501), math.rad(19.767), math.rad(128.343)), 0.1)
				standLS.C0 = standLS.C0:Lerp(standLSC0 * CFrame.new(0, 0 + 0.2 * math.sin(sine / 24), 0) * CFrame.Angles(math.rad(-7.334), math.rad(53.228), math.rad(-109.721)), 0.1)
				standRH.C0 = standRH.C0:Lerp(standRHC0 * CFrame.new(1.058, 0.475, -0.046) * CFrame.Angles(math.rad(-24.866), math.rad(17.246), math.rad(-24.293 + 3 * math.sin(sine / 25))), 0.1)
				standLH.C0 = standLH.C0:Lerp(standLHC0 * CFrame.new(-1.255, 0.407, 0) * CFrame.Angles(math.rad(5.157), math.rad(7.277 + 1 * math.sin(sine / 24)), math.rad(54.603 + 3 * math.sin(sine / 25))), 0.1)
			end
		elseif humanoid.MoveDirection.X ~= 0 or humanoid.MoveDirection.Z ~= 0 then
			if standActive and standanimationAction < 3 then
				standrootPart.CFrame = standrootPart.CFrame:Lerp(rootPart.CFrame + rootPart.CFrame.lookVector * 3, 0.05)
				standRootJoint.C0 = standRootJoint.C0:Lerp(standRootJointC0 * CFrame.new(1.697, 4.035 + 0.1 * math.sin(sine / 25), 0.924 + 0.5 * math.sin(sine / 25)) * CFrame.Angles(math.rad(32.2), math.rad(-15.986), math.rad(-63.827)), 0.1)
				standNeck.C0 = standNeck.C0:Lerp(standNeckC0 * CFrame.Angles(math.rad(-17.876), math.rad(-15.241), math.rad(70.703)), 0.1)
				standRS.C0 = standRS.C0:Lerp(standRSC0 * CFrame.new(0.467, -0.442, -0.092) * CFrame.Angles(math.rad(10.141), math.rad(2.235), math.rad(144.156)), 0.1)
				standLS.C0 = standLS.C0:Lerp(standLSC0 * CFrame.new(-0.184, -0.638, 0.005) * CFrame.Angles(math.rad(21.715), math.rad(37.128), math.rad(-164.267)), 0.1)
				standRH.C0 = standRH.C0:Lerp(standRHC0 * CFrame.new(1.058, 0.475, -0.046) * CFrame.Angles(math.rad(-31.742), math.rad(25.726), math.rad(-32.544)), 0.1)
				standLH.C0 = standLH.C0:Lerp(standLHC0 * CFrame.new(-0.673, 0.213, 0.387) * CFrame.Angles(math.rad(2.521), math.rad(31.799), math.rad(49.274)), 0.1)
			end
			if animationAction < 3 then
				if not running then
					RootJoint.C0 = RootJoint.C0:Lerp(RootJointC0 * CFrame.new(0,0,0 + 0.1 * math.sin(sine / 2.5)), 0.3)
					RootJoint.C0 = RootJoint.C0:Lerp(RootJointC0 * CFrame.Angles(math.rad((-9.626) + (-rs.Z * 2)), math.rad((-rs.X * 2) + (rotVelocity.Y * 5)), 0), 0.1)
					Neck.C0 = Neck.C0:Lerp(NeckC0 * CFrame.Angles(math.rad(9.626), math.rad(-1.662), math.rad(0)), 0.3)
					RS.C0 = RS.C0:Lerp(RSC0 * CFrame.new(0,0 + 0.05 * math.cos(sine / 2.5)/2,0 + 0.05 * math.sin(sine / 2.5)/2) * CFrame.Angles(math.rad(19.481), math.rad(8.365), math.rad(9.454)), 0.3)
					LS.C0 = LS.C0:Lerp(LSC0 * CFrame.new(0,0 + 0.05 * math.cos(sine / 2.5)/2,0 + 0.05 * math.sin(sine / 2.5)/2) * CFrame.Angles(math.rad(-5.199 + 5 * math.sin(sine / 5)), math.rad(-5.157), math.rad(4.063 - 10 * math.sin(sine / 5))), 0.3)
					RH.C0 = RH.C0:Lerp(RHC0 * CFrame.new(0, 0.25 * math.cos(sine/5), 0) * CFrame.Angles(math.rad((30*math.sin(sine/5) * math.clamp(-rs.X,-1,1))), math.rad(0), math.rad((-9.626+30*math.sin(sine/5))) * math.clamp(-rs.Z,-1,1)), 0.3)
					LH.C0 = LH.C0:Lerp(LHC0 * CFrame.new(0, -0.25 * math.cos(sine/5), 0) * CFrame.Angles(math.rad((30*math.sin(sine/5) * math.clamp(-rs.X,-1,1))), math.rad(0), math.rad((9.626+30*math.sin(sine/5))) * math.clamp(-rs.Z,-1,1)), 0.3)
				else
					RootJoint.C0 = RootJoint.C0:Lerp(RootJointC0 * CFrame.new(0,0,0 + 0.1 * math.sin(sine / (1))) * CFrame.Angles(0, 0, 0), 0.3)
					RootJoint.C0 = RootJoint.C0:Lerp(RootJointC0 * CFrame.new(0,0,0 + 0.1 * math.sin(sine / 1)) * CFrame.Angles(math.rad((-9.626) + (-rs.Z * 2)), math.rad((-rs.X * 2) + (rotVelocity.Y * 5)), 0), 0.1)
					Neck.C0 = Neck.C0:Lerp(NeckC0 * CFrame.Angles(math.rad(9.626), math.rad(-1.662), math.rad(0)), 0.3)
					RS.C0 = RS.C0:Lerp(RSC0 * CFrame.new(0,0 + 0.05 * math.cos(sine / 2)/2,0 + 0.05 * math.sin(sine / 2)/2) * CFrame.Angles(math.rad(19.481), math.rad(8.365), math.rad(9.454)), 0.3)
					LS.C0 = LS.C0:Lerp(LSC0 * CFrame.new(0,0 + 0.05 * math.cos(sine / 2)/2,0 + 0.05 * math.sin(sine / 2)/2) * CFrame.Angles(math.rad(-10.199 + 3 * math.sin(sine / 2)), math.rad(-3.157), math.rad(4.063 - 50 * math.sin(sine / 2))), 0.3)
					RH.C0 = RH.C0:Lerp(RHC0 * CFrame.new(0, 0.25 * math.cos(sine/2), 0) * CFrame.Angles(math.rad((30*math.sin(sine/2) * math.clamp(-rs.X,-1,1))), math.rad(0), math.rad((-9.626+100*math.sin(sine/2))) * math.clamp(-rs.Z,-1,1)), 0.3)
					LH.C0 = LH.C0:Lerp(LHC0 * CFrame.new(0, -0.25 * math.cos(sine/2), 0) * CFrame.Angles(math.rad((30*math.sin(sine/2) * math.clamp(-rs.X,-1,1))), math.rad(0), math.rad((9.626+100*math.sin(sine/2))) * math.clamp(-rs.Z,-1,1)), 0.3)
				end
			end
		end
		if standActive and follow then
			standrootPart.CFrame = standrootPart.CFrame:Lerp(rootPart.CFrame, 0.5)
		end
	end
end)()

local Mouse = game.Players.LocalPlayer:GetMouse()
local Debounce = false
Mouse.KeyDown:Connect(function(Key)
    if Key == "c" and Debounce == false then
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(Mouse.Hit.x, Mouse.Hit.y + 5, Mouse.Hit.z)
        Debounce = true
        wait(0.5)
        Debounce = false
    end
end)
end)
end




if VPCFrame then
local FREECAM_Camera = Workspace.CurrentCamera
Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
	local newCamera = Workspace.CurrentCamera
	if newCamera then
		FREECAM_Camera = newCamera
	end
end)
local Funcs,Backups,Version = {},{},"0.12.1"
function Funcs.RandomString(Length)
	local Length = typeof(Length) == "number" and math.clamp(Length,1,100) or math.random(80,100)
	local Text = ""
	for i = 1,Length do
		Text = Text..string.char(math.random(1,128))
	end
	return Text
end
local function RandomString()
	return Funcs.RandomString(100)
end
local function randomstring()
	return Funcs.RandomString(100)
end
local LocalPlayer = game.Players.LocalPlayer
	ScreenGui = Instance.new("ScreenGui")
		ScreenGui.Name = Funcs.RandomString(100)
		ScreenGui.DisplayOrder = 2147483647
		ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
		ScreenGui.IgnoreGuiInset = true
		ScreenGui.ResetOnSpawn = false
		ScreenGui.Archivable = false
		ScreenGui.Parent = LocalPlayer:FindFirstChildOfClass("PlayerGui")
        ViewportFrame = Instance.new("ViewportFrame")
		ViewportFrame.Name = Funcs.RandomString(100)
		ViewportFrame.Size = UDim2.new(1, 0, 1, 0)
		ViewportFrame.BackgroundTransparency = 1
		ViewportFrame.Archivable = false
		ViewportFrame.Parent = ScreenGui
		ViewportFrame.CurrentCamera = FREECAM_Camera
		workspaceLOL = Instance.new("WorldModel")
		workspaceLOL.Name = Funcs.RandomString(100)
		workspaceLOL.Archivable = false
		workspaceLOL.Parent = ViewportFrame
LocalPlayer.Character.Parent = workspaceLOL
end
if NaNHealth then
spawn(function()
wait(2)
local v1 = {
    [1] = getrenv()._G.Pass, 
    [2] = "Damage", 
    [3] = "NaN", 
    [4] = game.Players.LocalPlayer.Character
}
local event = game:GetService("ReplicatedStorage").Remotes.Events
event:FireServer(v1)
end)
end
if CustomHealth then
spawn(function()
wait()
	local v1 = {
    [1] = getrenv()._G.Pass, 
    [2] = "Damage", 
    [3] = DamageToCharacter, 
    [4] = game.Players.LocalPlayer.Character
}
local event = game:GetService("ReplicatedStorage").Remotes.Events
event:FireServer(v1)
end)
end
if Unreleased then
spawn(function()
game.Workspace.Map:Destroy()
local script = game:GetObjects("rbxassetid://10744835944")[1]
script.Parent = workspace
wait(1)
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-941.471, 2258.962, -341.183)
end)
end
if NoFace then
game.Players.LocalPlayer.Character.Head.face:Destroy()
end
if FakeHealthBar then
game.Players.LocalPlayer.Character.Head.HealthBar:Destroy()
local gay = game:GetService("ReplicatedStorage").Resources.Guis.HealthBar:Clone()
            gay.Enabled = true
            gay.Active = true
            gay.Frame.PName.TextColor3 = Color3.new(1, 1, 1)
            gay.Frame.PName.TextStrokeColor3 = Color3.new(0, 0, 0)
            gay.Frame.PName.Text = player.Name
            gay.Parent = player.Character.Head
end
game:GetService("Players").LocalPlayer.PlayerGui.CharacterSelection:Destroy()
detect:Disconnect()
game.Players.LocalPlayer.Character.ForceField:Destroy()


--TIER 5 🔥☠ⒽⓊⓂⒶⓃⓄⒾⒹⓇⓄⓄⓉⓅⒶⓇⓉ ⓇⒺⓂⓄⓋⒺ☠🔥--
if Tier5 then
        local Char = game.Players.LocalPlayer.Character
		local OldParent = Char.Parent
		local HRP = Char and Char:FindFirstChild("HumanoidRootPart")
		local OldPos = HRP.CFrame
		Char.Parent = game
		local HRP1 = HRP:Clone()
		HRP1.Parent = Char
		HRP = HRP:Destroy()
		HRP1.CFrame = OldPos
		Char.Parent = OldParent
end

game:GetService("Players").LocalPlayer.PlayerScripts.ChallengeScript.Disabled = true
game:GetService("Players").LocalPlayer.PlayerScripts.ChallengeScript:Destroy()
game.Players.LocalPlayer.PlayerScripts.FireClient:Destroy()
if NoHeadMesh then
game.Players.LocalPlayer.Character.Head:FindFirstChildOfClass("SpecialMesh"):Destroy()
end
if NothingWithoutCharacter then
game.Players.LocalPlayer:ClearCharacterAppearance()
end
local fonts = {
	Enum.Font.Antique,
	Enum.Font.Arcade,
	Enum.Font.Arial,
	Enum.Font.ArialBold,
	Enum.Font.Bodoni,
	Enum.Font.Cartoon,
	Enum.Font.Code,
	Enum.Font.Fantasy,
	Enum.Font.Garamond,
	Enum.Font.Highway,
	Enum.Font.Legacy,
	Enum.Font.SciFi,
	Enum.Font.SourceSans,
	Enum.Font.SourceSansBold,
	Enum.Font.SourceSansItalic,
	Enum.Font.SourceSansLight,
	Enum.Font.SourceSansSemibold
}


--Tier 1 Regular script--
if DisabledData then
game.Players.LocalPlayer.PlayerData:Destroy()
game.Players.LocalPlayer.Character.Attacks:Destroy()
game.Players.LocalPlayer.Character.Extra:Destroy()
end
game.Players.LocalPlayer.Character.StaminaRegen:Destroy()
if not LockAbleISA then
game.Players.LocalPlayer.Character.LockOn:Destroy()
end
if NoRedHealth then
game.Players.LocalPlayer.Character.Head.HealthBar.Frame.StaminaBar:Destroy()
game.Players.LocalPlayer.Character.Head.HealthBar.Frame.BackHealth:Destroy()
end
if NilHealth then
game.Players.LocalPlayer.Character.Head.HealthBar.Frame.StaminaBar:Destroy()
game.Players.LocalPlayer.Character.Head.HealthBar.Frame.BackHealth:Destroy()
game.Players.LocalPlayer.Character.Head.HealthBar.Frame.Health:Destroy()
end
if NoYellowHealth then
game.Players.LocalPlayer.Character.Head.HealthBar.Frame.Health:Destroy()
end
if NoHealthBar then
game.Players.LocalPlayer.Character.Head.HealthBar.Frame.HP:Destroy()
game.Players.LocalPlayer.Character.Head.HealthBar.Frame.StaminaBar:Destroy()
game.Players.LocalPlayer.Character.Head.HealthBar.Frame.HealthLabel:Destroy()
game.Players.LocalPlayer.Character.Head.HealthBar.Frame.BackHealth:Destroy()
game.Players.LocalPlayer.Character.Head.HealthBar.Frame.Health:Destroy()
game.Players.LocalPlayer.Character.Head.HealthBar.Frame.Script:Destroy()
end
if HideName then
game.Players.LocalPlayer.Character.Head.HealthBar.Frame.PName:Destroy()
end
if NoHealthLabel then
game.Players.LocalPlayer.Character.Head.HealthBar.Frame.HealthLabel:Destroy()
end
if jojo then
BikeAndGunAHHHH = false
nofuckinghatsmesh = false
end
if jojo then
   for i,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
   if v:IsA("Accessory") and v.Handle:FindFirstChild("Mesh") then
   ag = v.Handle:FindFirstChild("Mesh")
   ag:Destroy()
   end
   end
end
Character = game.Players.LocalPlayer.Character
if BikeAndGunAHHHH then
nofuckinghatsmesh = false
local goofy = {Character:WaitForChild("Necklace"),
               Character:WaitForChild("Pal Hair"),
               Character:WaitForChild("LavanderHair"),
               Character:WaitForChild("Pink Hair"),
               Character:WaitForChild("Robloxclassicred"),
               Character:WaitForChild("rol_icebrainAccessory"),
               Character:WaitForChild("Kate Hair"),
}

for i,v in next, goofy do
for _,mesh in next, v:GetDescendants() do
if mesh:IsA("Mesh") or mesh:IsA("SpecialMesh") then
mesh:Remove()
end
end
end
end

if NoClothes then
pchar = game.Players.LocalPlayer.Character
if pchar:FindFirstChild("Shirt") then
   pchar.Shirt:Remove()
end
if pchar:FindFirstChild("Pants") then
   pchar.Pants:Remove()
end
if pchar:FindFirstChild("Shirt Graphic") then
   pchar["Shirt Graphic"].Graphic = ""
end
end

if nofuckinghatsmesh then
for _,v in pairs(game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid'):GetAccessories()) do
		for i,c in pairs(v:GetDescendants()) do
			if c:IsA("SpecialMesh") then
			c:Destroy()
			end
		end
	end
end

--Tier 2 Removing velocity from the character--
for i,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
		if v:IsA("BodyVelocity") or v:IsA("BodyGyro") or v:IsA("RocketPropulsion") or v:IsA("BodyThrust") or v:IsA("BodyAngularVelocity") or v:IsA("AngularVelocity") or v:IsA("BodyForce") or v:IsA("VectorForce") or v:IsA("LineForce") then
			v:Destroy()
		end
	end
--Tier 3 CORRUPTION--
if StopCharacterFromLoadingV2 then
spawn(function()
task.wait(3)
game:GetService("Workspace").ServerEffects:Destroy()
if game:GetService("Players").LocalPlayer.Backpack:FindFirstChildOfClass("Folder") then
game:GetService("Players").LocalPlayer.Backpack:FindFirstChildOfClass("Folder"):Destroy()
end
end)
end
if CharCorruption then
local detect 
detect = rs.Heartbeat:Connect(function()
game.Players.LocalPlayer.Character.Name = randomstring()
game.Players.LocalPlayer.DisplayName = randomstring()
end)
end
local secondsElapsed = 0
local timeout = 5
if not HideName then
if SlowLoading then
while true do
    game.Players.LocalPlayer.Character.Head.HealthBar.Frame.PName.Text = randomstring()
if FreezeAnim then
for i,v in pairs(game.Players.LocalPlayer.Character.Humanoid:GetDescendants()) do
		if v:IsA("Animator") then
			v:Destroy()
		end
	end
end
	wait(1)
	secondsElapsed = secondsElapsed + 1
 
	if secondsElapsed == timeout then
        
        game.Players.LocalPlayer.Character.Head.HealthBar.Frame.PName.Text = game.Players.LocalPlayer.Name
		break
	end
end
end
end
--Tier 6 Reanimation--
if not spawnonly then
wait(1)
local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local twait = task.wait
local tdelay = task.delay
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local angles = CFrame.Angles
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
    return
end

c:GetPropertyChangedSignal("Parent"):Connect(function()
    if not (c and c.Parent) then
        c = nil
    end
end)

local clone, destroy, getchildren, getdescendants, isa = c.Clone, c.Destroy, c.GetChildren, c.GetDescendants, c.IsA

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(getchildren(parent)) do
            if (v.Name == name) and isa(v, className) then
                return v
            end
        end
    end
    return nil
end

if type(getNetlessVelocity) ~= "function" then
    getNetlessVelocity = nil
end

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad
local ino = fenv.isnetworkowner or fenv.is_network_owner or fenv.isnetowner or fenv.is_net_owner

healthHide = healthHide and ((method == 0) or (method == 3)) and gp(c, "Head", "BasePart")

if (alignmode == 4) and (not ino) then alignmode = 2 end

if type(getNetlessVelocity) ~= "function" then
    getNetlessVelocity = function(v) return v end
end

local function align(Part0, Part1)
    
    local att0 = Instance.new("Attachment")
    att0.Orientation = v3_0
    att0.Position = v3_0
    att0.Name = "att0_" .. Part0.Name
    local att1 = Instance.new("Attachment")
    att1.Orientation = v3_0
    att1.Position = v3_0
    att1.Name = "att1_" .. Part1.Name
    
    if alignmode == 4 then
    
        local hide = false
        if Part0 == healthHide then
            healthHide = false
            tdelay(0, function()
                while twait(2.9) and Part0 and c do
                    hide = #Part0:GetConnectedParts() == 1
                    twait(0.1)
                    hide = false
                end
            end)
        end
        
        local rot = math.rad(0.05)
        local con = nil
        con = heartbeat:Connect(function()
            if Part0 and Part1 and att1 then
                if ino(Part0) then
                    Part0.CFrame = Part1.CFrame * att1.CFrame * angles(0, 0, rot)
                    if hide then
                        Part0.Position += v3(0, 3000, 0)
                    end
                    rot = -rot
                end
                hbcf = Part0.CFrame
            else
                con:Disconnect()
            end
        end)
    
    else
        
        Part0.CustomPhysicalProperties = physp
        if (alignmode == 1) or (alignmode == 2) then
            local ape = Instance.new("AlignPosition")
            ape.ApplyAtCenterOfMass = false
            ape.MaxForce = inf
            ape.MaxVelocity = inf
            ape.ReactionForceEnabled = false
            ape.Responsiveness = 200
            ape.Attachment1 = att1
            ape.Attachment0 = att0
            ape.Name = "AlignPositionRtrue"
            ape.RigidityEnabled = true
            ape.Parent = att0
        end
        
        if (alignmode == 2) or (alignmode == 3) then
            local apd = Instance.new("AlignPosition")
            apd.ApplyAtCenterOfMass = false
            apd.MaxForce = inf
            apd.MaxVelocity = inf
            apd.ReactionForceEnabled = false
            apd.Responsiveness = 200
            apd.Attachment1 = att1
            apd.Attachment0 = att0
            apd.Name = "AlignPositionRfalse"
            apd.RigidityEnabled = false
            apd.Parent = att0
        end
        
        local ao = Instance.new("AlignOrientation")
        ao.MaxAngularVelocity = inf
        ao.MaxTorque = inf
        ao.PrimaryAxisOnly = false
        ao.ReactionTorqueEnabled = false
        ao.Responsiveness = 200
        ao.Attachment1 = att1
        ao.Attachment0 = att0
        ao.RigidityEnabled = false
        ao.Parent = att0
    
    end

    local vel = Part0.Velocity
    local con0, con1 = nil, nil
    if alignmode == 4 then
        con0 = stepped:Connect(function()
            if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
            Part0.RotVelocity = Part1.RotVelocity
        end)
        con1 = heartbeat:Connect(function()
            if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
            Part0.Velocity = getNetlessVelocity(Part1.Velocity)
        end)
    else
        con0 = renderstepped:Connect(function()
            if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
            Part0.Velocity = vel
        end)
        con1 = heartbeat:Connect(function()
            if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
            vel = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(Part1.Velocity)
        end)
    end
    
    att0:GetPropertyChangedSignal("Parent"):Connect(function()
        Part0 = att0.Parent
        if not isa(Part0, "BasePart") then
            att0 = nil
            Part0 = nil
        end
    end)
    att0.Parent = Part0
    
    att1:GetPropertyChangedSignal("Parent"):Connect(function()
        Part1 = att1.Parent
        if not isa(Part1, "BasePart") then
            att1 = nil
            Part1 = nil
        end
    end)
    att1.Parent = Part1
end

local function respawnrequest()
    local ccfr = ws.CurrentCamera.CFrame
    local c = lp.Character
    lp.Character = nil
    lp.Character = c
    local con = nil
    con = ws.CurrentCamera.Changed:Connect(function(prop)
        if (prop ~= "Parent") and (prop ~= "CFrame") then
            return
        end
        ws.CurrentCamera.CFrame = ccfr
        con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and lp:FindFirstChildOfClass("Backpack")

if type(simrad) ~= "number" then simrad = 1000 end
if shp and (simradius == "shp") then
    tdelay(0, function()
        while c do
            shp(lp, "SimulationRadius", simrad)
            heartbeat:Wait()
        end
    end)
elseif ssr and (simradius == "ssr") then
    tdelay(0, function()
        while c do
            ssr(simrad)
            heartbeat:Wait()
        end
    end)
end

if antiragdoll then
    antiragdoll = function(v)
        if isa(v, "HingeConstraint") or isa(v, "BallSocketConstraint") then
            v.Parent = nil
        end
    end
    for i, v in pairs(getdescendants(c)) do
        antiragdoll(v)
    end
    c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
    respawnrequest()
end

if method == 0 then
    twait(loadtime)
    if not c then
        return
    end
end

if discharscripts then
    for i, v in pairs(getchildren(c)) do
        if isa(v, "LocalScript") then
            v.Disabled = true
        end
    end
elseif newanimate then
    local animate = gp(c, "Animate", "LocalScript")
    if animate and (not animate.Disabled) then
        animate.Disabled = true
    else
        newanimate = false
    end
end

if addtools then
    for i, v in pairs(getchildren(addtools)) do
        if isa(v, "Tool") then
            v.Parent = c
        end
    end
end

pcall(function()
    settings().Physics.AllowSleep = false
    settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(getdescendants(c)) do
    if v.ClassName == "Script" then
        OLDscripts[v.Name] = true
    end
end

local scriptNames = {}

for i, v in pairs(getdescendants(c)) do
    if isa(v, "BasePart") then
        local newName = tostring(i)
        local exists = true
        while exists do
            exists = OLDscripts[newName]
            if exists then
                newName = newName .. "_"    
            end
        end
        table.insert(scriptNames, newName)
        Instance.new("Script", v).Name = newName
    end
end

local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
    for i, v in pairs(hum:GetPlayingAnimationTracks()) do
        v:Stop()
    end
end
c.Archivable = true
local cl = clone(c)
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        twait(1.6)
    end
end
if destroyhum then
    pcall(destroy, hum)
end

if not c then
    return
end

local head, torso, root = gp(c, "Head", "BasePart"), gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart"), gp(c, "HumanoidRootPart", "BasePart")
if hatcollide then
    pcall(destroy, torso)
    pcall(destroy, root)
    pcall(destroy, c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script"))
end

local model = Instance.new("Model", c)
model:GetPropertyChangedSignal("Parent"):Connect(function()
    if not (model and model.Parent) then
        model = nil
    end
end)

for i, v in pairs(getchildren(c)) do
    if v ~= model then
        if addtools and isa(v, "Tool") then
            for i1, v1 in pairs(getdescendants(v)) do
                if v1 and v1.Parent and isa(v1, "BasePart") then
                    local bv = Instance.new("BodyVelocity")
                    bv.Velocity = v3_0
                    bv.MaxForce = v3(1000, 1000, 1000)
                    bv.P = 1250
                    bv.Name = "bv_" .. v.Name
                    bv.Parent = v1
                end
            end
        end
        v.Parent = model
    end
end

if breakjoints then
    model:BreakJoints()
else
    if head and torso then
        for i, v in pairs(getdescendants(model)) do
            if isa(v, "JointInstance") then
                local save = false
                if (v.Part0 == torso) and (v.Part1 == head) then
                    save = true
                end
                if (v.Part0 == head) and (v.Part1 == torso) then
                    save = true
                end
                if save then
                    if hedafterneck then
                        hedafterneck = v
                    end
                else
                    pcall(destroy, v)
                end
            end
        end
    end
    if method == 3 then
        task.delay(loadtime, pcall, model.BreakJoints, model)
    end
end

cl.Parent = ws
for i, v in pairs(getchildren(cl)) do
    v.Parent = c
end
pcall(destroy, cl)

local uncollide, noclipcon = nil, nil
if noclipAllParts then
    uncollide = function()
        if c then
            for i, v in pairs(getdescendants(c)) do
                if isa(v, "BasePart") then
                    v.CanCollide = false
                end
            end
        else
            noclipcon:Disconnect()
        end
    end
else
    uncollide = function()
        if model then
            for i, v in pairs(getdescendants(model)) do
                if isa(v, "BasePart") then
                    v.CanCollide = false
                end
            end
        else
            noclipcon:Disconnect()
        end
    end
end
noclipcon = stepped:Connect(uncollide)
uncollide()

for i, scr in pairs(getdescendants(model)) do
    if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
        local Part0 = scr.Parent
        if isa(Part0, "BasePart") then
            for i1, scr1 in pairs(getdescendants(c)) do
                if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
                    local Part1 = scr1.Parent
                    if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
                        align(Part0, Part1)
                        pcall(destroy, scr)
                        pcall(destroy, scr1)
                        break
                    end
                end
            end
        end
    end
end

for i, v in pairs(getdescendants(c)) do
    if v and v.Parent and (not v:IsDescendantOf(model)) then
        if isa(v, "Decal") then
            v.Transparency = 1
        elseif isa(v, "BasePart") then
            v.Transparency = 1
            v.Anchored = false
        elseif isa(v, "ForceField") then
            v.Visible = false
        elseif isa(v, "Sound") then
            v.Playing = false
        elseif isa(v, "BillboardGui") or isa(v, "SurfaceGui") or isa(v, "ParticleEmitter") or isa(v, "Fire") or isa(v, "Smoke") or isa(v, "Sparkles") then
            v.Enabled = false
        end
    end
end

if newanimate then
    local animate = gp(c, "Animate", "LocalScript")
    if animate then
        animate.Disabled = false
    end
end

if addtools then
    for i, v in pairs(getchildren(c)) do
        if isa(v, "Tool") then
            v.Parent = addtools
        end
    end
end

local hum0, hum1 = model:FindFirstChildOfClass("Humanoid"), c:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (hum0 and hum0.Parent) then
            hum0 = nil
        end
    end)
end
if hum1 then
    hum1:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (hum1 and hum1.Parent) then
            hum1 = nil
        end
    end)

    ws.CurrentCamera.CameraSubject = hum1
    local camSubCon = nil
    local function camSubFunc()
        camSubCon:Disconnect()
        if c and hum1 then
            ws.CurrentCamera.CameraSubject = hum1
        end
    end
    camSubCon = renderstepped:Connect(camSubFunc)
    if hum0 then
        hum0:GetPropertyChangedSignal("Jump"):Connect(function()
            if hum1 then
                hum1.Jump = hum0.Jump
            end
        end)
    else
        respawnrequest()
    end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
    pcall(destroy, rb)
    sg:SetCore("ResetButtonCallback", true)
    if destroyhum then
        if c then c:BreakJoints() end
        return
    end
    if model and hum0 and (hum0.Health > 0) then
        model:BreakJoints()
        hum0.Health = 0
    end
    if antirespawn then
        respawnrequest()
    end
end)
sg:SetCore("ResetButtonCallback", rb)

tdelay(0, function()
    while c do
        if hum0 and hum1 then
            hum1.Jump = hum0.Jump
        end
        wait()
    end
    sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
    if part then
        local cfr = part.CFrame
        local R6parts = { 
            head = {
                Name = "Head",
                Size = v3(2, 1, 1),
                R15 = {
                    Head = 0
                }
            },
            torso = {
                Name = "Torso",
                Size = v3(2, 2, 1),
                R15 = {
                    UpperTorso = 0.2,
                    LowerTorso = -0.8
                }
            },
            root = {
                Name = "HumanoidRootPart",
                Size = v3(2, 2, 1),
                R15 = {
                    HumanoidRootPart = 0
                }
            },
            leftArm = {
                Name = "Left Arm",
                Size = v3(1, 2, 1),
                R15 = {
                    LeftHand = -0.849,
                    LeftLowerArm = -0.174,
                    LeftUpperArm = 0.415
                }
            },
            rightArm = {
                Name = "Right Arm",
                Size = v3(1, 2, 1),
                R15 = {
                    RightHand = -0.849,
                    RightLowerArm = -0.174,
                    RightUpperArm = 0.415
                }
            },
            leftLeg = {
                Name = "Left Leg",
                Size = v3(1, 2, 1),
                R15 = {
                    LeftFoot = -0.85,
                    LeftLowerLeg = -0.29,
                    LeftUpperLeg = 0.49
                }
            },
            rightLeg = {
                Name = "Right Leg",
                Size = v3(1, 2, 1),
                R15 = {
                    RightFoot = -0.85,
                    RightLowerLeg = -0.29,
                    RightUpperLeg = 0.49
                }
            }
        }
        for i, v in pairs(getchildren(c)) do
            if isa(v, "BasePart") then
                for i1, v1 in pairs(getchildren(v)) do
                    if isa(v1, "Motor6D") then
                        v1.Part0 = nil
                    end
                end
            end
        end
        part.Archivable = true
        for i, v in pairs(R6parts) do
            local part = clone(part)
            part:ClearAllChildren()
            part.Name = v.Name
            part.Size = v.Size
            part.CFrame = cfr
            part.Anchored = false
            part.Transparency = 1
            part.CanCollide = false
            for i1, v1 in pairs(v.R15) do
                local R15part = gp(c, i1, "BasePart")
                local att = gp(R15part, "att1_" .. i1, "Attachment")
                if R15part then
                    local weld = Instance.new("Weld", R15part)
                    weld.Name = "Weld_" .. i1
                    weld.Part0 = part
                    weld.Part1 = R15part
                    weld.C0 = cf(0, v1, 0)
                    weld.C1 = cf(0, 0, 0)
                    R15part.Massless = true
                    R15part.Name = "R15_" .. i1
                    R15part.Parent = part
                    if att then
                        att.Parent = part
                        att.Position = v3(0, v1, 0)
                    end
                end
            end
            part.Parent = c
            R6parts[i] = part
        end
        local R6joints = {
            neck = {
                Parent = R6parts.torso,
                Name = "Neck",
                Part0 = R6parts.torso,
                Part1 = R6parts.head,
                C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
            },
            rootJoint = {
                Parent = R6parts.root,
                Name = "RootJoint" ,
                Part0 = R6parts.root,
                Part1 = R6parts.torso,
                C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
            },
            rightShoulder = {
                Parent = R6parts.torso,
                Name = "Right Shoulder",
                Part0 = R6parts.torso,
                Part1 = R6parts.rightArm,
                C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
            },
            leftShoulder = {
                Parent = R6parts.torso,
                Name = "Left Shoulder",
                Part0 = R6parts.torso,
                Part1 = R6parts.leftArm,
                C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
            },
            rightHip = {
                Parent = R6parts.torso,
                Name = "Right Hip",
                Part0 = R6parts.torso,
                Part1 = R6parts.rightLeg,
                C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
            },
            leftHip = {
                Parent = R6parts.torso,
                Name = "Left Hip" ,
                Part0 = R6parts.torso,
                Part1 = R6parts.leftLeg,
                C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
            }
        }
        for i, v in pairs(R6joints) do
            local joint = Instance.new("Motor6D")
            for prop, val in pairs(v) do
                joint[prop] = val
            end
            R6joints[i] = joint
        end
        if hum1 then
            hum1.RigType = Enum.HumanoidRigType.R6
            hum1.HipHeight = 0
        end
    end
end

local torso1 = torso
torso = gp(c, "Torso", "BasePart") or ((not R15toR6) and gp(c, torso.Name, "BasePart"))
if (typeof(hedafterneck) == "Instance") and head and torso and torso1 then
    local conNeck = nil
    local conTorso = nil
    local contorso1 = nil
    local aligns = {}
    local function enableAligns()
        conNeck:Disconnect()
        conTorso:Disconnect()
        conTorso1:Disconnect()
        for i, v in pairs(aligns) do
            v.Enabled = true
        end
    end
    conNeck = hedafterneck.Changed:Connect(function(prop)
        if table.find({"Part0", "Part1", "Parent"}, prop) then
            enableAligns()
        end
    end)
    conTorso = torso:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
    conTorso1 = torso1:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
    for i, v in pairs(getdescendants(head)) do
        if isa(v, "AlignPosition") or isa(v, "AlignOrientation") then
            i = tostring(i)
            aligns[i] = v
            v:GetPropertyChangedSignal("Parent"):Connect(function()
                aligns[i] = nil
            end)
            v.Enabled = false
        end
    end
end

local flingpart0 = gp(model, flingpart, "BasePart") or gp(gp(model, flingpart, "Accessory"), "Handle", "BasePart")
local flingpart1 = gp(c, flingpart, "BasePart") or gp(gp(c, flingpart, "Accessory"), "Handle", "BasePart")

local fling = function() end
if flingpart0 and flingpart1 then
    flingpart0:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (flingpart0 and flingpart0.Parent) then
            flingpart0 = nil
            fling = function() end
        end
    end)
    flingpart0.Archivable = true
    flingpart1:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (flingpart1 and flingpart1.Parent) then
            flingpart1 = nil
            fling = function() end
        end
    end)
    local att0 = gp(flingpart0, "att0_" .. flingpart0.Name, "Attachment")
    local att1 = gp(flingpart1, "att1_" .. flingpart1.Name, "Attachment")
    if att0 and att1 then
        att0:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (att0 and att0.Parent) then
                att0 = nil
                fling = function() end
            end
        end)
        att1:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (att1 and att1.Parent) then
                att1 = nil
                fling = function() end
            end
        end)
        local lastfling = nil
        local mouse = lp:GetMouse()
        fling = function(target, duration, rotVelocity)
            if typeof(target) == "Instance" then
                if isa(target, "BasePart") then
                    target = target.Position
                elseif isa(target, "Model") then
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                elseif isa(target, "Humanoid") then
                    target = target.Parent
                    if not (target and isa(target, "Model")) then
                        return
                    end
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                else
                    return
                end
            elseif typeof(target) == "CFrame" then
                target = target.Position
            elseif typeof(target) ~= "Vector3" then
                target = mouse.Hit
                if target then
                    target = target.Position
                else
                    return
                end
            end
            if target.Y < ws.FallenPartsDestroyHeight + 5 then
                target = v3(target.X, ws.FallenPartsDestroyHeight + 5, target.Z)
            end
            lastfling = target
            if type(duration) ~= "number" then
                duration = tonumber(duration) or 0.5
            end
            if typeof(rotVelocity) ~= "Vector3" then
                rotVelocity = v3(20000, 20000, 20000)
            end
            if not (target and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            flingpart0.Archivable = true
            local flingpart = clone(flingpart0)
            flingpart.Transparency = 1
            flingpart.CanCollide = false
            flingpart.Name = "flingpart_" .. flingpart0.Name
            flingpart.Anchored = true
            flingpart.Velocity = v3_0
            flingpart.RotVelocity = v3_0
            flingpart.Position = target
            flingpart:GetPropertyChangedSignal("Parent"):Connect(function()
                if not (flingpart and flingpart.Parent) then
                    flingpart = nil
                end
            end)
            flingpart.Parent = flingpart1
            if flingpart0.Transparency > 0.5 then
                flingpart0.Transparency = 0.5
            end
            att1.Parent = flingpart
            local con = nil
            local rotchg = v3(0, rotVelocity.Unit.Y * -1000, 0)
            con = heartbeat:Connect(function(delta)
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart.Orientation += rotchg * delta
                    flingpart0.RotVelocity = rotVelocity
                else
                    con:Disconnect()
                end
            end)
            if alignmode ~= 4 then
                local con = nil
                con = renderstepped:Connect(function()
                    if flingpart0 and target then
                        flingpart0.RotVelocity = v3_0
                    else
                        con:Disconnect()
                    end
                end)
            end
            twait(duration)
            if lastfling ~= target then
                if flingpart then
                    if att1 and (att1.Parent == flingpart) then
                        att1.Parent = flingpart1
                    end
                    pcall(destroy, flingpart)
                end
                return
            end
            target = nil
            if not (flingpart and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            flingpart0.RotVelocity = v3_0
            att1.Parent = flingpart1
            pcall(destroy, flingpart)
        end
    end
end
if HMController then
lp:GetMouse().Button1Down:Connect(fling)
end
if TurnLockOn then
local script = game:GetObjects("rbxassetid://6707102945")[1]
script.LockOnScript.Parent = game:GetService("Players").LocalPlayer.Character
local script = game.Players.LocalPlayer.Character.LockOnScript
function Lerp(p1, p2, p3)
	return p1 + (p2 - p1) * p3;
end;
local l__LocalPlayer__1 = game.Players.LocalPlayer;
local v3 = l__LocalPlayer__1.Character or l__LocalPlayer__1.CharacterAdded:Wait();
local l__HumanoidRootPart__4 = v3:FindFirstChild("HumanoidRootPart");
local l__Humanoid__5 = v3:WaitForChild("Humanoid");
local l__UserInputService__6 = game:GetService("UserInputService");
local l__disableCamera__7 = script:WaitForChild("disableCamera");
local v8 = Vector3.new(5, 0, 19);
_G.RootPartFollow = true;
local u1 = false;
local u2 = false;
local u3 = false;
local u4 = false;
local l__LockOn__5 = script:WaitForChild("LockOn");
local l__mouse__6 = l__LocalPlayer__1:GetMouse();
l__UserInputService__6.InputBegan:Connect(function(p4, p5)
	if not p5 then
		if p4.KeyCode == Enum.KeyCode.W then
			u1 = true;
		elseif p4.KeyCode == Enum.KeyCode.A then
			u2 = true;
		elseif p4.KeyCode == Enum.KeyCode.S then
			u3 = true;
		elseif p4.KeyCode == Enum.KeyCode.D then
			u4 = true;
		end;
		if p4.UserInputType == Enum.UserInputType.MouseButton3 or p4.KeyCode == Enum.KeyCode.L then
			local v9 = nil;
			local v10 = nil;
			local v11 = nil;
			local v12 = nil;
			local v13 = nil;
			local v14 = nil;
			if not l__LockOn__5.Value then
				if l__mouse__6.Target.Parent:IsA("Model") and l__mouse__6.Target.Parent:FindFirstChild("Humanoid") and l__mouse__6.Target.Parent ~= v3 and l__Humanoid__5.Health > 0 then 
					if l__mouse__6.Target.Parent:IsA("Accessory") then
						l__LockOn__5.Value = l__mouse__6.Target.Parent.Parent;
					elseif l__mouse__6.Target.Parent:FindFirstChild("Humanoid") then
						l__LockOn__5.Value = l__mouse__6.Target.Parent;
					end;
					l__UserInputService__6.MouseBehavior = Enum.MouseBehavior.LockCenter;
					return;
				end;
				v9 = l__LockOn__5;
				v10 = "Value";
				v11 = v9;
				v12 = v10;
				v13 = v11[v12];
				v14 = v13;
				if v14 then
					l__LockOn__5.Value = nil;
					l__UserInputService__6.MouseBehavior = Enum.MouseBehavior.Default;
				end;
			elseif l__Humanoid__5.Health > 0 then
				v9 = l__LockOn__5;
				v10 = "Value";
				v11 = v9;
				v12 = v10;
				v13 = v11[v12];
				v14 = v13;
				if v14 then
					l__LockOn__5.Value = nil;
					l__UserInputService__6.MouseBehavior = Enum.MouseBehavior.Default;
				end;
			end;
		end;
	end;
end);
l__UserInputService__6.InputEnded:Connect(function(p6, p7)
	if p6.KeyCode == Enum.KeyCode.W then
		u1 = false;
		return;
	end;
	if p6.KeyCode == Enum.KeyCode.A then
		u2 = false;
		return;
	end;
	if p6.KeyCode == Enum.KeyCode.S then
		u3 = false;
		return;
	end;
	if p6.KeyCode == Enum.KeyCode.D then
		u4 = false;
	end;
end);
local l__CurrentCamera__7 = workspace.CurrentCamera;
game:GetService("RunService").RenderStepped:Connect(function()
	if l__LockOn__5.Value and l__LockOn__5.Value:FindFirstChild("HumanoidRootPart") and l__Humanoid__5.Health > 0 then
		if not script.UseMouse.Value then
			game:GetService("UserInputService").MouseIconEnabled = false;
		else
			game:GetService("UserInputService").MouseIconEnabled = true;
		end;
		local l__magnitude__15 = (l__HumanoidRootPart__4.Position - l__LockOn__5.Value:FindFirstChild("HumanoidRootPart").Position).magnitude;
		local v16 = CFrame.new(l__HumanoidRootPart__4.CFrame.p + Vector3.new(0, 1, 0));
		local v17 = (l__HumanoidRootPart__4.Position + l__LockOn__5.Value:FindFirstChild("HumanoidRootPart").Position) / 2;
		local v18 = l__magnitude__15;
		if l__magnitude__15 > 20 then
			v18 = 60;
		end;
		if l__magnitude__15 <= 20 then
			v18 = 20;
		end;
		local v19 = (l__HumanoidRootPart__4.Position.Y - l__LockOn__5.Value.HumanoidRootPart.Position.Y) / 2;
		if v19 < 0 then
			v19 = -v19;
		end;
		local v20 = math.clamp(l__Humanoid__5.WalkSpeed / 50, 0, 1.5);
		l__CurrentCamera__7.CFrame = l__CurrentCamera__7.CFrame:lerp(CFrame.new((v16 + l__CurrentCamera__7.CFrame.rightVector * (v18 / 5.5 + (l__HumanoidRootPart__4.Position.Y - l__LockOn__5.Value.HumanoidRootPart.Position.Y) / 10) - l__CurrentCamera__7.CFrame.lookVector * 10 - CFrame.new(l__HumanoidRootPart__4.Position, Vector3.new(l__LockOn__5.Value.HumanoidRootPart.Position.X, l__HumanoidRootPart__4.Position.Y, l__LockOn__5.Value.HumanoidRootPart.Position.Z)).lookVector * (5 + v19)).p, v17), 0.4);
		if not (not l__LockOn__5.Value) and (not (not l__LockOn__5.Value:FindFirstChild("HumanoidRootPart")) and not (not _G.RootPartFollow)) or script.Aim.Value and _G.RootPartFollow then
			local l__HumanoidRootPart__21 = l__LockOn__5.Value:FindFirstChild("HumanoidRootPart");
			l__HumanoidRootPart__4.CFrame = CFrame.new(l__HumanoidRootPart__4.Position, Vector3.new(l__HumanoidRootPart__21.Position.X, l__HumanoidRootPart__4.Position.Y, l__HumanoidRootPart__21.Position.Z));
		end;
		if l__Humanoid__5.Health == 0 or not workspace:FindFirstChild(l__LockOn__5.Value.Name) or l__LockOn__5.Value.Humanoid.Health == 0 then

		end;
	elseif l__Humanoid__5.Health > 0 then
		if _G.RootPartFollow then
			l__Humanoid__5.AutoRotate = true;
		else
			l__Humanoid__5.AutoRotate = false;
		end;
		l__LockOn__5.Value = nil;
		game:GetService("UserInputService").MouseIconEnabled = true;
	end;
	if l__LockOn__5.Value and l__LockOn__5.Value:FindFirstChild("HumanoidRootPart") and l__Humanoid__5.Health > 0 then
		l__Humanoid__5.AutoRotate = false;
		local v22 = Vector3.new(0, 0, 0);
		if u1 then
			local v23, v24 = workspace:FindPartOnRay(Ray.new(l__HumanoidRootPart__4.Position, l__HumanoidRootPart__4.CFrame.lookVector * 4), v3);
			if v23 and v23.CanCollide then
				v22 = v22 + Vector3.new(0, 0, 0);
			else
				v22 = v22 + Vector3.new(0, 0, 1);
			end;
		end;
		if u3 then
			v22 = v22 - Vector3.new(0, 0, 1);
		end;
		if u2 then
			v22 = v22 - Vector3.new(1, 0, 0);
		end;
		if u4 then
			v22 = v22 + Vector3.new(1, 0, 0);
		end;
		l__Humanoid__5:MoveTo(CFrame.new(l__HumanoidRootPart__4.Position, l__LockOn__5.Value:FindFirstChild("HumanoidRootPart").Position).p + CFrame.new(l__HumanoidRootPart__4.Position, l__LockOn__5.Value:FindFirstChild("HumanoidRootPart").Position).lookVector * (v22.Z * l__Humanoid__5.WalkSpeed) + CFrame.new(l__HumanoidRootPart__4.Position, l__LockOn__5.Value:FindFirstChild("HumanoidRootPart").Position).rightVector * (v22.X * l__Humanoid__5.WalkSpeed));
	end;
end);
end
if TIER7 then
local Cam = workspace.CurrentCamera
	local Pos, Char = Cam.CFrame, game.Players.LocalPlayer.Character
	local Human = Char and Char.FindFirstChildWhichIsA(Char, "Humanoid")
	local nHuman = Human.Clone(Human)
	nHuman.Parent, game.Players.LocalPlayer.Character = Char, nil
	nHuman.SetStateEnabled(nHuman, 15, false)
	nHuman.SetStateEnabled(nHuman, 1, false)
	nHuman.SetStateEnabled(nHuman, 0, false)
	nHuman.BreakJointsOnDeath, Human = true, Human.Destroy(Human)
	game.Players.LocalPlayer.Character, Cam.CameraSubject, Cam.CFrame = Char, nHuman, wait() and Pos
	nHuman.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
	nHuman.Health = nHuman.MaxHealth
end
local detect 
detect = rs.Heartbeat:Connect(function()
if not CustomHealth then
game.Players.LocalPlayer.Character.Model.Head.HealthBar.Frame.HealthLabel.Font = fonts[math.random(1,#fonts)]
game.Players.LocalPlayer.Character.Data.Blocking.Value = randomstring()
game.Players.LocalPlayer.Character.Data.PoisonDamage.Value = randomstring()
game.Players.LocalPlayer.Character.Data.Poison.Value = randomstring()
game.Players.LocalPlayer.Character.Data.PerfectBlocking.Value = randomstring()
game.Players.LocalPlayer.Character.Data.Stamina.Value = randomstring()
game.Players.LocalPlayer.Character.Data.MaxStamina.Value = randomstring()
game.Players.LocalPlayer.Character.Data.Defense.Value = randomstring()
game.Players.LocalPlayer.Character.Data.Attack.Value = randomstring()
game.Players.LocalPlayer.Character.Data.SprintMeter.Value = randomstring()
game.Players.LocalPlayer.Character.Data.MaxSprintMeter.Value = randomstring()
end
if not ImCumming == 4 then
game.Players.LocalPlayer.Character.Humanoid.MaxHealth = math.huge
game.Players.LocalPlayer.Character.Humanoid.Health = math.huge
game.Players.LocalPlayer.Character.Model.Humanoid.MaxHealth = math.huge
game.Players.LocalPlayer.Character.Model.Humanoid.Health = math.huge
end
end)
end
if VR then
--[[---------Settings---------]]--
local game = game
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local sethidden = sethiddenproperty or set_hidden_property or set_hidden_prop
coroutine.wrap(function()
    while wait() do
        sethidden(Players.LocalPlayer, "SimulationRadius", math.huge)
        sethidden(Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)()
RunService.Stepped:Connect(function()
sethidden(Players.LocalPlayer, "SimulationRadius", math.huge)
Players.LocalPlayer.MaximumSimulationRadius = math.huge
end)
local bodyTransparency = 0 --Change the transparency of your character (0 - 1)
local bodyVelocity = {-17.7, 0, -17.7} --Change your body parts velocity. First number value is the X value. Second number value is the Y value. Third number value is the Z value.
local hatVelocity = {-17.7, 0, -17.7} --Change your accessory's velocity. First number value is the X value. Second number value is the Y value. Third number value is the Z value.
--Velocity is not recommended to be (-17.7, 0, -17.7) in R15 since body parts often fall in R15.
--[[--------------------------]]--

local player1 = Players.LocalPlayer
local character1 = player1.Character

--Fake Character--
--Create Attachment Function
local function CreateAttachment(parent, position, orientation, axis, secondaryAxis, name)
    local newAttchment = Instance.new("Attachment", parent)
    newAttchment.Position = position
    newAttchment.Orientation = orientation
    newAttchment.Axis = axis
    newAttchment.SecondaryAxis = secondaryAxis
    newAttchment.Name = name
end

--Variables
local player1 = Players.LocalPlayer
local character1 = player1.Character
local hrp = character1.HumanoidRootPart

for i,v in pairs(character1:GetChildren()) do
    if v:IsA("LocalScript") then
        v:Destroy()
    end
end

local camera = workspace.CurrentCamera
workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
	camera = (workspace.CurrentCamera or workspace:FindFirstChild("Camera") or Instance.new("Camera"))
end)

local reanimFolder = Instance.new("Folder", character1)
reanimFolder.Name = "FakeCharacter"

local model = Instance.new("Model", reanimFolder)
model.Name = "Reanimation"

local userInputService = game:GetService("UserInputService")
local movingW, movingA, movingS, movingD, jumping = false

--Body Parts--
--Head
local cHead = Instance.new("Part")
cHead.Parent = model
cHead.Size = Vector3.new(2, 1, 1)
cHead.Name = "Head"

--Torso
local cTorso = Instance.new("Part")
cTorso.Parent = model
cTorso.Size = Vector3.new(2, 2, 1)
cTorso.Name = "Torso"

--Left Arm
local cLArm = Instance.new("Part")
cLArm.Parent = model
cLArm.Size = Vector3.new(1, 2, 1)
cLArm.Name = "Left Arm"

--Right Arm
local cRArm = Instance.new("Part")
cRArm.Parent = model
cRArm.Size = Vector3.new(1, 2, 1)
cRArm.Name = "Right Arm"

--Left Leg
local cLLeg = Instance.new("Part")
cLLeg.Parent = model
cLLeg.Size = Vector3.new(1, 2, 1)
cLLeg.Name = "Left Leg"

--Right Leg
local cRLeg = Instance.new("Part")
cRLeg.Parent = model
cRLeg.Size = Vector3.new(1, 2, 1)
cRLeg.Name = "Right Leg"

--HumanoidRootPart
local cHRP = Instance.new("Part")
cHRP.Parent = model
cHRP.Size = Vector3.new(2, 2, 1)
cHRP.Name = "HumanoidRootPart"
cHRP.Transparency = 1
cHRP.CanCollide = false

--Transparency
for i,v in pairs(model:GetChildren()) do
    if v:IsA("Part") and v.Name ~= "HumanoidRootPart" then
        v.Transparency = 1--0.5
    end
end

--Joints--
--Right Shoulder
local rShoulder = Instance.new("Motor6D")
rShoulder.Parent = cTorso
rShoulder.Part0 = cTorso
rShoulder.Part1 = cRArm
rShoulder.Name = "Right Shoulder"
rShoulder.C0 = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
rShoulder.C1 = CFrame.new(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)

--Left Shoulder
local lShoulder = Instance.new("Motor6D")
lShoulder.Parent = cTorso
lShoulder.Part0 = cTorso
lShoulder.Part1 = cLArm
lShoulder.Name = "Left Shoulder"
lShoulder.C0 = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
lShoulder.C1 = CFrame.new(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)

--Right Hip
local rHip = Instance.new("Motor6D")
rHip.Parent = cTorso
rHip.Part0 = cTorso
rHip.Part1 = cRLeg
rHip.Name = "Right Hip"
rHip.C0 = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
rHip.C1 = CFrame.new(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)

--Left Hip
local lHip = Instance.new("Motor6D")
lHip.Parent = cTorso
lHip.Part0 = cTorso
lHip.Part1 = cLLeg
lHip.Name = "Left Hip"
lHip.C0 = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
lHip.C1 = CFrame.new(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)

--Neck
local neck = Instance.new("Motor6D")
neck.Parent = cTorso
neck.Part0 = cTorso
neck.Part1 = cHead
neck.Name = "Neck"
neck.C0 = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
neck.C1 = CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)

--RootJoint
local rootJoint = Instance.new("Motor6D")
rootJoint.Parent = cHRP
rootJoint.Part0 = cHRP
rootJoint.Part1 = cTorso
rootJoint.Name = "RootJoint"
rootJoint.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
rootJoint.C1 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)

--Humanoid--
local cHumanoid = Instance.new("Humanoid")
cHumanoid.Parent = model
cHumanoid.DisplayDistanceType = "None"

--Head Mesh--
local headMesh = Instance.new("SpecialMesh")
headMesh.Parent = cHead
headMesh.Scale = Vector3.new(1.25, 1.25, 1.25)

local reanimation = model

--Creating Attachments
CreateAttachment(cHead, Vector3.new(0,0.60000002384186,0), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "HairAttachment")
CreateAttachment(cHead, Vector3.new(0,0.60000002384186,0), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "HatAttachment")
CreateAttachment(cHead, Vector3.new(0,0,-0.60000002384186), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "FaceFrontAttachment")
CreateAttachment(cHead, Vector3.new(0,0,0), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "FaceCenterAttachment")
CreateAttachment(cTorso, Vector3.new(0,1,0), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "NeckAttachment")
CreateAttachment(cTorso, Vector3.new(0,0,-0.5), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "BodyFrontAttachment")
CreateAttachment(cTorso, Vector3.new(0,0,0.5), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "BodyBackAttachment")
CreateAttachment(cTorso, Vector3.new(-1,1,0), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "LeftCollarAttachment")
CreateAttachment(cTorso, Vector3.new(1,1,0), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "RightCollarAttachment")
CreateAttachment(cTorso, Vector3.new(0,-1,-0.5), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "WaistFrontAttachment")
CreateAttachment(cTorso, Vector3.new(0,-1,0), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "WaistCenterAttachment")
CreateAttachment(cTorso, Vector3.new(0,-1,0.5), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "WaistBackAttachment")
CreateAttachment(cLArm, Vector3.new(0,1,0), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "LeftShoulderAttachment")
CreateAttachment(cLArm, Vector3.new(0,-1,0), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "LeftGripAttachment")
CreateAttachment(cRArm, Vector3.new(0,1,0), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "RightShoulderAttachment")
CreateAttachment(cRArm, Vector3.new(0,-1,0), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "RightGripAttachment")
CreateAttachment(cLLeg, Vector3.new(0,-1,0), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "LeftFootAttachment")
CreateAttachment(cRLeg, Vector3.new(0,-1,0), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "RightFootAttachment")
CreateAttachment(cHRP, Vector3.new(0,0,0), Vector3.new(-0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0), "RootAttachment")

--Cloning Hats (For Netless)
for i,v in pairs(character1:GetChildren()) do
    if v:IsA("Accessory") then
        local clone = v:Clone()
        local weld = v.Handle:FindFirstChildWhichIsA("Weld")
        local weldPart1 = weld.Part1
        local newWeld = Instance.new("Weld")
	newWeld.Parent = clone.Handle
        local CFrame0 = v.Handle.AccessoryWeld.C0
        local CFrame1 = v.Handle.AccessoryWeld.C1
        
        clone.Handle:FindFirstChild("AccessoryWeld"):Destroy()
        clone.Parent = reanimation
        newWeld.Name = "AccessoryWeld"
        newWeld.C0 = CFrame0
        newWeld.C1 = CFrame1
        newWeld.Part0 = clone.Handle
        newWeld.Part1 = character1:FindFirstChild(weldPart1.Name)
        clone.Handle.Transparency = 1
    end
end

cHRP.CFrame = hrp.CFrame

-- CLOVR - FE FULL-BODY VR SCRIPT

-- April 21st Update - TOOL HOLDING ADDED

-- | made by 0866 and Abacaxl
-- | tysm unverified

--RagdollEnabled is set to true, DON'T set it to false or CLOVR won't work. Feel free to change the other settings though. -Abacaxl

--|| Settings:
local StudsOffset = 0 -- Character height (negative if you're too high)
local Smoothness = .5 -- Character interpolation (0.1 - 1 = smooth - rigid)
local AnchorCharacter = true -- Prevent physics from causing inconsistencies
local HideCharacter = false -- Hide character on a platform
local NoCollision = false-- Disable player collision
local ChatEnabled = true -- See chat on your left hand in-game
local ChatLocalRange = 75 -- Local chat range
local ViewportEnabled = true -- View nearby players in a frame
local ViewportRange = 30 -- Maximum distance players are updated
local RagdollEnabled = true -- Use your character instead of hats (NetworkOwner vulnerability)
local RagdollHeadMovement = true -- Move your head separately from your body (+9 second wait)
local AutoRun = false -- Run script on respawn
local AutoRespawn = true -- Kill your real body when your virtual body dies
local WearAllAccessories = true -- Use all leftover hats for the head
local AccurateHandPosition = true -- Move your Roblox hands according to your real hands
local AccessorySettings = {
    LeftArm = "",
    RightArm = "",
    LeftLeg = "",
    RightLeg = "",
    Torso = "",
    Head = true,
    BlockArms = true,
    BlockLegs = true,
    BlockTorso = true,
    LimbOffset = CFrame.Angles(math.rad(90), 0, 0)
}
local FootPlacementSettings = {
    RightOffset = Vector3.new(.5, 0, 0),
    LeftOffset = Vector3.new(-.5, 0, 0)
}
--|| Script:
local Script = nil
Script = function()
    --[[
 Variables
--]]
    local Client = Players.LocalPlayer
    local Character = Client.Character or Client.CharacterAdded:Wait()
    local WeldBase = Character:WaitForChild("HumanoidRootPart")
    local ArmBase = Character:FindFirstChild("RightHand") or Character:FindFirstChild("Right Arm") or WeldBase
    local Backpack = Client:WaitForChild("Backpack")
    local Mouse = Client:GetMouse()
    local Camera = workspace.CurrentCamera
    local VRService = game:GetService("VRService")
    local VRReady = VRService.VREnabled
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local HttpService = game:GetService("HttpService")
    local StarterGui = game:GetService("StarterGui")
    local HeadAccessories = {}
    local UsedAccessories = {}
    local Pointer = false
    local Point1 = false
    local Point2 = false
    local VirtualRig = game:GetObjects("rbxassetid://4468539481")[1]
    local VirtualBody = game:GetObjects("rbxassetid://4464983829")[1]
    local Anchor = Instance.new("Part")
    Anchor.Anchored = true
    Anchor.Transparency = 1
    Anchor.CanCollide = false
    Anchor.Parent = workspace
    --[[
    if RagdollEnabled then
        local NetworkAccess =
            coroutine.create(
            function()
                settings().Physics.AllowSleep = false
                while true do
                    game:GetService("RunService").RenderStepped:Wait()
                    for _, Players in next, game:GetService("Players"):GetChildren() do
                        if Players ~= game:GetService("Players").LocalPlayer then
                            Players.MaximumSimulationRadius = 0.1
                            Players.SimulationRadius = 0
                        end
                    end
                    game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge, math.huge)
                    game:GetService("Players").LocalPlayer.SimulationRadius = math.huge * math.huge
                end
            end
        )
        coroutine.resume(NetworkAccess)
    end
    ]]
    StarterGui:SetCore("VRLaserPointerMode", 3)
    --[[
 Character Protection
--]]
    local CharacterCFrame = WeldBase.CFrame
    if not RagdollEnabled then
        Character:FindFirstChild("Humanoid").AnimationPlayed:Connect(
            function(Animation)
                Animation:Stop()
            end
        )
        for _, Track in next, Character:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
            Track:Stop()
        end
        if HideCharacter then
            local Platform = Instance.new("Part")
            Platform.Anchored = true
            Platform.Size = Vector3.new(100, 5, 100)
            Platform.CFrame = CFrame.new(0, 10000, 0)
            Platform.Transparency = 1
            Platform.Parent = workspace
            Character:MoveTo(Platform.Position + Vector3.new(0, 5, 0))
            wait(.5)
        end
        if AnchorCharacter then
            for _, Part in pairs(Character:GetChildren()) do
                if Part:IsA("BasePart") then
                    Part.Anchored = true
                end
            end
        end
    end
    --[[
 Functions
--]]
    function Tween(Object, Style, Direction, Time, Goal)
        local tweenInfo = TweenInfo.new(Time, Enum.EasingStyle[Style], Enum.EasingDirection[Direction])
        local tween = game:GetService("TweenService"):Create(Object, tweenInfo, Goal)
        tween.Completed:Connect(
            function()
                tween:Destroy()
            end
        )
        tween:Play()
        return tween
    end
    local function GetMotorForLimb(Limb)
        for _, Motor in next, Character:GetDescendants() do
            if Motor:IsA("Motor6D") and Motor.Part1 == Limb then
                return Motor
            end
        end
    end
    local function CreateAlignment(Limb, Part0)
        local Attachment0 = Instance.new("Attachment")
	Attachment0.Parent = Part0 or Anchor
        local Attachment1 = Instance.new("Attachment")
	Attachment1.Parent = Limb
        local Orientation = Instance.new("AlignOrientation")
        local Position = Instance.new("AlignPosition")
        Orientation.Attachment0 = Attachment1
        Orientation.Attachment1 = Attachment0
        Orientation.RigidityEnabled = false
        Orientation.MaxTorque = 20000
        Orientation.Responsiveness = 40
        Orientation.Parent = reanimation["HumanoidRootPart"]
        
        Orientation.Name = Limb.Name.."'s AlignRot"
        Orientation.MaxAngularVelocity = 100
        
        Position.Attachment0 = Attachment1
        Position.Attachment1 = Attachment0
        Position.RigidityEnabled = false
        Position.MaxForce = 40000
        Position.Responsiveness = 40
        Position.Parent = reanimation["HumanoidRootPart"]
        
        Position.Name = Limb.Name.."'s AlignPos"
        Position.MaxVelocity = 100
        
        Limb.Massless = false
        local Motor = GetMotorForLimb(Limb)
        if Motor then
            Motor:Destroy()
        end
        return function(CF, Local)
            if Local then
                Attachment0.CFrame = CF
            else
                Attachment0.WorldCFrame = CF
            end
        end
    end
    local function GetExtraTool()
        for _, Tool in next, Character:GetChildren() do
            if Tool:IsA("Tool") and not Tool.Name:match("LIMB_TOOL") then
                return Tool
            end
        end
    end
    local function GetGripForHandle(Handle)
        for _, Weld in next, Character:GetDescendants() do
            if Weld:IsA("Weld") and (Weld.Part0 == Handle or Weld.Part1 == Handle) then
                return Weld
            end
        end
        wait(.2)
        for _, Weld in next, Character:GetDescendants() do
            if Weld:IsA("Weld") and (Weld.Part0 == Handle or Weld.Part1 == Handle) then
                return Weld
            end
        end
    end
    local function CreateRightGrip(Handle)
        local RightGrip = Instance.new("Weld")
        RightGrip.Name = "RightGrip"
        RightGrip.Part1 = Handle
        RightGrip.Part0 = WeldBase
        RightGrip.Parent = WeldBase
        return RightGrip
    end
    local function CreateAccessory(Accessory, DeleteMeshes)
        if not Accessory then
            return
        end
        local HatAttachment = Accessory.Handle:FindFirstChildWhichIsA("Attachment")
        local HeadAttachment = VirtualRig:FindFirstChild(HatAttachment.Name, true)
        local BasePart = HeadAttachment.Parent
        local HatAtt = HatAttachment.CFrame
        local HeadAtt = HeadAttachment.CFrame
        if DeleteMeshes then
            if Accessory.Handle:FindFirstChild("Mesh") then
                Accessory.Handle.Mesh:Destroy()
            end
        end
        wait()
        local Handle = Accessory:WaitForChild("Handle")
        if Handle:FindFirstChildWhichIsA("Weld", true) then
            Handle:FindFirstChildWhichIsA("Weld", true):Destroy()
            Handle:BreakJoints()
        else
            Handle:BreakJoints()
        end
        Handle.Massless = true
        Handle.Transparency = 0.5
        UsedAccessories[Accessory] = true
        local RightGrip = CreateRightGrip(Handle)
        wait()
        for _, Object in pairs(Handle:GetDescendants()) do
            if not Object:IsA("BasePart") then
                pcall(
                    function()
                        Object.Transparency = 1
                    end
                )
                pcall(
                    function()
                        Object.Enabled = false
                    end
                )
            end
        end
        return Handle, RightGrip, HatAtt, HeadAtt, BasePart
    end
    local function GetHeadAccessories()
        for _, Accessory in next, Character:GetChildren() do
            if Accessory:IsA("Accessory") and not UsedAccessories[Accessory] then
                local Handle, RightGrip, HatAtt, HeadAtt, BasePart = CreateAccessory(Accessory)
                table.insert(HeadAccessories, {Handle, RightGrip, HatAtt, HeadAtt, BasePart})
                do
                    Handle.Transparency = 1
                end
                if not WearAllAccessories then
                    break
                end
            end
        end
    end
    --[[
 VR Replication Setup
--]]
    if not RagdollEnabled then
        LeftHandle, LeftHandGrip =
            CreateAccessory(Character:FindFirstChild(AccessorySettings.LeftArm), AccessorySettings.BlockArms)
        RightHandle, RightHandGrip =
            CreateAccessory(Character:FindFirstChild(AccessorySettings.RightArm), AccessorySettings.BlockArms)
        LeftHipHandle, LeftLegGrip =
            CreateAccessory(Character:FindFirstChild(AccessorySettings.LeftLeg), AccessorySettings.BlockLegs)
        RightHipHandle, RightLegGrip =
            CreateAccessory(Character:FindFirstChild(AccessorySettings.RightLeg), AccessorySettings.BlockLegs)
        TorsoHandle, TorsoGrip =
            CreateAccessory(Character:FindFirstChild(AccessorySettings.Torso), AccessorySettings.BlockTorso)
        GetHeadAccessories()
    elseif RagdollEnabled then
        if RagdollHeadMovement then
            Permadeath()
            MoveHead = CreateAlignment(reanimation["Head"])
        end
        MoveRightArm = CreateAlignment(reanimation["Right Arm"])
        MoveLeftArm = CreateAlignment(reanimation["Left Arm"])
        MoveRightLeg = CreateAlignment(reanimation["Right Leg"])
        MoveLeftLeg = CreateAlignment(reanimation["Left Leg"])
        MoveTorso = CreateAlignment(reanimation["Torso"])
        MoveRoot = CreateAlignment(reanimation["HumanoidRootPart"])
        --
        if RagdollHeadMovement then
            for _, Accessory in next, reanimation:GetChildren() do
                if Accessory:IsA("Accessory") and Accessory:FindFirstChild("Handle") then
                    local Attachment1 = Accessory.Handle:FindFirstChildWhichIsA("Attachment")
                    local Attachment0 = reanimation:FindFirstChild(tostring(Attachment1), true)
                    local Orientation = Instance.new("AlignOrientation")
                    local Position = Instance.new("AlignPosition")
                    
                    Orientation.Attachment0 = Attachment1
                    Orientation.Attachment1 = Attachment0
                    Orientation.RigidityEnabled = false
                    Orientation.ReactionTorqueEnabled = true
                    Orientation.MaxTorque = 20000
                    Orientation.Responsiveness = 40
                    Orientation.Parent = reanimation["Head"]
                    
                    Position.Attachment0 = Attachment1
                    Position.Attachment1 = Attachment0
                    Position.RigidityEnabled = false
                    Position.ReactionForceEnabled = true
                    Position.MaxForce = 40000
                    Position.Responsiveness = 40
                    Position.Parent = reanimation["Head"]
                end
            end
        end
        
    end
    --[[
 Movement
--]]
    VirtualRig.Name = "VirtualRig"
    VirtualRig.RightFoot.BodyPosition.Position = CharacterCFrame.p
    VirtualRig.LeftFoot.BodyPosition.Position = CharacterCFrame.p
    VirtualRig.Parent = workspace
    VirtualRig:SetPrimaryPartCFrame(CharacterCFrame)
    VirtualRig:FindFirstChildOfClass("Humanoid").Health = 0
    --VirtualRig:FindFirstChild("HumanoidRootPart").CFrame = character1.HumanoidRootPart.CFrame
    VirtualRig:BreakJoints()
    for i,v in pairs(VirtualRig:GetChildren()) do
        if v:IsA("BasePart") then
            v.CFrame = character1.HumanoidRootPart.CFrame
        end
    end
    --
    VirtualBody.Parent = workspace
    VirtualBody.Name = "VirtualBody"
    VirtualBody:FindFirstChildOfClass("Humanoid").WalkSpeed = 8
    VirtualBody:FindFirstChildOfClass("Humanoid").CameraOffset = Vector3.new(0, StudsOffset, 0)
    VirtualBody:SetPrimaryPartCFrame(CharacterCFrame)
    VirtualBody:FindFirstChildOfClass("Humanoid").Died:Connect(
        function()
            if AutoRespawn then
                Character:BreakJoints()
                if RagdollHeadMovement and RagdollEnabled then
                    --Network:Unclaim()
                    Respawn()
                end
            end
        end
    )
    --
    Camera.CameraSubject = VirtualBody:FindFirstChildOfClass("Humanoid")
    Character:FindFirstChildOfClass("Humanoid").WalkSpeed = 0
    Character:FindFirstChildOfClass("Humanoid").JumpPower = 1
    for _, Part in next, VirtualBody:GetChildren() do
        if Part:IsA("BasePart") then
            Part.Transparency = 1
        end
    end
    for _, Part in next, VirtualRig:GetChildren() do
        if Part:IsA("BasePart") then
            Part.Transparency = 1
        end
    end
    if not VRReady then
        VirtualRig.RightUpperArm.ShoulderConstraint.RigidityEnabled = true
        VirtualRig.LeftUpperArm.ShoulderConstraint.RigidityEnabled = true
    end
    local OnMoving =
        RunService.Stepped:Connect(
        function()
            local Direction = Character:FindFirstChildOfClass("Humanoid").MoveDirection
            local Start = VirtualBody.HumanoidRootPart.Position
            local Point = Start + Direction * 6
            VirtualBody:FindFirstChildOfClass("Humanoid"):MoveTo(Point)
        end
    )
    Character:FindFirstChildOfClass("Humanoid").Jumping:Connect(
        function()
            VirtualBody:FindFirstChildOfClass("Humanoid").Jump = true
        end
    )
    UserInputService.JumpRequest:Connect(
        function()
            VirtualBody:FindFirstChildOfClass("Humanoid").Jump = true
        end
    )
    --[[
 VR Replication
--]]
    if RagdollEnabled then
        for _, Part in pairs(Character:GetDescendants()) do
            if Part:IsA("BasePart") and Part.Name == "Handle" and Part.Parent:IsA("Accessory") then
                Part.LocalTransparencyModifier = 1
            elseif Part:IsA("BasePart") and Part.Transparency < 0.5 and Part.Name ~= "Head" then
                Part.LocalTransparencyModifier = bodyTransparency
            elseif Part:IsA("BasePart") and Part.Name == "Head" then
                Part.LocalTransparencyModifier = 1
            end
            if not Part:IsA("BasePart") and not Part:IsA("AlignPosition") and not Part:IsA("AlignOrientation") then
                pcall(
                    function()
                        Part.Transparency = 1
                    end
                )
                pcall(
                    function()
                        Part.Enabled = false
                    end
                )
            end
        end
    end
    local FootUpdateDebounce = tick()
    local function FloorRay(Part, Distance)
        local Position = Part.CFrame.p
        local Target = Position - Vector3.new(0, Distance, 0)
        local Line = Ray.new(Position, (Target - Position).Unit * Distance)
        local FloorPart, FloorPosition, FloorNormal =
            workspace:FindPartOnRayWithIgnoreList(Line, {VirtualRig, VirtualBody, Character})
        if FloorPart then
            return FloorPart, FloorPosition, FloorNormal, (FloorPosition - Position).Magnitude
        else
            return nil, Target, Vector3.new(), Distance
        end
    end
    local function Flatten(CF)
        local X, Y, Z = CF.X, CF.Y, CF.Z
        local LX, LZ = CF.lookVector.X, CF.lookVector.Z
        return CFrame.new(X, Y, Z) * CFrame.Angles(0, math.atan2(LX, LZ), 0)
    end
    local FootTurn = 1
    local function FootReady(Foot, Target)
        local MaxDist
        if Character:FindFirstChildOfClass("Humanoid").MoveDirection.Magnitude > 0 then
            MaxDist = .5
        else
            MaxDist = 1
        end
        local PastThreshold = (Foot.Position - Target.Position).Magnitude > MaxDist
        local PastTick = tick() - FootUpdateDebounce >= 2
        if PastThreshold or PastTick then
            FootUpdateDebounce = tick()
        end
        return PastThreshold or PastTick
    end
    local function FootYield()
        local RightFooting = VirtualRig.RightFoot.BodyPosition
        local LeftFooting = VirtualRig.LeftFoot.BodyPosition
        local LowerTorso = VirtualRig.LowerTorso
        local Yield = tick()
        repeat
            RunService.Stepped:Wait()
            if
                (LowerTorso.Position - RightFooting.Position).Y > 4 or
                    (LowerTorso.Position - LeftFooting.Position).Y > 4 or
                    ((LowerTorso.Position - RightFooting.Position) * Vector3.new(1, 0, 1)).Magnitude > 4 or
                    ((LowerTorso.Position - LeftFooting.Position) * Vector3.new(1, 0, 1)).Magnitude > 4
             then
                break
            end
        until tick() - Yield >= .17
    end
    local function UpdateFooting()
        if not VirtualRig:FindFirstChild("LowerTorso") then
            wait()
            return
        end
        local Floor, FloorPosition, FloorNormal, Dist = FloorRay(VirtualRig.LowerTorso, 3)
        Dist = math.clamp(Dist, 0, 5)
        local FootTarget =
            VirtualRig.LowerTorso.CFrame * CFrame.new(FootPlacementSettings.RightOffset) - Vector3.new(0, Dist, 0) +
            Character:FindFirstChildOfClass("Humanoid").MoveDirection * (VirtualBody:FindFirstChildOfClass("Humanoid").WalkSpeed / 8) * 2
        if FootReady(VirtualRig.RightFoot, FootTarget) then
            VirtualRig.RightFoot.BodyPosition.Position = FootTarget.p
            VirtualRig.RightFoot.BodyGyro.CFrame = Flatten(VirtualRig.LowerTorso.CFrame)
        end
        FootYield()
        local FootTarget =
            VirtualRig.LowerTorso.CFrame * CFrame.new(FootPlacementSettings.LeftOffset) - Vector3.new(0, Dist, 0) +
            Character:FindFirstChildOfClass("Humanoid").MoveDirection * (VirtualBody:FindFirstChildOfClass("Humanoid").WalkSpeed / 8) * 2
        if FootReady(VirtualRig.LeftFoot, FootTarget) then
            VirtualRig.LeftFoot.BodyPosition.Position = FootTarget.p
            VirtualRig.LeftFoot.BodyGyro.CFrame = Flatten(VirtualRig.LowerTorso.CFrame)
        end
    end
    local function UpdateTorsoPosition()
        if not RagdollEnabled then
            if TorsoHandle then
                local Positioning = VirtualRig.UpperTorso.CFrame
                if not TorsoGrip or not TorsoGrip.Parent then
                    TorsoGrip = CreateRightGrip(TorsoHandle)
                end
                local Parent = TorsoGrip.Parent
                TorsoGrip.C1 = CFrame.new()
                TorsoGrip.C0 =
                    TorsoGrip.C0:Lerp(
                    WeldBase.CFrame:ToObjectSpace(Positioning * CFrame.new(0, -0.25, 0) * AccessorySettings.LimbOffset),
                    Smoothness
                )
                TorsoGrip.Parent = nil
                TorsoGrip.Parent = Parent
            end
        else
            local Positioning = VirtualRig.UpperTorso.CFrame
            MoveTorso(Positioning * CFrame.new(0, -0.25, 0))
            MoveRoot(Positioning * CFrame.new(0, -0.25, 0))
        end
    end
    local function UpdateLegPosition()
        if not RagdollEnabled then
            if RightHipHandle then
                local Positioning =
                    VirtualRig.RightLowerLeg.CFrame:Lerp(VirtualRig.RightFoot.CFrame, 0.5) + Vector3.new(0, 0.5, 0)
                if not RightHipHandle or not RightHipHandle.Parent then
                    RightLegGrip = CreateRightGrip(RightHipHandle)
                end
                local Parent = RightLegGrip.Parent
                RightLegGrip.C1 = CFrame.new()
                RightLegGrip.C0 =
                    RightLegGrip.C0:Lerp(
                    WeldBase.CFrame:ToObjectSpace(Positioning * AccessorySettings.LimbOffset),
                    Smoothness
                )
                RightLegGrip.Parent = nil
                RightLegGrip.Parent = Parent
            end
            if LeftHipHandle then
                local Positioning =
                    VirtualRig.LeftLowerLeg.CFrame:Lerp(VirtualRig.LeftFoot.CFrame, 0.5) + Vector3.new(0, 0.5, 0)
                if not LeftLegGrip or not LeftLegGrip.Parent then
                    LeftLegGrip = CreateRightGrip(LeftHipHandle)
                end
                local Parent = LeftLegGrip.Parent
                LeftLegGrip.C1 = CFrame.new()
                LeftLegGrip.C0 =
                    LeftLegGrip.C0:Lerp(
                    WeldBase.CFrame:ToObjectSpace(Positioning * AccessorySettings.LimbOffset),
                    Smoothness
                )
                LeftLegGrip.Parent = nil
                LeftLegGrip.Parent = Parent
            end
        else
            do
                local Positioning =
                    VirtualRig.RightLowerLeg.CFrame:Lerp(VirtualRig.RightFoot.CFrame, 0.5) *
                    CFrame.Angles(0, math.rad(180), 0) +
                    Vector3.new(0, 0.5, 0)
                MoveRightLeg(Positioning)
            end
            do
                local Positioning =
                    VirtualRig.LeftLowerLeg.CFrame:Lerp(VirtualRig.LeftFoot.CFrame, 0.5) *
                    CFrame.Angles(0, math.rad(180), 0) +
                    Vector3.new(0, 0.5, 0)
                MoveLeftLeg(Positioning)
            end
        end
    end
    local function OnUserCFrameChanged(UserCFrame, Positioning, IgnoreTorso)
        local Positioning = Camera.CFrame * Positioning
        if not IgnoreTorso then
            UpdateTorsoPosition()
            UpdateLegPosition()
        end
        if not RagdollEnabled then
            if UserCFrame == Enum.UserCFrame.Head and AccessorySettings.Head then
                for _, Table in next, HeadAccessories do
                    local Handle, RightGrip, HatAtt, HeadAtt, BasePart = unpack(Table)
                    local LocalPositioning = Positioning
                    if not RightGrip or not RightGrip.Parent then
                        RightGrip = CreateRightGrip(Handle)
                        Table[2] = RightGrip
                    end
                    local Parent = RightGrip.Parent
                    if BasePart then
                        LocalPositioning = BasePart.CFrame * HeadAtt
                    end
                    RightGrip.C1 = HatAtt
                    RightGrip.C0 = RightGrip.C0:Lerp(WeldBase.CFrame:ToObjectSpace(LocalPositioning), Smoothness)
                    RightGrip.Parent = nil
                    RightGrip.Parent = Parent
                end
            elseif RightHandle and UserCFrame == Enum.UserCFrame.RightHand and AccessorySettings.RightArm then
                local HandPosition = Positioning
                local LocalPositioning = Positioning
                if not RightHandGrip or not RightHandGrip.Parent then
                    RightHandGrip = CreateRightGrip(RightHandle)
                end
                if AccurateHandPosition then
                    HandPosition = HandPosition * CFrame.new(0, 0, 1)
                end
                if not VRReady then
                    local HeadRotation = Camera.CFrame - Camera.CFrame.p
                    HandPosition =
                        VirtualRig.RightUpperArm.CFrame:Lerp(VirtualRig.RightLowerArm.CFrame, 0.5) *
                        AccessorySettings.LimbOffset
                    --LocalPositioning = (HeadRotation + (HandPosition * CFrame.new(0, 0, 1)).p) * CFrame.Angles(math.rad(-45), 0, 0)
                    LocalPositioning = HandPosition * CFrame.new(0, 0, 1) * CFrame.Angles(math.rad(-180), 0, 0)
                    if Point2 then
                        VirtualRig.RightUpperArm.Aim.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                        VirtualRig.RightUpperArm.Aim.CFrame = Camera.CFrame * AccessorySettings.LimbOffset
                    elseif VirtualRig.RightUpperArm.Aim.MaxTorque ~= Vector3.new(0, 0, 0) then
                        VirtualRig.RightUpperArm.Aim.MaxTorque = Vector3.new(0, 0, 0)
                    end
                elseif AccurateHandPosition then
                    LocalPositioning = HandPosition
                end
                local Parent = RightHandGrip.Parent
                RightHandGrip.C1 = CFrame.new()
                RightHandGrip.C0 = RightHandGrip.C0:Lerp(WeldBase.CFrame:ToObjectSpace(HandPosition), Smoothness)
                RightHandGrip.Parent = nil
                RightHandGrip.Parent = Parent
                --
                local EquippedTool = GetExtraTool()
                if EquippedTool and EquippedTool:FindFirstChild("Handle") then
                    local EquippedGrip = GetGripForHandle(EquippedTool.Handle)
                    local Parent = EquippedGrip.Parent
                    local ArmBaseCFrame = ArmBase.CFrame
                    if ArmBase.Name == "Right Arm" then
                        ArmBaseCFrame = ArmBaseCFrame
                    end
                    EquippedGrip.C1 = EquippedTool.Grip
                    EquippedGrip.C0 = EquippedGrip.C0:Lerp(ArmBaseCFrame:ToObjectSpace(LocalPositioning), Smoothness)
                    EquippedGrip.Parent = nil
                    EquippedGrip.Parent = Parent
                end
            elseif LeftHandle and UserCFrame == Enum.UserCFrame.LeftHand and AccessorySettings.LeftArm then
                local HandPosition = Positioning
                if not LeftHandGrip or not LeftHandGrip.Parent then
                    LeftHandGrip = CreateRightGrip(LeftHandle)
                end
                if AccurateHandPosition then
                    HandPosition = HandPosition * CFrame.new(0, 0, 1)
                end
                if not VRReady then
                    HandPosition =
                        VirtualRig.LeftUpperArm.CFrame:Lerp(VirtualRig.LeftLowerArm.CFrame, 0.5) *
                        AccessorySettings.LimbOffset
                    --warn("Setting HandPosition to hands")
                    if Point1 then
                        VirtualRig.LeftUpperArm.Aim.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                        VirtualRig.LeftUpperArm.Aim.CFrame = Camera.CFrame * AccessorySettings.LimbOffset
                    elseif VirtualRig.LeftUpperArm.Aim.MaxTorque ~= Vector3.new(0, 0, 0) then
                        VirtualRig.LeftUpperArm.Aim.MaxTorque = Vector3.new(0, 0, 0)
                    end
                end
                local Parent = LeftHandGrip.Parent
                LeftHandGrip.C1 = CFrame.new()
                LeftHandGrip.C0 = LeftHandGrip.C0:Lerp(WeldBase.CFrame:ToObjectSpace(HandPosition), Smoothness)
                LeftHandGrip.Parent = nil
                LeftHandGrip.Parent = Parent
            end
        end
        if RagdollEnabled then
            if UserCFrame == Enum.UserCFrame.Head and RagdollHeadMovement then
                MoveHead(Positioning)
            elseif UserCFrame == Enum.UserCFrame.RightHand then
                local Positioning = Positioning
                if not VRReady then
                    Positioning = VirtualRig.RightUpperArm.CFrame:Lerp(VirtualRig.RightLowerArm.CFrame, 0.5)
                elseif AccurateHandPosition then
                    Positioning = Positioning * CFrame.new(0, 0, 1)
                end
                if VRReady then
                    Positioning = Positioning * AccessorySettings.LimbOffset
                end
                MoveRightArm(Positioning)
                if Point2 then
                    VirtualRig.RightUpperArm.Aim.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                    VirtualRig.RightUpperArm.Aim.CFrame = Camera.CFrame * AccessorySettings.LimbOffset
                elseif VirtualRig.RightUpperArm.Aim.MaxTorque ~= Vector3.new(0, 0, 0) then
                    VirtualRig.RightUpperArm.Aim.MaxTorque = Vector3.new(0, 0, 0)
                end
            elseif UserCFrame == Enum.UserCFrame.LeftHand then
                local Positioning = Positioning
                if not VRReady then
                    Positioning = VirtualRig.LeftUpperArm.CFrame:Lerp(VirtualRig.LeftLowerArm.CFrame, 0.5)
                elseif AccurateHandPosition then
                    Positioning = Positioning * CFrame.new(0, 0, 1)
                end
                if VRReady then
                    Positioning = Positioning * AccessorySettings.LimbOffset
                end
                MoveLeftArm(Positioning)
                if Point1 then
                    VirtualRig.LeftUpperArm.Aim.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                    VirtualRig.LeftUpperArm.Aim.CFrame = Camera.CFrame * AccessorySettings.LimbOffset
                elseif VirtualRig.LeftUpperArm.Aim.MaxTorque ~= Vector3.new(0, 0, 0) then
                    VirtualRig.LeftUpperArm.Aim.MaxTorque = Vector3.new(0, 0, 0)
                end
            end
        end
        if UserCFrame == Enum.UserCFrame.Head then
            VirtualRig.Head.CFrame = Positioning
        elseif UserCFrame == Enum.UserCFrame.RightHand and VRReady then
            VirtualRig.RightHand.CFrame = Positioning
        elseif UserCFrame == Enum.UserCFrame.LeftHand and VRReady then
            VirtualRig.LeftHand.CFrame = Positioning
        end
        if not VRReady and VirtualRig.LeftHand.Anchored then
            VirtualRig.RightHand.Anchored = false
            VirtualRig.LeftHand.Anchored = false
        elseif VRReady and not VirtualRig.LeftHand.Anchored then
            VirtualRig.RightHand.Anchored = true
            VirtualRig.LeftHand.Anchored = true
        end
    end
    local CFrameChanged = VRService.UserCFrameChanged:Connect(OnUserCFrameChanged)
    local OnStepped =
        RunService.Stepped:Connect(
        function()
            for _, Part in pairs(VirtualRig:GetChildren()) do
                if Part:IsA("BasePart") then
                    Part.CanCollide = false
                end
            end
            if RagdollEnabled then
                for _, Part in pairs(Character:GetChildren()) do
                    if Part:IsA("BasePart") then
                        Part.CanCollide = false
                    end
                end
            end
            if NoCollision then
                for _, Player in pairs(Players:GetPlayers()) do
                    if Player ~= Client and Player.Character then
                        local Descendants = Player.Character:GetDescendants()
                        for i = 1, #Descendants do
                            local Part = Descendants[i]
                            if Part:IsA("BasePart") then
                                Part.CanCollide = false
                                Part.Velocity = Vector3.new()
                                Part.RotVelocity = Vector3.new()
                            end
                        end
                    end
                end
            end
        end
    )
    local OnRenderStepped =
        RunService.Stepped:Connect(
        function()
            Camera.CameraSubject = VirtualBody:FindFirstChildOfClass("Humanoid")
            if RagdollEnabled then
                Character.HumanoidRootPart.CFrame = VirtualRig.UpperTorso.CFrame
                --Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            end
            if not VRReady then
                OnUserCFrameChanged(Enum.UserCFrame.Head, CFrame.new(0, 0, 0))
                OnUserCFrameChanged(Enum.UserCFrame.RightHand, CFrame.new(0, 0, 0), true)
                OnUserCFrameChanged(Enum.UserCFrame.LeftHand, CFrame.new(0, 0, 0), true)
            end
        end
    )
    spawn(
        function()
            while Character and Character.Parent do
                FootYield()
                UpdateFooting()
            end
        end
    )
    --[[
 Non-VR Support + VR Mechanics
--]]
    local OnInput =
        UserInputService.InputBegan:Connect(
        function(Input, Processed)
            if not Processed then
                if Input.KeyCode == Enum.KeyCode.LeftControl or Input.KeyCode == Enum.KeyCode.ButtonL2 then
                    Tween(
                        VirtualBody:FindFirstChildOfClass("Humanoid"),
                        "Elastic",
                        "Out",
                        1,
                        {
                            CameraOffset = Vector3.new(0, StudsOffset - 1.5, 0)
                        }
                    )
                end
                if Input.KeyCode == Enum.KeyCode.X then
                    if RagdollEnabled and RagdollHeadMovement then
                        --Network:Unclaim()
                        Respawn()
                    end
                end
                if Input.KeyCode == Enum.KeyCode.C then
                    VirtualBody:MoveTo(Mouse.Hit.p)
                    VirtualRig:MoveTo(Mouse.Hit.p)
                end
            end
            if Input.KeyCode == Enum.KeyCode.LeftShift or Input.KeyCode == Enum.KeyCode.ButtonR2 then
                Tween(
                    VirtualBody:FindFirstChildOfClass("Humanoid"),
                    "Sine",
                    "Out",
                    1,
                    {
                        WalkSpeed = 16
                    }
                )
            end
            if not VRReady and Input.UserInputType == Enum.UserInputType.MouseButton1 then
                Point1 = true
            end
            if not VRReady and Input.UserInputType == Enum.UserInputType.MouseButton2 then
                Point2 = true
            end
            if VRReady and Input.KeyCode == Enum.KeyCode.ButtonY then
                Character:BreakJoints()
                if RagdollEnabled and RagdollHeadMovement then
                    --Network:Unclaim()
                    Respawn()
                end
            end
        end
    )
    local OnInputEnded =
        UserInputService.InputEnded:Connect(
        function(Input, Processed)
            if not Processed then
                if Input.KeyCode == Enum.KeyCode.LeftControl or Input.KeyCode == Enum.KeyCode.ButtonL2 then
                    Tween(
                        VirtualBody:FindFirstChildOfClass("Humanoid"),
                        "Elastic",
                        "Out",
                        1,
                        {
                            CameraOffset = Vector3.new(0, StudsOffset, 0)
                        }
                    )
                end
            end
            if Input.KeyCode == Enum.KeyCode.LeftShift or Input.KeyCode == Enum.KeyCode.ButtonR2 then
                Tween(
                    VirtualBody:FindFirstChildOfClass("Humanoid"),
                    "Sine",
                    "Out",
                    1,
                    {
                        WalkSpeed = 8
                    }
                )
            end
            if not VRReady and Input.UserInputType == Enum.UserInputType.MouseButton1 then
                Point1 = false
            end
            if not VRReady and Input.UserInputType == Enum.UserInputType.MouseButton2 then
                Point2 = false
            end
        end
    )
    --[[
 Proper Cleanup
--]]
    local OnReset
    OnReset =
        Client.CharacterAdded:Connect(
        function()
            OnReset:Disconnect()
            CFrameChanged:Disconnect()
            OnStepped:Disconnect()
            OnRenderStepped:Disconnect()
            OnMoving:Disconnect()
            OnInput:Disconnect()
            OnInputEnded:Disconnect()
            VirtualRig:Destroy()
            VirtualBody:Destroy()
            if RagdollEnabled then
                --Network:Unclaim()
            end
            if AutoRun then
                delay(
                    2,
                    function()
                        Script()
                    end
                )
            end
        end
    )
    if ChatEnabled then
        spawn(ChatHUDFunc)
    end
    if ViewportEnabled then
        spawn(ViewHUDFunc)
    end
    do
        --[[
 Functions
 --]]
        local Players = game:GetService("Players")
        local Client = Players.LocalPlayer
        local VRService = game:GetService("VRService")
        local VRReady = VRService.VREnabled
        local UserInputService = game:GetService("UserInputService")
        local RunService = game:GetService("RunService")
        local Camera = workspace.CurrentCamera
        --[[
 Code
 --]]
        if VRReady then
            local Pointer = game:GetObjects("rbxassetid://4476173280")[1]
            Pointer.Parent = workspace
            Pointer.Beam.Enabled = false
            Pointer.Target.ParticleEmitter.Enabled = false
            local RenderStepped =
                RunService.RenderStepped:Connect(
                function()
                    if Pointer.Beam.Enabled then
                        local RightHand = Camera.CFrame * VRService:GetUserCFrame(Enum.UserCFrame.RightHand)
                        local Target = RightHand * CFrame.new(0, 0, -10)
                        local Line = Ray.new(RightHand.p, (Target.p - RightHand.p).Unit * 128)
                        local Part, Position =
                            workspace:FindPartOnRayWithIgnoreList(Line, {VirtualRig, VirtualBody, Character, Pointer})
                        local Distance = (Position - RightHand.p).Magnitude
                        Pointer.Target.Position = Vector3.new(0, 0, -Distance)
                        Pointer.CFrame = RightHand
                    end
                end
            )
            local Input =
                UserInputService.InputBegan:Connect(
                function(Input)
                    if Input.KeyCode == Enum.KeyCode.ButtonB then
                        Pointer.Beam.Enabled = not Pointer.Beam.Enabled
                        Pointer.Target.ParticleEmitter.Enabled = not Pointer.Target.ParticleEmitter.Enabled
                    end
                end
            )
            --
            local CharacterAdded
            CharacterAdded =
                Client.CharacterAdded:Connect(
                function()
                    RenderStepped:Disconnect()
                    Input:Disconnect()
                    CharacterAdded:Disconnect()
                    Pointer:Destroy()
                    Pointer = nil
                end
            )
        else
            return
        end
    end
end
Permadeath = function()
    local ch = Players.LocalPlayer.Character
    local prt = Instance.new("Model")
	prt.Parent = workspace
    local z1 = Instance.new("Part")
	z1.Parent = prt
    z1.Name = "Torso"
    z1.CanCollide = false
    z1.Anchored = true
    local z2 = Instance.new("Part")
	z2.Parent = prt
    z2.Name = "Head"
    z2.Anchored = true
    z2.CanCollide = false
    local z3 = Instance.new("Humanoid")
	z3.Parent = prt
    z3.Name = "Humanoid"
    z1.Position = Vector3.new(0, 9999, 0)
    z2.Position = Vector3.new(0, 9991, 0)
    Players.LocalPlayer.Character = prt
    wait(Players.RespawnTime/2)
    -- warn("50%")
    Players.LocalPlayer.Character = ch
    wait(Players.RespawnTime/2 + 0.5)
    -- warn("100%")
end
Respawn = function()
    local ch = Players.LocalPlayer.Character
    local prt = Instance.new("Model")
	prt.Parent = workspace
    local z1 = Instance.new("Part")
	z1.Parent = prt
    z1.Name = "Torso"
    z1.CanCollide = false
    z1.Anchored = true
    local z2 = Instance.new("Part")
	z2.Parent = prt
    z2.Name = "Head"
    z2.Anchored = true
    z2.CanCollide = false
    local z3 = Instance.new("Humanoid")
	z3.Parent = prt
    z3.Name = "Humanoid"
    z1.Position = Vector3.new(0, 9999, 0)
    z2.Position = Vector3.new(0, 9991, 0)
    Players.LocalPlayer.Character = prt
    wait(Players.RespawnTime)
    Players.LocalPlayer.Character = ch
end
ChatHUDFunc = function()
    --[[
 Variables
 --]]
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local VRService = game:GetService("VRService")
    local VRReady = VRService.VREnabled
    local Players = game:GetService("Players")
    local Client = Players.LocalPlayer
    local ChatHUD = game:GetObjects("rbxassetid://4476067885")[1]
    local GlobalFrame = ChatHUD.GlobalFrame
    local Template = GlobalFrame.Template
    local LocalFrame = ChatHUD.LocalFrame
    local Global = ChatHUD.Global
    local Local = ChatHUD.Local
    local Camera = workspace.CurrentCamera
    Template.Parent = nil
    ChatHUD.Parent = game:GetService("CoreGui")
    --[[
 Code
 --]]
    local Highlight = Global.Frame.BackgroundColor3
    local Deselected = Local.Frame.BackgroundColor3
    local OpenGlobalTab = function()
        Global.Frame.BackgroundColor3 = Highlight
        Local.Frame.BackgroundColor3 = Deselected
        Global.Font = Enum.Font.SourceSansBold
        Local.Font = Enum.Font.SourceSans
        GlobalFrame.Visible = true
        LocalFrame.Visible = false
    end
    local OpenLocalTab = function()
        Global.Frame.BackgroundColor3 = Deselected
        Local.Frame.BackgroundColor3 = Highlight
        Global.Font = Enum.Font.SourceSans
        Local.Font = Enum.Font.SourceSansBold
        GlobalFrame.Visible = false
        LocalFrame.Visible = true
    end
    Global.MouseButton1Down:Connect(OpenGlobalTab)
    Local.MouseButton1Down:Connect(OpenLocalTab)
    Global.MouseButton1Click:Connect(OpenGlobalTab)
    Local.MouseButton1Click:Connect(OpenLocalTab)
    OpenLocalTab()
    --
    local function GetPlayerDistance(Sender)
        if Sender.Character and Sender.Character:FindFirstChild("Head") then
            return math.floor((Sender.Character.Head.Position - Camera:GetRenderCFrame().p).Magnitude + 0.5)
        end
    end
    local function NewGlobal(Message, Sender, Color)
        local Frame = Template:Clone()
        Frame.Text = ("[%s]: %s"):format(Sender.Name, Message)
        Frame.User.Text = ("[%s]:"):format(Sender.Name)
        Frame.User.TextColor3 = Color
        Frame.BackgroundColor3 = Color
        Frame.Parent = GlobalFrame
        delay(
            60,
            function()
                Frame:Destroy()
            end
        )
    end
    local function NewLocal(Message, Sender, Color, Dist)
        local Frame = Template:Clone()
        Frame.Text = ("(%s) [%s]: %s"):format(tostring(Dist), Sender.Name, Message)
        Frame.User.Text = ("(%s) [%s]:"):format(tostring(Dist), Sender.Name)
        Frame.User.TextColor3 = Color
        Frame.BackgroundColor3 = Color
        Frame.Parent = LocalFrame
        delay(
            60,
            function()
                Frame:Destroy()
            end
        )
    end
    local function OnNewChat(Message, Sender, Color)
        if not ChatHUD or not ChatHUD.Parent then
            return
        end
        NewGlobal(Message, Sender, Color)
        local Distance = GetPlayerDistance(Sender)
        if Distance and Distance <= ChatLocalRange then
            NewLocal(Message, Sender, Color, Distance)
        end
    end
    local function OnPlayerAdded(Player)
        if not ChatHUD or not ChatHUD.Parent then
            return
        end
        local Color = BrickColor.Random().Color
        Player.Chatted:Connect(
            function(Message)
                OnNewChat(Message, Player, Color)
            end
        )
    end
    Players.PlayerAdded:Connect(OnPlayerAdded)
    for _, Player in pairs(Players:GetPlayers()) do
        OnPlayerAdded(Player)
    end
    --
    local ChatPart = ChatHUD.Part
    ChatHUD.Adornee = ChatPart
    if VRReady then
        ChatHUD.Parent = game:GetService("CoreGui")
        ChatHUD.Enabled = true
        ChatHUD.AlwaysOnTop = true
        local OnInput =
            UserInputService.InputBegan:Connect(
            function(Input, Processed)
                if not Processed then
                    if Input.KeyCode == Enum.KeyCode.ButtonX then
                        ChatHUD.Enabled = not ChatHUD.Enabled
                    end
                end
            end
        )
        local RenderStepped =
            RunService.RenderStepped:Connect(
            function()
                local LeftHand = VRService:GetUserCFrame(Enum.UserCFrame.LeftHand)
                ChatPart.CFrame = Camera.CFrame * LeftHand
            end
        )
        local CharacterAdded
        CharacterAdded =
            Client.CharacterAdded:Connect(
            function()
                OnInput:Disconnect()
                RenderStepped:Disconnect()
                CharacterAdded:Disconnect()
                ChatHUD:Destroy()
                ChatHUD = nil
            end
        )
    end
    wait(9e9)
end
ViewHUDFunc = function()
    --[[
 Variables
 --]]
    local ViewportRange = ViewportRange or 32
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local VRService = game:GetService("VRService")
    local VRReady = VRService.VREnabled
    local Players = game:GetService("Players")
    local Client = Players.LocalPlayer
    local Mouse = Client:GetMouse()
    local Camera = workspace.CurrentCamera
    local CameraPort = Camera.CFrame
    local ViewHUD = script:FindFirstChild("ViewHUD") or game:GetObjects("rbxassetid://4480405425")[1]
    local Viewport = ViewHUD.Viewport
    local Viewcam = Instance.new("Camera")
    local ViewPart = ViewHUD.Part
    ViewHUD.Parent = game:GetService("CoreGui")
    Viewcam.Parent = Viewport
    Viewcam.CameraType = Enum.CameraType.Scriptable
    Viewport.CurrentCamera = Viewcam
    Viewport.BackgroundTransparency = 1
    --[[
 Code
 --]]
    local function Clone(Character)
        local Arc = Character.Archivable
        local Clone
        Character.Archivable = true
        Clone = Character:Clone()
        Character.Archivable = Arc
        return Clone
    end
    local function GetPart(Name, Parent, Descendants)
        for i = 1, #Descendants do
            local Part = Descendants[i]
            if Part.Name == Name and Part.Parent.Name == Parent then
                return Part
            end
        end
    end
    local function OnPlayerAdded(Player)
        if not ViewHUD or not ViewHUD.Parent then
            return
        end
        local function CharacterAdded(Character)
            if not ViewHUD or not ViewHUD.Parent then
                return
            end
            Character:WaitForChild("Head")
            Character:WaitForChild("Humanoid")
            wait(3)
            local FakeChar = Clone(Character)
            local Root = FakeChar:FindFirstChild("HumanoidRootPart") or FakeChar:FindFirstChild("Head")
            local RenderConnection
            local Descendants = FakeChar:GetDescendants()
            local RealDescendants = Character:GetDescendants()
            local Correspondents = {}
            FakeChar:FindFirstChildOfClass("Humanoid").DisplayDistanceType = "None"
            for i = 1, #Descendants do
                local Part = Descendants[i]
                local Real = Part:IsA("BasePart") and GetPart(Part.Name, Part.Parent.Name, RealDescendants)
                if Part:IsA("BasePart") and Real then
                    Part.Anchored = true
                    Part:BreakJoints()
                    if Part.Parent:IsA("Accessory") then
                        Part.Transparency = 0
                    end
                    table.insert(Correspondents, {Part, Real})
                end
            end
            RenderConnection =
                RunService.RenderStepped:Connect(
                function()
                    if not Character or not Character.Parent then
                        RenderConnection:Disconnect()
                        FakeChar:Destroy()
                        return
                    end
                    if
                        (Root and (Root.Position - Camera.CFrame.p).Magnitude <= ViewportRange) or Player == Client or
                            not Root
                     then
                        for i = 1, #Correspondents do
                            local Part, Real = unpack(Correspondents[i])
                            if Part and Real and Part.Parent and Real.Parent then
                                Part.CFrame = Real.CFrame
                            elseif Part.Parent and not Real.Parent then
                                Part:Destroy()
                            end
                        end
                    end
                end
            )
            FakeChar.Parent = Viewcam
        end
        Player.CharacterAdded:Connect(CharacterAdded)
        if Player.Character then
            spawn(
                function()
                    CharacterAdded(Player.Character)
                end
            )
        end
    end
    local PlayerAdded = Players.PlayerAdded:Connect(OnPlayerAdded)
    for _, Player in pairs(Players:GetPlayers()) do
        OnPlayerAdded(Player)
    end
    ViewPart.Size = Vector3.new()
    if VRReady then
        Viewport.Position = UDim2.new(.62, 0, .89, 0)
        Viewport.Size = UDim2.new(.3, 0, .3, 0)
        Viewport.AnchorPoint = Vector2.new(.5, 1)
    else
        Viewport.Size = UDim2.new(0.3, 0, 0.3, 0)
    end
    local RenderStepped =
        RunService.RenderStepped:Connect(
        function()
            local Render = Camera.CFrame
            local Scale = Camera.ViewportSize
            if VRReady then
                Render = Render * VRService:GetUserCFrame(Enum.UserCFrame.Head)
            end
            CameraPort = CFrame.new(Render.p + Vector3.new(5, 2, 0), Render.p)
            Viewport.Camera.CFrame = CameraPort
            ViewPart.CFrame = Render * CFrame.new(0, 0, -16)
            ViewHUD.Size = UDim2.new(0, Scale.X - 6, 0, Scale.Y - 6)
        end
    )
    --
    local CharacterAdded
    CharacterAdded =
        Client.CharacterAdded:Connect(
        function()
            RenderStepped:Disconnect()
            CharacterAdded:Disconnect()
            PlayerAdded:Disconnect()
            ViewHUD:Destroy()
            ViewHUD = nil
        end
    )
    
    ------------------------Part of modification------------------------
    for i,v in pairs(character1:GetDescendants()) do
        if v:IsA("Motor6D") then
            v:Destroy()
        end
    end
    
    if character1:FindFirstChildOfClass("Humanoid").RigType == Enum.HumanoidRigType.R15 then
        character1:BreakJoints()
    end
    
    for i,v in pairs(reanimation:GetChildren()) do
        if v:IsA("BasePart") then
            v.Anchored = false
        end
    end
    
    game:GetService("RunService").Heartbeat:Connect(function()
        for i,v in pairs(character1:GetChildren()) do
            if v:IsA("BasePart") then
                v.Velocity = Vector3.new(bodyVelocity[1], bodyVelocity[2], bodyVelocity[3])
                if character1:FindFirstChildOfClass("Humanoid").RigType == Enum.HumanoidRigType.R6 then
                    v.CFrame = reanimation:FindFirstChild(v.Name).CFrame
                else
                    --Head
                    if character1:FindFirstChild("Head") then
                        character1.Head.CFrame = reanimation.Head.CFrame
                    end
                    
                    --Torso
                    if character1:FindFirstChild("UpperTorso") then
                        character1.UpperTorso.CFrame = reanimation.Torso.CFrame * CFrame.new(0, 0.185, 0)
                    end
                    if character1:FindFirstChild("LowerTorso") then
                        character1.LowerTorso.CFrame = reanimation.Torso.CFrame * CFrame.new(0, -0.8, 0)
                    end
                    
                    --HumanoidRootPart
                    if character1:FindFirstChild("HumanoidRootPart") then
                        character1.HumanoidRootPart.CFrame = cHRP.CFrame
                    end
                    
                    --Left Arm
                    if character1:FindFirstChild("LeftUpperArm") then
                        character1.LeftUpperArm.CFrame = reanimation["Left Arm"].CFrame * CFrame.new(0, 0.4, 0)
                    end
                    if character1:FindFirstChild("LeftLowerArm") then
                        character1.LeftLowerArm.CFrame = reanimation["Left Arm"].CFrame * CFrame.new(0, -0.19, 0)
                    end
                    if character1:FindFirstChild("LeftHand") then
                        character1.LeftHand.CFrame = reanimation["Left Arm"].CFrame * CFrame.new(0, -0.84, 0)
                    end
                    
                    --Right Arm
                    if character1:FindFirstChild("RightUpperArm") then
                        character1.RightUpperArm.CFrame = reanimation["Right Arm"].CFrame * CFrame.new(0, 0.4, 0)
                    end
                    if character1:FindFirstChild("RightLowerArm") then
                        character1.RightLowerArm.CFrame = reanimation["Right Arm"].CFrame * CFrame.new(0, -0.19, 0)
                    end
                    if character1:FindFirstChild("RightHand") then
                        character1.RightHand.CFrame = reanimation["Right Arm"].CFrame * CFrame.new(0, -0.84, 0)
                    end
                    
                    --Left Leg
                    if character1:FindFirstChild("LeftUpperLeg") then
                        character1.LeftUpperLeg.CFrame = reanimation["Left Leg"].CFrame * CFrame.new(0, 0.55, 0)
                    end
                    if character1:FindFirstChild("LeftLowerLeg") then
                        character1.LeftLowerLeg.CFrame = reanimation["Left Leg"].CFrame * CFrame.new(0, -0.19, 0)
                    end
                    if character1:FindFirstChild("LeftFoot") then
                        character1.LeftFoot.CFrame = reanimation["Left Leg"].CFrame * CFrame.new(0, -0.85, 0)
                    end
                    
                    --Right Leg
                    if character1:FindFirstChild("RightUpperLeg") then
                        character1.RightUpperLeg.CFrame = reanimation["Right Leg"].CFrame * CFrame.new(0, 0.55, 0)
                    end
                    if character1:FindFirstChild("RightLowerLeg") then
                        character1.RightLowerLeg.CFrame = reanimation["Right Leg"].CFrame * CFrame.new(0, -0.19, 0)
                    end
                    if character1:FindFirstChild("RightFoot") then
                        character1.RightFoot.CFrame = reanimation["Right Leg"].CFrame * CFrame.new(0, -0.85, 0)
                    end
                end
            end
            
            if v:IsA("Accessory") then
                v.Handle.Velocity = Vector3.new(hatVelocity[1], hatVelocity[2], hatVelocity[3])
                v.Handle.CFrame = reanimation:FindFirstChild(v.Name).Handle.CFrame
            end
        end
    end)
    
    game:GetService("RunService").Stepped:Connect(function()
        for i,v in pairs(reanimation:GetChildren()) do
            if v:IsA("BasePart") then
                v.CanCollide = false
            end
        end
    end)
    
    
    --------------------------------------------------------------------
    
    wait(9e9)
end
Script()
wait(2)
local Players = game:GetService("Players")
local lp = Players.LocalPlayer
local character = reanimation--lp.Character
local A0LL = Instance.new("Attachment")
A0LL.Parent = character["Left Leg"]
A0LL.Position = Vector3.new(0, 1, 0)
local A1LL = Instance.new("Attachment")
A1LL.Parent = character["Torso"]
A1LL.Position = Vector3.new(-0.5, -1, 0)
local socket1 = Instance.new("BallSocketConstraint")
socket1.Parent = character["Left Leg"]
socket1.Attachment0 = A0LL
socket1.Attachment1 = A1LL
local A0RL = Instance.new("Attachment")
A0RL.Parent = character["Right Leg"]
A0RL.Position = Vector3.new(0, 1, 0)
local A1RL = Instance.new("Attachment")
A1RL.Parent = character["Torso"]
A1RL.Position = Vector3.new(0.5, -1, 0)
local socket2 = Instance.new("BallSocketConstraint")
socket2.Parent = character["Right Leg"]
socket2.Attachment0 = A0RL
socket2.Attachment1 = A1RL
local A0H = Instance.new("Attachment")
A0H.Parent = character["Head"]
A0H.Position = Vector3.new(0, -0.5, 0)
local A1H = Instance.new("Attachment")
A1H.Parent = character["Torso"]
A1H.Position = Vector3.new(0, 1, 0)
local socket5 = Instance.new("BallSocketConstraint")
socket5.Parent = character["Head"]
socket5.Attachment0 = A0H
socket5.Attachment1 = A1H
-----------------------------------------------------------
wait(9e9)
coroutine.wrap(function()
    while wait() do
        sethidden(Players.LocalPlayer, "SimulationRadius", math.huge)
        sethidden(Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)()
RunService.Stepped:Connect(function()
	sethidden(Players.LocalPlayer, "SimulationRadius", math.huge)
	Players.LocalPlayer.MaximumSimulationRadius = math.huge
end)
end
if WalkOnWall then
--[[
local _p = game:WaitForChild("Players")
local _plr = _p.ChildAdded:Wait()
if _plr == _p.LocalPlayer then
	_plr.ChildAdded:Connect(function(cccc)
		if c.Name == "PlayerScriptsLoader" then
			c.Disabled = true
		end
	end)
end
]]
repeat wait()
a = pcall(function()
	game:WaitForChild("Players").LocalPlayer:WaitForChild("PlayerScripts").ChildAdded:Connect(function(c)
		if c.Name == "PlayerScriptsLoader"then
			c.Disabled = true
		end
	end)
	end)
	if a == true then break end
until true == false
game:WaitForChild("Players").LocalPlayer:WaitForChild("PlayerScripts").ChildAdded:Connect(function(c)
	if c.Name == "PlayerScriptsLoader"then
		c.Disabled = true
	end
end)


function _CameraUI()
	local Players = game:GetService("Players")
	local TweenService = game:GetService("TweenService")
	
	local LocalPlayer = Players.LocalPlayer
	if not LocalPlayer then
		Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
		LocalPlayer = Players.LocalPlayer
	end
	
	local function waitForChildOfClass(parent, class)
		local child = parent:FindFirstChildOfClass(class)
		while not child or child.ClassName ~= class do
			child = parent.ChildAdded:Wait()
		end
		return child
	end
	
	local PlayerGui = waitForChildOfClass(LocalPlayer, "PlayerGui")
	
	local TOAST_OPEN_SIZE = UDim2.new(0, 326, 0, 58)
	local TOAST_CLOSED_SIZE = UDim2.new(0, 80, 0, 58)
	local TOAST_BACKGROUND_COLOR = Color3.fromRGB(32, 32, 32)
	local TOAST_BACKGROUND_TRANS = 0.4
	local TOAST_FOREGROUND_COLOR = Color3.fromRGB(200, 200, 200)
	local TOAST_FOREGROUND_TRANS = 0
	
	-- Convenient syntax for creating a tree of instanes
	local function create(className)
		return function(props)
			local inst = Instance.new(className)
			local parent = props.Parent
			props.Parent = nil
			for name, val in pairs(props) do
				if type(name) == "string" then
					inst[name] = val
				else
					val.Parent = inst
				end
			end
			-- Only set parent after all other properties are initialized
			inst.Parent = parent
			return inst
		end
	end
	
	local initialized = false
	
	local uiRoot
	local toast
	local toastIcon
	local toastUpperText
	local toastLowerText
	
	local function initializeUI()
		assert(not initialized)
	
		uiRoot = create("ScreenGui"){
			Name = "RbxCameraUI",
			AutoLocalize = false,
			Enabled = true,
			DisplayOrder = -1, -- Appears behind default developer UI
			IgnoreGuiInset = false,
			ResetOnSpawn = false,
			ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
	
			create("ImageLabel"){
				Name = "Toast",
				Visible = false,
				AnchorPoint = Vector2.new(0.5, 0),
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				Position = UDim2.new(0.5, 0, 0, 8),
				Size = TOAST_CLOSED_SIZE,
				Image = "rbxasset://textures/ui/Camera/CameraToast9Slice.png",
				ImageColor3 = TOAST_BACKGROUND_COLOR,
				ImageRectSize = Vector2.new(6, 6),
				ImageTransparency = 1,
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(3, 3, 3, 3),
				ClipsDescendants = true,
	
				create("Frame"){
					Name = "IconBuffer",
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.new(0, 0, 0, 0),
					Size = UDim2.new(0, 80, 1, 0),
	
					create("ImageLabel"){
						Name = "Icon",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundTransparency = 1,
						Position = UDim2.new(0.5, 0, 0.5, 0),
						Size = UDim2.new(0, 48, 0, 48),
						ZIndex = 2,
						Image = "rbxasset://textures/ui/Camera/CameraToastIcon.png",
						ImageColor3 = TOAST_FOREGROUND_COLOR,
						ImageTransparency = 1,
					}
				},
	
				create("Frame"){
					Name = "TextBuffer",
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.new(0, 80, 0, 0),
					Size = UDim2.new(1, -80, 1, 0),
					ClipsDescendants = true,
	
					create("TextLabel"){
						Name = "Upper",
						AnchorPoint = Vector2.new(0, 1),
						BackgroundTransparency = 1,
						Position = UDim2.new(0, 0, 0.5, 0),
						Size = UDim2.new(1, 0, 0, 19),
						Font = Enum.Font.GothamSemibold,
						Text = "Camera control enabled",
						TextColor3 = TOAST_FOREGROUND_COLOR,
						TextTransparency = 1,
						TextSize = 19,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextYAlignment = Enum.TextYAlignment.Center,
					},
	
					create("TextLabel"){
						Name = "Lower",
						AnchorPoint = Vector2.new(0, 0),
						BackgroundTransparency = 1,
						Position = UDim2.new(0, 0, 0.5, 3),
						Size = UDim2.new(1, 0, 0, 15),
						Font = Enum.Font.Gotham,
						Text = "Right mouse button to toggle",
						TextColor3 = TOAST_FOREGROUND_COLOR,
						TextTransparency = 1,
						TextSize = 15,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextYAlignment = Enum.TextYAlignment.Center,
					},
				},
			},
	
			Parent = PlayerGui,
		}
	
		toast = uiRoot.Toast
		toastIcon = toast.IconBuffer.Icon
		toastUpperText = toast.TextBuffer.Upper
		toastLowerText = toast.TextBuffer.Lower
	
		initialized = true
	end
	
	local CameraUI = {}
	
	do
		-- Instantaneously disable the toast or enable for opening later on. Used when switching camera modes.
		function CameraUI.setCameraModeToastEnabled(enabled)
			if not enabled and not initialized then
				return
			end
	
			if not initialized then
				initializeUI()
			end
	
			toast.Visible = enabled
			if not enabled then
				CameraUI.setCameraModeToastOpen(false)
			end
		end
	
		local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	
		-- Tween the toast in or out. Toast must be enabled with setCameraModeToastEnabled.
		function CameraUI.setCameraModeToastOpen(open)
			assert(initialized)
	
			TweenService:Create(toast, tweenInfo, {
				Size = open and TOAST_OPEN_SIZE or TOAST_CLOSED_SIZE,
				ImageTransparency = open and TOAST_BACKGROUND_TRANS or 1,
			}):Play()
	
			TweenService:Create(toastIcon, tweenInfo, {
				ImageTransparency = open and TOAST_FOREGROUND_TRANS or 1,
			}):Play()
	
			TweenService:Create(toastUpperText, tweenInfo, {
				TextTransparency = open and TOAST_FOREGROUND_TRANS or 1,
			}):Play()
	
			TweenService:Create(toastLowerText, tweenInfo, {
				TextTransparency = open and TOAST_FOREGROUND_TRANS or 1,
			}):Play()
		end
	end
	
	return CameraUI
end

function _CameraToggleStateController()
	local Players = game:GetService("Players")
	local UserInputService = game:GetService("UserInputService")
	local GameSettings = UserSettings():GetService("UserGameSettings")
	
	local LocalPlayer = Players.LocalPlayer
	if not LocalPlayer then
		Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
		LocalPlayer = Players.LocalPlayer
	end
	
	local Mouse = LocalPlayer:GetMouse()
	
	local Input = _CameraInput()
	local CameraUI = _CameraUI()
	
	local lastTogglePan = false
	local lastTogglePanChange = tick()
	
	local CROSS_MOUSE_ICON = "rbxasset://textures/Cursors/CrossMouseIcon.png"
	
	local lockStateDirty = false
	local wasTogglePanOnTheLastTimeYouWentIntoFirstPerson = false
	local lastFirstPerson = false
	
	CameraUI.setCameraModeToastEnabled(false)
	
	return function(isFirstPerson)
		local togglePan = Input.getTogglePan()
		local toastTimeout = 3
	
		if isFirstPerson and togglePan ~= lastTogglePan then
			lockStateDirty = true
		end
	
		if lastTogglePan ~= togglePan or tick() - lastTogglePanChange > toastTimeout then
			local doShow = togglePan and tick() - lastTogglePanChange < toastTimeout
	
			CameraUI.setCameraModeToastOpen(doShow)
	
			if togglePan then
				lockStateDirty = false
			end
			lastTogglePanChange = tick()
			lastTogglePan = togglePan
		end
	
		if isFirstPerson ~= lastFirstPerson then
			if isFirstPerson then
				wasTogglePanOnTheLastTimeYouWentIntoFirstPerson = Input.getTogglePan()
				Input.setTogglePan(true)
			elseif not lockStateDirty then
				Input.setTogglePan(wasTogglePanOnTheLastTimeYouWentIntoFirstPerson)
			end
		end
	
		if isFirstPerson then
			if Input.getTogglePan() then
				Mouse.Icon = CROSS_MOUSE_ICON
				UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
				--GameSettings.RotationType = Enum.RotationType.CameraRelative
			else
				Mouse.Icon = ""
				UserInputService.MouseBehavior = Enum.MouseBehavior.Default
				--GameSettings.RotationType = Enum.RotationType.CameraRelative
			end
	
		elseif Input.getTogglePan() then
			Mouse.Icon = CROSS_MOUSE_ICON
			UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
			GameSettings.RotationType = Enum.RotationType.MovementRelative
	
		elseif Input.getHoldPan() then
			Mouse.Icon = ""
			UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
			GameSettings.RotationType = Enum.RotationType.MovementRelative
	
		else
			Mouse.Icon = ""
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
			GameSettings.RotationType = Enum.RotationType.MovementRelative
		end
	
		lastFirstPerson = isFirstPerson
	end
end

function _CameraInput()
	local UserInputService = game:GetService("UserInputService")
	
	local MB_TAP_LENGTH = 0.3 -- length of time for a short mouse button tap to be registered
	
	local rmbDown, rmbUp
	do
		local rmbDownBindable = Instance.new("BindableEvent")
		local rmbUpBindable = Instance.new("BindableEvent")
	
		rmbDown = rmbDownBindable.Event
		rmbUp = rmbUpBindable.Event
	
		UserInputService.InputBegan:Connect(function(input, gpe)
			if not gpe and input.UserInputType == Enum.UserInputType.MouseButton2 then
				rmbDownBindable:Fire()
			end
		end)
	
		UserInputService.InputEnded:Connect(function(input, gpe)
			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				rmbUpBindable:Fire()
			end
		end)
	end
	
	local holdPan = false
	local togglePan = false
	local lastRmbDown = 0 -- tick() timestamp of the last right mouse button down event
	
	local CameraInput = {}
	
	function CameraInput.getHoldPan()
		return holdPan
	end
	
	function CameraInput.getTogglePan()
		return togglePan
	end
	
	function CameraInput.getPanning()
		return togglePan or holdPan
	end
	
	function CameraInput.setTogglePan(value)
		togglePan = value
	end
	
	local cameraToggleInputEnabled = false
	local rmbDownConnection
	local rmbUpConnection
	
	function CameraInput.enableCameraToggleInput()
		if cameraToggleInputEnabled then
			return
		end
		cameraToggleInputEnabled = true
	
		holdPan = false
		togglePan = false
	
		if rmbDownConnection then
			rmbDownConnection:Disconnect()
		end
	
		if rmbUpConnection then
			rmbUpConnection:Disconnect()
		end
	
		rmbDownConnection = rmbDown:Connect(function()
			holdPan = true
			lastRmbDown = tick()
		end)
	
		rmbUpConnection = rmbUp:Connect(function()
			holdPan = false
			if tick() - lastRmbDown < MB_TAP_LENGTH and (togglePan or UserInputService:GetMouseDelta().Magnitude < 2) then
				togglePan = not togglePan
			end
		end)
	end
	
	function CameraInput.disableCameraToggleInput()
		if not cameraToggleInputEnabled then
			return
		end
		cameraToggleInputEnabled = false
	
		if rmbDownConnection then
			rmbDownConnection:Disconnect()
			rmbDownConnection = nil
		end
		if rmbUpConnection then
			rmbUpConnection:Disconnect()
			rmbUpConnection = nil
		end
	end
	
	return CameraInput
end

function _BaseCamera()
	--[[
		BaseCamera - Abstract base class for camera control modules
		2018 Camera Update - AllYourBlox
	--]]
	
	--[[ Local Constants ]]--
	local UNIT_Z = Vector3.new(0,0,1)
	local X1_Y0_Z1 = Vector3.new(1,0,1)	--Note: not a unit vector, used for projecting onto XZ plane
	
	local THUMBSTICK_DEADZONE = 0.2
	local DEFAULT_DISTANCE = 12.5	-- Studs
	local PORTRAIT_DEFAULT_DISTANCE = 25		-- Studs
	local FIRST_PERSON_DISTANCE_THRESHOLD = 1.0 -- Below this value, snap into first person
	
	local CAMERA_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
	
	-- Note: DotProduct check in CoordinateFrame::lookAt() prevents using values within about
	-- 8.11 degrees of the +/- Y axis, that's why these limits are currently 80 degrees
	local MIN_Y = math.rad(-80)
	local MAX_Y = math.rad(80)
	
	local TOUCH_ADJUST_AREA_UP = math.rad(30)
	local TOUCH_ADJUST_AREA_DOWN = math.rad(-15)
	
	local TOUCH_SENSITIVTY_ADJUST_MAX_Y = 2.1
	local TOUCH_SENSITIVTY_ADJUST_MIN_Y = 0.5
	
	local VR_ANGLE = math.rad(15)
	local VR_LOW_INTENSITY_ROTATION = Vector2.new(math.rad(15), 0)
	local VR_HIGH_INTENSITY_ROTATION = Vector2.new(math.rad(45), 0)
	local VR_LOW_INTENSITY_REPEAT = 0.1
	local VR_HIGH_INTENSITY_REPEAT = 0.4
	
	local ZERO_VECTOR2 = Vector2.new(0,0)
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	
	local TOUCH_SENSITIVTY = Vector2.new(0.00945 * math.pi, 0.003375 * math.pi)
	local MOUSE_SENSITIVITY = Vector2.new( 0.002 * math.pi, 0.0015 * math.pi )
	
	local SEAT_OFFSET = Vector3.new(0,5,0)
	local VR_SEAT_OFFSET = Vector3.new(0,4,0)
	local HEAD_OFFSET = Vector3.new(0,1.5,0)
	local R15_HEAD_OFFSET = Vector3.new(0, 1.5, 0)
	local R15_HEAD_OFFSET_NO_SCALING = Vector3.new(0, 2, 0)
	local HUMANOID_ROOT_PART_SIZE = Vector3.new(2, 2, 1)
	
	local GAMEPAD_ZOOM_STEP_1 = 0
	local GAMEPAD_ZOOM_STEP_2 = 10
	local GAMEPAD_ZOOM_STEP_3 = 20
	
	local PAN_SENSITIVITY = 20
	local ZOOM_SENSITIVITY_CURVATURE = 0.5
	
	local abs = math.abs
	local sign = math.sign
	
	local FFlagUserCameraToggle do
		local success, result = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserCameraToggle")
		end)
		FFlagUserCameraToggle = success and result
	end
	
	local FFlagUserDontAdjustSensitvityForPortrait do
		local success, result = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserDontAdjustSensitvityForPortrait")
		end)
		FFlagUserDontAdjustSensitvityForPortrait = success and result
	end
	
	local FFlagUserFixZoomInZoomOutDiscrepancy do
		local success, result = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserFixZoomInZoomOutDiscrepancy")
		end)
		FFlagUserFixZoomInZoomOutDiscrepancy = success and result
	end
	
	local Util = _CameraUtils()
	local ZoomController = _ZoomController()
	local CameraToggleStateController = _CameraToggleStateController()
	local CameraInput = _CameraInput()
	local CameraUI = _CameraUI()
	
	--[[ Roblox Services ]]--
	local Players = game:GetService("Players")
	local UserInputService = game:GetService("UserInputService")
	local StarterGui = game:GetService("StarterGui")
	local GuiService = game:GetService("GuiService")
	local ContextActionService = game:GetService("ContextActionService")
	local VRService = game:GetService("VRService")
	local UserGameSettings = UserSettings():GetService("UserGameSettings")
	
	local player = Players.LocalPlayer 
	
	--[[ The Module ]]--
	local BaseCamera = {}
	BaseCamera.__index = BaseCamera
	
	function BaseCamera.new()
		local self = setmetatable({}, BaseCamera)
	
		-- So that derived classes have access to this
		self.FIRST_PERSON_DISTANCE_THRESHOLD = FIRST_PERSON_DISTANCE_THRESHOLD
	
		self.cameraType = nil
		self.cameraMovementMode = nil
	
		self.lastCameraTransform = nil
		self.rotateInput = ZERO_VECTOR2
		self.userPanningCamera = false
		self.lastUserPanCamera = tick()
	
		self.humanoidRootPart = nil
		self.humanoidCache = {}
	
		-- Subject and position on last update call
		self.lastSubject = nil
		self.lastSubjectPosition = Vector3.new(0,5,0)
	
		-- These subject distance members refer to the nominal camera-to-subject follow distance that the camera
		-- is trying to maintain, not the actual measured value.
		-- The default is updated when screen orientation or the min/max distances change,
		-- to be sure the default is always in range and appropriate for the orientation.
		self.defaultSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
		self.currentSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
	
		self.inFirstPerson = false
		self.inMouseLockedMode = false
		self.portraitMode = false
		self.isSmallTouchScreen = false
	
		-- Used by modules which want to reset the camera angle on respawn.
		self.resetCameraAngle = true
	
		self.enabled = false
	
		-- Input Event Connections
		self.inputBeganConn = nil
		self.inputChangedConn = nil
		self.inputEndedConn = nil
	
		self.startPos = nil
		self.lastPos = nil
		self.panBeginLook = nil
	
		self.panEnabled = true
		self.keyPanEnabled = true
		self.distanceChangeEnabled = true
	
		self.PlayerGui = nil
	
		self.cameraChangedConn = nil
		self.viewportSizeChangedConn = nil
	
		self.boundContextActions = {}
	
		-- VR Support
		self.shouldUseVRRotation = false
		self.VRRotationIntensityAvailable = false
		self.lastVRRotationIntensityCheckTime = 0
		self.lastVRRotationTime = 0
		self.vrRotateKeyCooldown = {}
		self.cameraTranslationConstraints = Vector3.new(1, 1, 1)
		self.humanoidJumpOrigin = nil
		self.trackingHumanoid = nil
		self.cameraFrozen = false
		self.subjectStateChangedConn = nil
	
		-- Gamepad support
		self.activeGamepad = nil
		self.gamepadPanningCamera = false
		self.lastThumbstickRotate = nil
		self.numOfSeconds = 0.7
		self.currentSpeed = 0
		self.maxSpeed = 6
		self.vrMaxSpeed = 4
		self.lastThumbstickPos = Vector2.new(0,0)
		self.ySensitivity = 0.65
		self.lastVelocity = nil
		self.gamepadConnectedConn = nil
		self.gamepadDisconnectedConn = nil
		self.currentZoomSpeed = 1.0
		self.L3ButtonDown = false
		self.dpadLeftDown = false
		self.dpadRightDown = false
	
		-- Touch input support
		self.isDynamicThumbstickEnabled = false
		self.fingerTouches = {}
		self.dynamicTouchInput = nil
		self.numUnsunkTouches = 0
		self.inputStartPositions = {}
		self.inputStartTimes = {}
		self.startingDiff = nil
		self.pinchBeginZoom = nil
		self.userPanningTheCamera = false
		self.touchActivateConn = nil
	
		-- Mouse locked formerly known as shift lock mode
		self.mouseLockOffset = ZERO_VECTOR3
	
		-- [[ NOTICE ]] --
		-- Initialization things used to always execute at game load time, but now these camera modules are instantiated
		-- when needed, so the code here may run well after the start of the game
	
		if player.Character then
			self:OnCharacterAdded(player.Character)
		end
	
		player.CharacterAdded:Connect(function(char)
			self:OnCharacterAdded(char)
		end)
	
		if self.cameraChangedConn then self.cameraChangedConn:Disconnect() end
		self.cameraChangedConn = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
			self:OnCurrentCameraChanged()
		end)
		self:OnCurrentCameraChanged()
	
		if self.playerCameraModeChangeConn then self.playerCameraModeChangeConn:Disconnect() end
		self.playerCameraModeChangeConn = player:GetPropertyChangedSignal("CameraMode"):Connect(function()
			self:OnPlayerCameraPropertyChange()
		end)
	
		if self.minDistanceChangeConn then self.minDistanceChangeConn:Disconnect() end
		self.minDistanceChangeConn = player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(function()
			self:OnPlayerCameraPropertyChange()
		end)
	
		if self.maxDistanceChangeConn then self.maxDistanceChangeConn:Disconnect() end
		self.maxDistanceChangeConn = player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
			self:OnPlayerCameraPropertyChange()
		end)
	
		if self.playerDevTouchMoveModeChangeConn then self.playerDevTouchMoveModeChangeConn:Disconnect() end
		self.playerDevTouchMoveModeChangeConn = player:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
			self:OnDevTouchMovementModeChanged()
		end)
		self:OnDevTouchMovementModeChanged() -- Init
	
		if self.gameSettingsTouchMoveMoveChangeConn then self.gameSettingsTouchMoveMoveChangeConn:Disconnect() end
		self.gameSettingsTouchMoveMoveChangeConn = UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
			self:OnGameSettingsTouchMovementModeChanged()
		end)
		self:OnGameSettingsTouchMovementModeChanged() -- Init
	
		UserGameSettings:SetCameraYInvertVisible()
		UserGameSettings:SetGamepadCameraSensitivityVisible()
	
		self.hasGameLoaded = game:IsLoaded()
		if not self.hasGameLoaded then
			self.gameLoadedConn = game.Loaded:Connect(function()
				self.hasGameLoaded = true
				self.gameLoadedConn:Disconnect()
				self.gameLoadedConn = nil
			end)
		end
	
		self:OnPlayerCameraPropertyChange()
	
		return self
	end
	
	function BaseCamera:GetModuleName()
		return "BaseCamera"
	end
	
	function BaseCamera:OnCharacterAdded(char)
		self.resetCameraAngle = self.resetCameraAngle or self:GetEnabled()
		self.humanoidRootPart = nil
		if UserInputService.TouchEnabled then
			self.PlayerGui = player:WaitForChild("PlayerGui")
			for _, child in ipairs(char:GetChildren()) do
				if child:IsA("Tool") then
					self.isAToolEquipped = true
				end
			end
			char.ChildAdded:Connect(function(child)
				if child:IsA("Tool") then
					self.isAToolEquipped = true
				end
			end)
			char.ChildRemoved:Connect(function(child)
				if child:IsA("Tool") then
					self.isAToolEquipped = false
				end
			end)
		end
	end
	
	function BaseCamera:GetHumanoidRootPart()
		if not self.humanoidRootPart then
			if player.Character then
				local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					self.humanoidRootPart = humanoid.RootPart
				end
			end
		end
		return self.humanoidRootPart
	end
	
	function BaseCamera:GetBodyPartToFollow(humanoid, isDead)
		-- If the humanoid is dead, prefer the head part if one still exists as a sibling of the humanoid
		if humanoid:GetState() == Enum.HumanoidStateType.Dead then
			local character = humanoid.Parent
			if character and character:IsA("Model") then
				return character:FindFirstChild("Head") or humanoid.RootPart
			end
		end
	
		return humanoid.RootPart
	end
	
	function BaseCamera:GetSubjectPosition()
		local result = self.lastSubjectPosition
		local camera = game.Workspace.CurrentCamera
		local cameraSubject = camera and camera.CameraSubject
	
		if cameraSubject then
			if cameraSubject:IsA("Humanoid") then
				local humanoid = cameraSubject
				local humanoidIsDead = humanoid:GetState() == Enum.HumanoidStateType.Dead
	
				if VRService.VREnabled and humanoidIsDead and humanoid == self.lastSubject then
					result = self.lastSubjectPosition
				else
					local bodyPartToFollow = humanoid.RootPart
	
					-- If the humanoid is dead, prefer their head part as a follow target, if it exists
					if humanoidIsDead then
						if humanoid.Parent and humanoid.Parent:IsA("Model") then
							bodyPartToFollow = humanoid.Parent:FindFirstChild("Head") or bodyPartToFollow
						end
					end
	
					if bodyPartToFollow and bodyPartToFollow:IsA("BasePart") then
						local heightOffset
						if humanoid.RigType == Enum.HumanoidRigType.R15 then
							if humanoid.AutomaticScalingEnabled then
								heightOffset = R15_HEAD_OFFSET
								if bodyPartToFollow == humanoid.RootPart then
									local rootPartSizeOffset = (humanoid.RootPart.Size.Y/2) - (HUMANOID_ROOT_PART_SIZE.Y/2)
									heightOffset = heightOffset + Vector3.new(0, rootPartSizeOffset, 0)
								end
							else
								heightOffset = R15_HEAD_OFFSET_NO_SCALING
							end
						else
							heightOffset = HEAD_OFFSET
						end
	
						if humanoidIsDead then
							heightOffset = ZERO_VECTOR3
						end
	
						result = bodyPartToFollow.CFrame.p + bodyPartToFollow.CFrame:vectorToWorldSpace(heightOffset + humanoid.CameraOffset)
					end
				end
	
			elseif cameraSubject:IsA("VehicleSeat") then
				local offset = SEAT_OFFSET
				if VRService.VREnabled then
					offset = VR_SEAT_OFFSET
				end
				result = cameraSubject.CFrame.p + cameraSubject.CFrame:vectorToWorldSpace(offset)
			elseif cameraSubject:IsA("SkateboardPlatform") then
				result = cameraSubject.CFrame.p + SEAT_OFFSET
			elseif cameraSubject:IsA("BasePart") then
				result = cameraSubject.CFrame.p
			elseif cameraSubject:IsA("Model") then
				if cameraSubject.PrimaryPart then
					result = cameraSubject:GetPrimaryPartCFrame().p
				else
					result = cameraSubject:GetModelCFrame().p
				end
			end
		else
			-- cameraSubject is nil
			-- Note: Previous RootCamera did not have this else case and let self.lastSubject and self.lastSubjectPosition
			-- both get set to nil in the case of cameraSubject being nil. This function now exits here to preserve the
			-- last set valid values for these, as nil values are not handled cases
			return
		end
	
		self.lastSubject = cameraSubject
		self.lastSubjectPosition = result
	
		return result
	end
	
	function BaseCamera:UpdateDefaultSubjectDistance()
		if self.portraitMode then
			self.defaultSubjectDistance = math.clamp(PORTRAIT_DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
		else
			self.defaultSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
		end
	end
	
	function BaseCamera:OnViewportSizeChanged()
		local camera = game.Workspace.CurrentCamera
		local size = camera.ViewportSize
		self.portraitMode = size.X < size.Y
		self.isSmallTouchScreen = UserInputService.TouchEnabled and (size.Y < 500 or size.X < 700)
	
		self:UpdateDefaultSubjectDistance()
	end
	
	-- Listener for changes to workspace.CurrentCamera
	function BaseCamera:OnCurrentCameraChanged()
		if UserInputService.TouchEnabled then
			if self.viewportSizeChangedConn then
				self.viewportSizeChangedConn:Disconnect()
				self.viewportSizeChangedConn = nil
			end
	
			local newCamera = game.Workspace.CurrentCamera
	
			if newCamera then
				self:OnViewportSizeChanged()
				self.viewportSizeChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
					self:OnViewportSizeChanged()
				end)
			end
		end
	
		-- VR support additions
		if self.cameraSubjectChangedConn then
			self.cameraSubjectChangedConn:Disconnect()
			self.cameraSubjectChangedConn = nil
		end
	
		local camera = game.Workspace.CurrentCamera
		if camera then
			self.cameraSubjectChangedConn = camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
				self:OnNewCameraSubject()
			end)
			self:OnNewCameraSubject()
		end
	end
	
	function BaseCamera:OnDynamicThumbstickEnabled()
		if UserInputService.TouchEnabled then
			self.isDynamicThumbstickEnabled = true
		end
	end
	
	function BaseCamera:OnDynamicThumbstickDisabled()
		self.isDynamicThumbstickEnabled = false
	end
	
	function BaseCamera:OnGameSettingsTouchMovementModeChanged()
		if player.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice then
			if (UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.DynamicThumbstick
				or UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.Default) then
				self:OnDynamicThumbstickEnabled()
			else
				self:OnDynamicThumbstickDisabled()
			end
		end
	end
	
	function BaseCamera:OnDevTouchMovementModeChanged()
		if player.DevTouchMovementMode.Name == "DynamicThumbstick" then
			self:OnDynamicThumbstickEnabled()
		else
			self:OnGameSettingsTouchMovementModeChanged()
		end
	end
	
	function BaseCamera:OnPlayerCameraPropertyChange()
		-- This call forces re-evaluation of player.CameraMode and clamping to min/max distance which may have changed
		self:SetCameraToSubjectDistance(self.currentSubjectDistance)
	end
	
	function BaseCamera:GetCameraHeight()
		if VRService.VREnabled and not self.inFirstPerson then
			return math.sin(VR_ANGLE) * self.currentSubjectDistance
		end
		return 0
	end
	
	function BaseCamera:InputTranslationToCameraAngleChange(translationVector, sensitivity)
		if not FFlagUserDontAdjustSensitvityForPortrait then
			local camera = game.Workspace.CurrentCamera
			if camera and camera.ViewportSize.X > 0 and camera.ViewportSize.Y > 0 and (camera.ViewportSize.Y > camera.ViewportSize.X) then
				-- Screen has portrait orientation, swap X and Y sensitivity
				return translationVector * Vector2.new( sensitivity.Y, sensitivity.X)
			end
		end
		return translationVector * sensitivity
	end
	
	function BaseCamera:Enable(enable)
		if self.enabled ~= enable then
			self.enabled = enable
			if self.enabled then
				self:ConnectInputEvents()
				self:BindContextActions()
	
				if player.CameraMode == Enum.CameraMode.LockFirstPerson then
					self.currentSubjectDistance = 0.5
					if not self.inFirstPerson then
						self:EnterFirstPerson()
					end
				end
			else
				self:DisconnectInputEvents()
				self:UnbindContextActions()
				-- Clean up additional event listeners and reset a bunch of properties
				self:Cleanup()
			end
		end
	end
	
	function BaseCamera:GetEnabled()
		return self.enabled
	end
	
	function BaseCamera:OnInputBegan(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchBegan(input, processed)
		elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
			self:OnMouse2Down(input, processed)
		elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
			self:OnMouse3Down(input, processed)
		end
	end
	
	function BaseCamera:OnInputChanged(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchChanged(input, processed)
		elseif input.UserInputType == Enum.UserInputType.MouseMovement then
			self:OnMouseMoved(input, processed)
		end
	end
	
	function BaseCamera:OnInputEnded(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchEnded(input, processed)
		elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
			self:OnMouse2Up(input, processed)
		elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
			self:OnMouse3Up(input, processed)
		end
	end
	
	function BaseCamera:OnPointerAction(wheel, pan, pinch, processed)
		if processed then
			return
		end
	
		if pan.Magnitude > 0 then
			local inversionVector = Vector2.new(1, UserGameSettings:GetCameraYInvertValue())
			local rotateDelta = self:InputTranslationToCameraAngleChange(PAN_SENSITIVITY*pan, MOUSE_SENSITIVITY)*inversionVector
			self.rotateInput = self.rotateInput + rotateDelta
		end
	
		local zoom = self.currentSubjectDistance
		local zoomDelta = -(wheel + pinch)
	
		if abs(zoomDelta) > 0 then
			local newZoom
			if self.inFirstPerson and zoomDelta > 0 then
				newZoom = FIRST_PERSON_DISTANCE_THRESHOLD
			else
				if FFlagUserFixZoomInZoomOutDiscrepancy then
					if (zoomDelta > 0) then
						newZoom = zoom + zoomDelta*(1 + zoom*ZOOM_SENSITIVITY_CURVATURE)
					else
						newZoom = (zoom + zoomDelta) / (1 - zoomDelta*ZOOM_SENSITIVITY_CURVATURE)
					end
				else
					newZoom = zoom + zoomDelta*(1 + zoom*ZOOM_SENSITIVITY_CURVATURE)
				end
			end
	
			self:SetCameraToSubjectDistance(newZoom)
		end
	end
	
	function BaseCamera:ConnectInputEvents()
		self.pointerActionConn = UserInputService.PointerAction:Connect(function(wheel, pan, pinch, processed)
			self:OnPointerAction(wheel, pan, pinch, processed)
		end)
	
		self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
			self:OnInputBegan(input, processed)
		end)
	
		self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
			self:OnInputChanged(input, processed)
		end)
	
		self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
			self:OnInputEnded(input, processed)
		end)
	
		self.menuOpenedConn = GuiService.MenuOpened:connect(function()
			self:ResetInputStates()
		end)
	
		self.gamepadConnectedConn = UserInputService.GamepadDisconnected:connect(function(gamepadEnum)
			if self.activeGamepad ~= gamepadEnum then return end
			self.activeGamepad = nil
			self:AssignActivateGamepad()
		end)
	
		self.gamepadDisconnectedConn = UserInputService.GamepadConnected:connect(function(gamepadEnum)
			if self.activeGamepad == nil then
				self:AssignActivateGamepad()
			end
		end)
	
		self:AssignActivateGamepad()
		if not FFlagUserCameraToggle then
			self:UpdateMouseBehavior()
		end
	end
	
	function BaseCamera:BindContextActions()
		self:BindGamepadInputActions()
		self:BindKeyboardInputActions()
	end
	
	function BaseCamera:AssignActivateGamepad()
		local connectedGamepads = UserInputService:GetConnectedGamepads()
		if #connectedGamepads > 0 then
			for i = 1, #connectedGamepads do
				if self.activeGamepad == nil then
					self.activeGamepad = connectedGamepads[i]
				elseif connectedGamepads[i].Value < self.activeGamepad.Value then
					self.activeGamepad = connectedGamepads[i]
				end
			end
		end
	
		if self.activeGamepad == nil then -- nothing is connected, at least set up for gamepad1
			self.activeGamepad = Enum.UserInputType.Gamepad1
		end
	end
	
	function BaseCamera:DisconnectInputEvents()
		if self.inputBeganConn then
			self.inputBeganConn:Disconnect()
			self.inputBeganConn = nil
		end
		if self.inputChangedConn then
			self.inputChangedConn:Disconnect()
			self.inputChangedConn = nil
		end
		if self.inputEndedConn then
			self.inputEndedConn:Disconnect()
			self.inputEndedConn = nil
		end
	end
	
	function BaseCamera:UnbindContextActions()
		for i = 1, #self.boundContextActions do
			ContextActionService:UnbindAction(self.boundContextActions[i])
		end
		self.boundContextActions = {}
	end
	
	function BaseCamera:Cleanup()
		if self.pointerActionConn then
			self.pointerActionConn:Disconnect()
			self.pointerActionConn = nil
		end
		if self.menuOpenedConn then
			self.menuOpenedConn:Disconnect()
			self.menuOpenedConn = nil
		end
		if self.mouseLockToggleConn then
			self.mouseLockToggleConn:Disconnect()
			self.mouseLockToggleConn = nil
		end
		if self.gamepadConnectedConn then
			self.gamepadConnectedConn:Disconnect()
			self.gamepadConnectedConn = nil
		end
		if self.gamepadDisconnectedConn then
			self.gamepadDisconnectedConn:Disconnect()
			self.gamepadDisconnectedConn = nil
		end
		if self.subjectStateChangedConn then
			self.subjectStateChangedConn:Disconnect()
			self.subjectStateChangedConn = nil
		end
		if self.viewportSizeChangedConn then
			self.viewportSizeChangedConn:Disconnect()
			self.viewportSizeChangedConn = nil
		end
		if self.touchActivateConn then
			self.touchActivateConn:Disconnect()
			self.touchActivateConn = nil
		end
	
		self.turningLeft = false
		self.turningRight = false
		self.lastCameraTransform = nil
		self.lastSubjectCFrame = nil
		self.userPanningTheCamera = false
		self.rotateInput = Vector2.new()
		self.gamepadPanningCamera = Vector2.new(0,0)
	
		-- Reset input states
		self.startPos = nil
		self.lastPos = nil
		self.panBeginLook = nil
		self.isRightMouseDown = false
		self.isMiddleMouseDown = false
	
		self.fingerTouches = {}
		self.dynamicTouchInput = nil
		self.numUnsunkTouches = 0
	
		self.startingDiff = nil
		self.pinchBeginZoom = nil
	
		-- Unlock mouse for example if right mouse button was being held down
		if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		end
	end
	
	-- This is called when settings menu is opened
	function BaseCamera:ResetInputStates()
		self.isRightMouseDown = false
		self.isMiddleMouseDown = false
		self:OnMousePanButtonReleased() -- this function doesn't seem to actually need parameters
	
		if UserInputService.TouchEnabled then
			--[[menu opening was causing serious touch issues
			this should disable all active touch events if
			they're active when menu opens.]]
			for inputObject in pairs(self.fingerTouches) do
				self.fingerTouches[inputObject] = nil
			end
			self.dynamicTouchInput = nil
			self.panBeginLook = nil
			self.startPos = nil
			self.lastPos = nil
			self.userPanningTheCamera = false
			self.startingDiff = nil
			self.pinchBeginZoom = nil
			self.numUnsunkTouches = 0
		end
	end
	
	function BaseCamera:GetGamepadPan(name, state, input)
		if input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.Thumbstick2 then
	--		if self.L3ButtonDown then
	--			-- L3 Thumbstick is depressed, right stick controls dolly in/out
	--			if (input.Position.Y > THUMBSTICK_DEADZONE) then
	--				self.currentZoomSpeed = 0.96
	--			elseif (input.Position.Y < -THUMBSTICK_DEADZONE) then
	--				self.currentZoomSpeed = 1.04
	--			else
	--				self.currentZoomSpeed = 1.00
	--			end
	--		else
				if state == Enum.UserInputState.Cancel then
					self.gamepadPanningCamera = ZERO_VECTOR2
					return
				end
	
				local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
				if inputVector.magnitude > THUMBSTICK_DEADZONE then
					self.gamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
				else
					self.gamepadPanningCamera = ZERO_VECTOR2
				end
			--end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	
	function BaseCamera:DoKeyboardPanTurn(name, state, input)
		if not self.hasGameLoaded and VRService.VREnabled then
			return Enum.ContextActionResult.Pass
		end
	
		if state == Enum.UserInputState.Cancel then
			self.turningLeft = false
			self.turningRight = false
			return Enum.ContextActionResult.Sink
		end
	
		if self.panBeginLook == nil and self.keyPanEnabled then
			if input.KeyCode == Enum.KeyCode.Left then
				self.turningLeft = state == Enum.UserInputState.Begin
			elseif input.KeyCode == Enum.KeyCode.Right then
				self.turningRight = state == Enum.UserInputState.Begin
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	
	function BaseCamera:DoPanRotateCamera(rotateAngle)
		local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1,0,1), rotateAngle, math.pi*0.25)
		if angle ~= 0 then
			self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
			self.lastUserPanCamera = tick()
			self.lastCameraTransform = nil
		end
	end
	
	function BaseCamera:DoGamepadZoom(name, state, input)
		if input.UserInputType == self.activeGamepad then
			if input.KeyCode == Enum.KeyCode.ButtonR3 then
				if state == Enum.UserInputState.Begin then
					if self.distanceChangeEnabled then
						local dist = self:GetCameraToSubjectDistance()
	
						if dist > (GAMEPAD_ZOOM_STEP_2 + GAMEPAD_ZOOM_STEP_3)/2 then
							self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_2)
						elseif dist > (GAMEPAD_ZOOM_STEP_1 + GAMEPAD_ZOOM_STEP_2)/2 then
							self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_1)
						else
							self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_3)
						end
					end
				end
			elseif input.KeyCode == Enum.KeyCode.DPadLeft then
				self.dpadLeftDown = (state == Enum.UserInputState.Begin)
			elseif input.KeyCode == Enum.KeyCode.DPadRight then
				self.dpadRightDown = (state == Enum.UserInputState.Begin)
			end
	
			if self.dpadLeftDown then
				self.currentZoomSpeed = 1.04
			elseif self.dpadRightDown then
				self.currentZoomSpeed = 0.96
			else
				self.currentZoomSpeed = 1.00
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	--	elseif input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.ButtonL3 then
	--		if (state == Enum.UserInputState.Begin) then
	--			self.L3ButtonDown = true
	--		elseif (state == Enum.UserInputState.End) then
	--			self.L3ButtonDown = false
	--			self.currentZoomSpeed = 1.00
	--		end
	--	end
	end
	
	function BaseCamera:DoKeyboardZoom(name, state, input)
		if not self.hasGameLoaded and VRService.VREnabled then
			return Enum.ContextActionResult.Pass
		end
	
		if state ~= Enum.UserInputState.Begin then
			return Enum.ContextActionResult.Pass
		end
	
		if self.distanceChangeEnabled and player.CameraMode ~= Enum.CameraMode.LockFirstPerson then
			if input.KeyCode == Enum.KeyCode.I then
				self:SetCameraToSubjectDistance( self.currentSubjectDistance - 5 )
			elseif input.KeyCode == Enum.KeyCode.O then
				self:SetCameraToSubjectDistance( self.currentSubjectDistance + 5 )
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	
	function BaseCamera:BindAction(actionName, actionFunc, createTouchButton, ...)
		table.insert(self.boundContextActions, actionName)
		ContextActionService:BindActionAtPriority(actionName, actionFunc, createTouchButton,
			CAMERA_ACTION_PRIORITY, ...)
	end
	
	function BaseCamera:BindGamepadInputActions()
		self:BindAction("BaseCameraGamepadPan", function(name, state, input) return self:GetGamepadPan(name, state, input) end,
			false, Enum.KeyCode.Thumbstick2)
		self:BindAction("BaseCameraGamepadZoom", function(name, state, input) return self:DoGamepadZoom(name, state, input) end,
			false, Enum.KeyCode.DPadLeft, Enum.KeyCode.DPadRight, Enum.KeyCode.ButtonR3)
	end
	
	function BaseCamera:BindKeyboardInputActions()
		self:BindAction("BaseCameraKeyboardPanArrowKeys", function(name, state, input) return self:DoKeyboardPanTurn(name, state, input) end,
			false, Enum.KeyCode.Left, Enum.KeyCode.Right)
		self:BindAction("BaseCameraKeyboardZoom", function(name, state, input) return self:DoKeyboardZoom(name, state, input) end,
			false, Enum.KeyCode.I, Enum.KeyCode.O)
	end
	
	local function isInDynamicThumbstickArea(input)
		local playerGui = player:FindFirstChildOfClass("PlayerGui")
		local touchGui = playerGui and playerGui:FindFirstChild("TouchGui")
		local touchFrame = touchGui and touchGui:FindFirstChild("TouchControlFrame")
		local thumbstickFrame = touchFrame and touchFrame:FindFirstChild("DynamicThumbstickFrame")
	
		if not thumbstickFrame then
			return false
		end
	
		local frameCornerTopLeft = thumbstickFrame.AbsolutePosition
		local frameCornerBottomRight = frameCornerTopLeft + thumbstickFrame.AbsoluteSize
		if input.Position.X >= frameCornerTopLeft.X and input.Position.Y >= frameCornerTopLeft.Y then
			if input.Position.X <= frameCornerBottomRight.X and input.Position.Y <= frameCornerBottomRight.Y then
				return true
			end
		end
	
		return false
	end
	
	---Adjusts the camera Y touch Sensitivity when moving away from the center and in the TOUCH_SENSITIVTY_ADJUST_AREA
	function BaseCamera:AdjustTouchSensitivity(delta, sensitivity)
		local cameraCFrame = game.Workspace.CurrentCamera and game.Workspace.CurrentCamera.CFrame
		if not cameraCFrame then
			return sensitivity
		end
		local currPitchAngle = cameraCFrame:ToEulerAnglesYXZ()
	
		local multiplierY = TOUCH_SENSITIVTY_ADJUST_MAX_Y
		if currPitchAngle > TOUCH_ADJUST_AREA_UP and delta.Y < 0 then
			local fractionAdjust = (currPitchAngle - TOUCH_ADJUST_AREA_UP)/(MAX_Y - TOUCH_ADJUST_AREA_UP)
			fractionAdjust = 1 - (1 - fractionAdjust)^3
			multiplierY = TOUCH_SENSITIVTY_ADJUST_MAX_Y - fractionAdjust * (
				TOUCH_SENSITIVTY_ADJUST_MAX_Y - TOUCH_SENSITIVTY_ADJUST_MIN_Y)
		elseif currPitchAngle < TOUCH_ADJUST_AREA_DOWN and delta.Y > 0 then
			local fractionAdjust = (currPitchAngle - TOUCH_ADJUST_AREA_DOWN)/(MIN_Y - TOUCH_ADJUST_AREA_DOWN)
			fractionAdjust = 1 - (1 - fractionAdjust)^3
			multiplierY = TOUCH_SENSITIVTY_ADJUST_MAX_Y - fractionAdjust * (
				TOUCH_SENSITIVTY_ADJUST_MAX_Y - TOUCH_SENSITIVTY_ADJUST_MIN_Y)
		end
	
		return Vector2.new(
			sensitivity.X,
			sensitivity.Y * multiplierY
		)
	end
	
	function BaseCamera:OnTouchBegan(input, processed)
		local canUseDynamicTouch = self.isDynamicThumbstickEnabled and not processed
		if canUseDynamicTouch then
			if self.dynamicTouchInput == nil and isInDynamicThumbstickArea(input) then
				-- First input in the dynamic thumbstick area should always be ignored for camera purposes
				-- Even if the dynamic thumbstick does not process it immediately
				self.dynamicTouchInput = input
				return
			end
			self.fingerTouches[input] = processed
			self.inputStartPositions[input] = input.Position
			self.inputStartTimes[input] = tick()
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end
	
	function BaseCamera:OnTouchChanged(input, processed)
		if self.fingerTouches[input] == nil then
			if self.isDynamicThumbstickEnabled then
				return
			end
			self.fingerTouches[input] = processed
			if not processed then
				self.numUnsunkTouches = self.numUnsunkTouches + 1
			end
		end
	
		if self.numUnsunkTouches == 1 then
			if self.fingerTouches[input] == false then
				self.panBeginLook = self.panBeginLook or self:GetCameraLookVector()
				self.startPos = self.startPos or input.Position
				self.lastPos = self.lastPos or self.startPos
				self.userPanningTheCamera = true
	
				local delta = input.Position - self.lastPos
				delta = Vector2.new(delta.X, delta.Y * UserGameSettings:GetCameraYInvertValue())
				if self.panEnabled then
					local adjustedTouchSensitivity = TOUCH_SENSITIVTY
					self:AdjustTouchSensitivity(delta, TOUCH_SENSITIVTY)
	
					local desiredXYVector = self:InputTranslationToCameraAngleChange(delta, adjustedTouchSensitivity)
					self.rotateInput = self.rotateInput + desiredXYVector
				end
				self.lastPos = input.Position
			end
		else
			self.panBeginLook = nil
			self.startPos = nil
			self.lastPos = nil
			self.userPanningTheCamera = false
		end
		if self.numUnsunkTouches == 2 then
			local unsunkTouches = {}
			for touch, wasSunk in pairs(self.fingerTouches) do
				if not wasSunk then
					table.insert(unsunkTouches, touch)
				end
			end
			if #unsunkTouches == 2 then
				local difference = (unsunkTouches[1].Position - unsunkTouches[2].Position).magnitude
				if self.startingDiff and self.pinchBeginZoom then
					local scale = difference / math.max(0.01, self.startingDiff)
					local clampedScale = math.clamp(scale, 0.1, 10)
					if self.distanceChangeEnabled then
						self:SetCameraToSubjectDistance(self.pinchBeginZoom / clampedScale)
					end
				else
					self.startingDiff = difference
					self.pinchBeginZoom = self:GetCameraToSubjectDistance()
				end
			end
		else
			self.startingDiff = nil
			self.pinchBeginZoom = nil
		end
	end
	
	function BaseCamera:OnTouchEnded(input, processed)
		if input == self.dynamicTouchInput then
			self.dynamicTouchInput = nil
			return
		end
	
		if self.fingerTouches[input] == false then
			if self.numUnsunkTouches == 1 then
				self.panBeginLook = nil
				self.startPos = nil
				self.lastPos = nil
				self.userPanningTheCamera = false
			elseif self.numUnsunkTouches == 2 then
				self.startingDiff = nil
				self.pinchBeginZoom = nil
			end
		end
	
		if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
			self.numUnsunkTouches = self.numUnsunkTouches - 1
		end
		self.fingerTouches[input] = nil
		self.inputStartPositions[input] = nil
		self.inputStartTimes[input] = nil
	end
	
	function BaseCamera:OnMouse2Down(input, processed)
		if processed then return end
	
		self.isRightMouseDown = true
		self:OnMousePanButtonPressed(input, processed)
	end
	
	function BaseCamera:OnMouse2Up(input, processed)
		self.isRightMouseDown = false
		self:OnMousePanButtonReleased(input, processed)
	end
	
	function BaseCamera:OnMouse3Down(input, processed)
		if processed then return end
	
		self.isMiddleMouseDown = true
		self:OnMousePanButtonPressed(input, processed)
	end
	
	function BaseCamera:OnMouse3Up(input, processed)
		self.isMiddleMouseDown = false
		self:OnMousePanButtonReleased(input, processed)
	end
	
	function BaseCamera:OnMouseMoved(input, processed)
		if not self.hasGameLoaded and VRService.VREnabled then
			return
		end
	
		local inputDelta = input.Delta
		inputDelta = Vector2.new(inputDelta.X, inputDelta.Y * UserGameSettings:GetCameraYInvertValue())
	
		local isInputPanning = FFlagUserCameraToggle and CameraInput.getPanning()
		local isBeginLook = self.startPos and self.lastPos and self.panBeginLook
		local isPanning = isBeginLook or self.inFirstPerson or self.inMouseLockedMode or isInputPanning
	
		if self.panEnabled and isPanning then
			local desiredXYVector = self:InputTranslationToCameraAngleChange(inputDelta, MOUSE_SENSITIVITY)
			self.rotateInput = self.rotateInput + desiredXYVector
		end
	
		if self.startPos and self.lastPos and self.panBeginLook then
			self.lastPos = self.lastPos + input.Delta
		end
	end
	
	function BaseCamera:OnMousePanButtonPressed(input, processed)
		if processed then return end
		if not FFlagUserCameraToggle then
			self:UpdateMouseBehavior()
		end
		self.panBeginLook = self.panBeginLook or self:GetCameraLookVector()
		self.startPos = self.startPos or input.Position
		self.lastPos = self.lastPos or self.startPos
		self.userPanningTheCamera = true
	end
	
	function BaseCamera:OnMousePanButtonReleased(input, processed)
		if not FFlagUserCameraToggle then
			self:UpdateMouseBehavior()
		end
		if not (self.isRightMouseDown or self.isMiddleMouseDown) then
			self.panBeginLook = nil
			self.startPos = nil
			self.lastPos = nil
			self.userPanningTheCamera = false
		end
	end
	
	function BaseCamera:UpdateMouseBehavior()
		if FFlagUserCameraToggle and self.isCameraToggle then
			CameraUI.setCameraModeToastEnabled(true)
			CameraInput.enableCameraToggleInput()
			CameraToggleStateController(self.inFirstPerson)
		else
			if FFlagUserCameraToggle then
				CameraUI.setCameraModeToastEnabled(false)
				CameraInput.disableCameraToggleInput()
			end
			-- first time transition to first person mode or mouse-locked third person
			if self.inFirstPerson or self.inMouseLockedMode then
				--UserGameSettings.RotationType = Enum.RotationType.CameraRelative
				UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
			else
				UserGameSettings.RotationType = Enum.RotationType.MovementRelative
				if self.isRightMouseDown or self.isMiddleMouseDown then
					UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
				else
					UserInputService.MouseBehavior = Enum.MouseBehavior.Default
				end
			end
		end
	end
	
	function BaseCamera:UpdateForDistancePropertyChange()
		-- Calling this setter with the current value will force checking that it is still
		-- in range after a change to the min/max distance limits
		self:SetCameraToSubjectDistance(self.currentSubjectDistance)
	end
	
	function BaseCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
		local lastSubjectDistance = self.currentSubjectDistance
	
		-- By default, camera modules will respect LockFirstPerson and override the currentSubjectDistance with 0
		-- regardless of what Player.CameraMinZoomDistance is set to, so that first person can be made
		-- available by the developer without needing to allow players to mousewheel dolly into first person.
		-- Some modules will override this function to remove or change first-person capability.
		if player.CameraMode == Enum.CameraMode.LockFirstPerson then
			self.currentSubjectDistance = 0.5
			if not self.inFirstPerson then
				self:EnterFirstPerson()
			end
		else
			local newSubjectDistance = math.clamp(desiredSubjectDistance, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
			if newSubjectDistance < FIRST_PERSON_DISTANCE_THRESHOLD then
				self.currentSubjectDistance = 0.5
				if not self.inFirstPerson then
					self:EnterFirstPerson()
				end
			else
				self.currentSubjectDistance = newSubjectDistance
				if self.inFirstPerson then
					self:LeaveFirstPerson()
				end
			end
		end
	
		-- Pass target distance and zoom direction to the zoom controller
		ZoomController.SetZoomParameters(self.currentSubjectDistance, math.sign(desiredSubjectDistance - lastSubjectDistance))
	
		-- Returned only for convenience to the caller to know the outcome
		return self.currentSubjectDistance
	end
	
	function BaseCamera:SetCameraType( cameraType )
		--Used by derived classes
		self.cameraType = cameraType
	end
	
	function BaseCamera:GetCameraType()
		return self.cameraType
	end
	
	-- Movement mode standardized to Enum.ComputerCameraMovementMode values
	function BaseCamera:SetCameraMovementMode( cameraMovementMode )
		self.cameraMovementMode = cameraMovementMode
	end
	
	function BaseCamera:GetCameraMovementMode()
		return self.cameraMovementMode
	end
	
	function BaseCamera:SetIsMouseLocked(mouseLocked)
		self.inMouseLockedMode = mouseLocked
		if not FFlagUserCameraToggle then
			self:UpdateMouseBehavior()
		end
	end
	
	function BaseCamera:GetIsMouseLocked()
		return self.inMouseLockedMode
	end
	
	function BaseCamera:SetMouseLockOffset(offsetVector)
		self.mouseLockOffset = offsetVector
	end
	
	function BaseCamera:GetMouseLockOffset()
		return self.mouseLockOffset
	end
	
	function BaseCamera:InFirstPerson()
		return self.inFirstPerson
	end
	
	function BaseCamera:EnterFirstPerson()
		-- Overridden in ClassicCamera, the only module which supports FirstPerson
	end
	
	function BaseCamera:LeaveFirstPerson()
		-- Overridden in ClassicCamera, the only module which supports FirstPerson
	end
	
	-- Nominal distance, set by dollying in and out with the mouse wheel or equivalent, not measured distance
	function BaseCamera:GetCameraToSubjectDistance()
		return self.currentSubjectDistance
	end
	
	-- Actual measured distance to the camera Focus point, which may be needed in special circumstances, but should
	-- never be used as the starting point for updating the nominal camera-to-subject distance (self.currentSubjectDistance)
	-- since that is a desired target value set only by mouse wheel (or equivalent) input, PopperCam, and clamped to min max camera distance
	function BaseCamera:GetMeasuredDistanceToFocus()
		local camera = game.Workspace.CurrentCamera
		if camera then
			return (camera.CoordinateFrame.p - camera.Focus.p).magnitude
		end
		return nil
	end
	
	function BaseCamera:GetCameraLookVector()
		return game.Workspace.CurrentCamera and game.Workspace.CurrentCamera.CFrame.lookVector or UNIT_Z
	end
	
	-- Replacements for RootCamera:RotateCamera() which did not actually rotate the camera
	-- suppliedLookVector is not normally passed in, it's used only by Watch camera
	function BaseCamera:CalculateNewLookCFrame(suppliedLookVector)
		local currLookVector = suppliedLookVector or self:GetCameraLookVector()
		local currPitchAngle = math.asin(currLookVector.y)
		local yTheta = math.clamp(self.rotateInput.y, -MAX_Y + currPitchAngle, -MIN_Y + currPitchAngle)
		local constrainedRotateInput = Vector2.new(self.rotateInput.x, yTheta)
		local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
		local newLookCFrame = CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y,0,0)
		return newLookCFrame
	end
	function BaseCamera:CalculateNewLookVector(suppliedLookVector)
		local newLookCFrame = self:CalculateNewLookCFrame(suppliedLookVector)
		return newLookCFrame.lookVector
	end
	
	function BaseCamera:CalculateNewLookVectorVR()
		local subjectPosition = self:GetSubjectPosition()
		local vecToSubject = (subjectPosition - game.Workspace.CurrentCamera.CFrame.p)
		local currLookVector = (vecToSubject * X1_Y0_Z1).unit
		local vrRotateInput = Vector2.new(self.rotateInput.x, 0)
		local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
		local yawRotatedVector = (CFrame.Angles(0, -vrRotateInput.x, 0) * startCFrame * CFrame.Angles(-vrRotateInput.y,0,0)).lookVector
		return (yawRotatedVector * X1_Y0_Z1).unit
	end
	
	function BaseCamera:GetHumanoid()
		local character = player and player.Character
		if character then
			local resultHumanoid = self.humanoidCache[player]
			if resultHumanoid and resultHumanoid.Parent == character then
				return resultHumanoid
			else
				self.humanoidCache[player] = nil -- Bust Old Cache
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					self.humanoidCache[player] = humanoid
				end
				return humanoid
			end
		end
		return nil
	end
	
	function BaseCamera:GetHumanoidPartToFollow(humanoid, humanoidStateType)
		if humanoidStateType == Enum.HumanoidStateType.Dead then
			local character = humanoid.Parent
			if character then
				return character:FindFirstChild("Head") or humanoid.Torso
			else
				return humanoid.Torso
			end
		else
			return humanoid.Torso
		end
	end
	
	function BaseCamera:UpdateGamepad()
		local gamepadPan = self.gamepadPanningCamera
		if gamepadPan and (self.hasGameLoaded or not VRService.VREnabled) then
			gamepadPan = Util.GamepadLinearToCurve(gamepadPan)
			local currentTime = tick()
			if gamepadPan.X ~= 0 or gamepadPan.Y ~= 0 then
				self.userPanningTheCamera = true
			elseif gamepadPan == ZERO_VECTOR2 then
				self.lastThumbstickRotate = nil
				if self.lastThumbstickPos == ZERO_VECTOR2 then
					self.currentSpeed = 0
				end
			end
	
			local finalConstant = 0
	
			if self.lastThumbstickRotate then
				if VRService.VREnabled then
					self.currentSpeed = self.vrMaxSpeed
				else
					local elapsedTime = (currentTime - self.lastThumbstickRotate) * 10
					self.currentSpeed = self.currentSpeed + (self.maxSpeed * ((elapsedTime*elapsedTime)/self.numOfSeconds))
	
					if self.currentSpeed > self.maxSpeed then self.currentSpeed = self.maxSpeed end
	
					if self.lastVelocity then
						local velocity = (gamepadPan - self.lastThumbstickPos)/(currentTime - self.lastThumbstickRotate)
						local velocityDeltaMag = (velocity - self.lastVelocity).magnitude
	
						if velocityDeltaMag > 12 then
							self.currentSpeed = self.currentSpeed * (20/velocityDeltaMag)
							if self.currentSpeed > self.maxSpeed then self.currentSpeed = self.maxSpeed end
						end
					end
				end
	
				finalConstant = UserGameSettings.GamepadCameraSensitivity * self.currentSpeed
				self.lastVelocity = (gamepadPan - self.lastThumbstickPos)/(currentTime - self.lastThumbstickRotate)
			end
	
			self.lastThumbstickPos = gamepadPan
			self.lastThumbstickRotate = currentTime
	
			return Vector2.new( gamepadPan.X * finalConstant, gamepadPan.Y * finalConstant * self.ySensitivity * UserGameSettings:GetCameraYInvertValue())
		end
	
		return ZERO_VECTOR2
	end
	
	-- [[ VR Support Section ]] --
	
	function BaseCamera:ApplyVRTransform()
		if not VRService.VREnabled then
			return
		end
	
		--we only want this to happen in first person VR
		local rootJoint = self.humanoidRootPart and self.humanoidRootPart:FindFirstChild("RootJoint")
		if not rootJoint then
			return
		end
	
		local cameraSubject = game.Workspace.CurrentCamera.CameraSubject
		local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	
		if self.inFirstPerson and not isInVehicle then
			local vrFrame = VRService:GetUserCFrame(Enum.UserCFrame.Head)
			local vrRotation = vrFrame - vrFrame.p
			rootJoint.C0 = CFrame.new(vrRotation:vectorToObjectSpace(vrFrame.p)) * CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
		else
			rootJoint.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
		end
	end
	
	function BaseCamera:IsInFirstPerson()
		return self.inFirstPerson
	end
	
	function BaseCamera:ShouldUseVRRotation()
		if not VRService.VREnabled then
			return false
		end
	
		if not self.VRRotationIntensityAvailable and tick() - self.lastVRRotationIntensityCheckTime < 1 then
			return false
		end
	
		local success, vrRotationIntensity = pcall(function() return StarterGui:GetCore("VRRotationIntensity") end)
		self.VRRotationIntensityAvailable = success and vrRotationIntensity ~= nil
		self.lastVRRotationIntensityCheckTime = tick()
	
		self.shouldUseVRRotation = success and vrRotationIntensity ~= nil and vrRotationIntensity ~= "Smooth"
	
		return self.shouldUseVRRotation
	end
	
	function BaseCamera:GetVRRotationInput()
		local vrRotateSum = ZERO_VECTOR2
		local success, vrRotationIntensity = pcall(function() return StarterGui:GetCore("VRRotationIntensity") end)
	
		if not success then
			return
		end
	
		local vrGamepadRotation = self.GamepadPanningCamera or ZERO_VECTOR2
		local delayExpired = (tick() - self.lastVRRotationTime) >= self:GetRepeatDelayValue(vrRotationIntensity)
	
		if math.abs(vrGamepadRotation.x) >= self:GetActivateValue() then
			if (delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2]) then
				local sign = 1
				if vrGamepadRotation.x < 0 then
					sign = -1
				end
				vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity) * sign
				self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = true
			end
		elseif math.abs(vrGamepadRotation.x) < self:GetActivateValue() - 0.1 then
			self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = nil
		end
		if self.turningLeft then
			if delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Left] then
				vrRotateSum = vrRotateSum - self:GetRotateAmountValue(vrRotationIntensity)
				self.vrRotateKeyCooldown[Enum.KeyCode.Left] = true
			end
		else
			self.vrRotateKeyCooldown[Enum.KeyCode.Left] = nil
		end
		if self.turningRight then
			if (delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Right]) then
				vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity)
				self.vrRotateKeyCooldown[Enum.KeyCode.Right] = true
			end
		else
			self.vrRotateKeyCooldown[Enum.KeyCode.Right] = nil
		end
	
		if vrRotateSum ~= ZERO_VECTOR2 then
			self.lastVRRotationTime = tick()
		end
	
		return vrRotateSum
	end
	
	function BaseCamera:CancelCameraFreeze(keepConstraints)
		if not keepConstraints then
			self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 1, self.cameraTranslationConstraints.z)
		end
		if self.cameraFrozen then
			self.trackingHumanoid = nil
			self.cameraFrozen = false
		end
	end
	
	function BaseCamera:StartCameraFreeze(subjectPosition, humanoidToTrack)
		if not self.cameraFrozen then
			self.humanoidJumpOrigin = subjectPosition
			self.trackingHumanoid = humanoidToTrack
			self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 0, self.cameraTranslationConstraints.z)
			self.cameraFrozen = true
		end
	end
	
	function BaseCamera:OnNewCameraSubject()
		if self.subjectStateChangedConn then
			self.subjectStateChangedConn:Disconnect()
			self.subjectStateChangedConn = nil
		end
	
		local humanoid = workspace.CurrentCamera and workspace.CurrentCamera.CameraSubject
		if self.trackingHumanoid ~= humanoid then
			self:CancelCameraFreeze()
		end
		if humanoid and humanoid:IsA("Humanoid") then
			self.subjectStateChangedConn = humanoid.StateChanged:Connect(function(oldState, newState)
				if VRService.VREnabled and newState == Enum.HumanoidStateType.Jumping and not self.inFirstPerson then
					self:StartCameraFreeze(self:GetSubjectPosition(), humanoid)
				elseif newState ~= Enum.HumanoidStateType.Jumping and newState ~= Enum.HumanoidStateType.Freefall then
					self:CancelCameraFreeze(true)
				end
			end)
		end
	end
	
	function BaseCamera:GetVRFocus(subjectPosition, timeDelta)
		local lastFocus = self.LastCameraFocus or subjectPosition
		if not self.cameraFrozen then
			self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, math.min(1, self.cameraTranslationConstraints.y + 0.42 * timeDelta), self.cameraTranslationConstraints.z)
		end
	
		local newFocus
		if self.cameraFrozen and self.humanoidJumpOrigin and self.humanoidJumpOrigin.y > lastFocus.y then
			newFocus = CFrame.new(Vector3.new(subjectPosition.x, math.min(self.humanoidJumpOrigin.y, lastFocus.y + 5 * timeDelta), subjectPosition.z))
		else
			newFocus = CFrame.new(Vector3.new(subjectPosition.x, lastFocus.y, subjectPosition.z):lerp(subjectPosition, self.cameraTranslationConstraints.y))
		end
	
		if self.cameraFrozen then
			-- No longer in 3rd person
			if self.inFirstPerson then -- not VRService.VREnabled
				self:CancelCameraFreeze()
			end
			-- This case you jumped off a cliff and want to keep your character in view
			-- 0.5 is to fix floating point error when not jumping off cliffs
			if self.humanoidJumpOrigin and subjectPosition.y < (self.humanoidJumpOrigin.y - 0.5) then
				self:CancelCameraFreeze()
			end
		end
	
		return newFocus
	end
	
	function BaseCamera:GetRotateAmountValue(vrRotationIntensity)
		vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
		if vrRotationIntensity then
			if vrRotationIntensity == "Low" then
				return VR_LOW_INTENSITY_ROTATION
			elseif vrRotationIntensity == "High" then
				return VR_HIGH_INTENSITY_ROTATION
			end
		end
		return ZERO_VECTOR2
	end
	
	function BaseCamera:GetRepeatDelayValue(vrRotationIntensity)
		vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
		if vrRotationIntensity then
			if vrRotationIntensity == "Low" then
				return VR_LOW_INTENSITY_REPEAT
			elseif vrRotationIntensity == "High" then
				return VR_HIGH_INTENSITY_REPEAT
			end
		end
		return 0
	end
	
	function BaseCamera:Update(dt)
		error("BaseCamera:Update() This is a virtual function that should never be getting called.", 2)
	end
	
	BaseCamera.UpCFrame = CFrame.new()
	
	function BaseCamera:UpdateUpCFrame(cf)
		self.UpCFrame = cf
	end
	local ZERO = Vector3.new(0, 0, 0)
	function BaseCamera:CalculateNewLookCFrame(suppliedLookVector)
		local currLookVector = suppliedLookVector or self:GetCameraLookVector()
		currLookVector = self.UpCFrame:VectorToObjectSpace(currLookVector)
		
		local currPitchAngle = math.asin(currLookVector.y)
		local yTheta = math.clamp(self.rotateInput.y, -MAX_Y + currPitchAngle, -MIN_Y + currPitchAngle)
		local constrainedRotateInput = Vector2.new(self.rotateInput.x, yTheta)
		local startCFrame = CFrame.new(ZERO, currLookVector)
		local newLookCFrame = CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y,0,0)
		
		return newLookCFrame
	end
	
	return BaseCamera
end

function _BaseOcclusion()
	--[[ The Module ]]--
	local BaseOcclusion = {}
	BaseOcclusion.__index = BaseOcclusion
	setmetatable(BaseOcclusion, {
		__call = function(_, ...)
			return BaseOcclusion.new(...)
		end
	})
	
	function BaseOcclusion.new()
		local self = setmetatable({}, BaseOcclusion)
		return self
	end
	
	-- Called when character is added
	function BaseOcclusion:CharacterAdded(char, player)
	end
	
	-- Called when character is about to be removed
	function BaseOcclusion:CharacterRemoving(char, player)
	end
	
	function BaseOcclusion:OnCameraSubjectChanged(newSubject)
	end
	
	--[[ Derived classes are required to override and implement all of the following functions ]]--
	function BaseOcclusion:GetOcclusionMode()
		-- Must be overridden in derived classes to return an Enum.DevCameraOcclusionMode value
		warn("BaseOcclusion GetOcclusionMode must be overridden by derived classes")
		return nil
	end
	
	function BaseOcclusion:Enable(enabled)
		warn("BaseOcclusion Enable must be overridden by derived classes")
	end
	
	function BaseOcclusion:Update(dt, desiredCameraCFrame, desiredCameraFocus)
		warn("BaseOcclusion Update must be overridden by derived classes")
		return desiredCameraCFrame, desiredCameraFocus
	end
	
	return BaseOcclusion
end

function _Popper()
	
	local Players = game:GetService("Players")
	
	local camera = game.Workspace.CurrentCamera
	
	local min = math.min
	local tan = math.tan
	local rad = math.rad
	local inf = math.huge
	local ray = Ray.new
	
	local function getTotalTransparency(part)
		return 1 - (1 - part.Transparency)*(1 - part.LocalTransparencyModifier)
	end
	
	local function eraseFromEnd(t, toSize)
		for i = #t, toSize + 1, -1 do
			t[i] = nil
		end
	end
	
	local nearPlaneZ, projX, projY do
		local function updateProjection()
			local fov = rad(camera.FieldOfView)
			local view = camera.ViewportSize
			local ar = view.X/view.Y
	
			projY = 2*tan(fov/2)
			projX = ar*projY
		end
	
		camera:GetPropertyChangedSignal("FieldOfView"):Connect(updateProjection)
		camera:GetPropertyChangedSignal("ViewportSize"):Connect(updateProjection)
	
		updateProjection()
	
		nearPlaneZ = camera.NearPlaneZ
		camera:GetPropertyChangedSignal("NearPlaneZ"):Connect(function()
			nearPlaneZ = camera.NearPlaneZ
		end)
	end
	
	local blacklist = {} do
		local charMap = {}
	
		local function refreshIgnoreList()
			local n = 1
			blacklist = {}
			for _, character in pairs(charMap) do
				blacklist[n] = character
				n = n + 1
			end
		end
	
		local function playerAdded(player)
			local function characterAdded(character)
				charMap[player] = character
				refreshIgnoreList()
			end
			local function characterRemoving()
				charMap[player] = nil
				refreshIgnoreList()
			end
	
			player.CharacterAdded:Connect(characterAdded)
			player.CharacterRemoving:Connect(characterRemoving)
			if player.Character then
				characterAdded(player.Character)
			end
		end
	
		local function playerRemoving(player)
			charMap[player] = nil
			refreshIgnoreList()
		end
	
		Players.PlayerAdded:Connect(playerAdded)
		Players.PlayerRemoving:Connect(playerRemoving)
	
		for _, player in ipairs(Players:GetPlayers()) do
			playerAdded(player)
		end
		refreshIgnoreList()
	end
	
	--------------------------------------------------------------------------------------------
	-- Popper uses the level geometry find an upper bound on subject-to-camera distance.
	--
	-- Hard limits are applied immediately and unconditionally. They are generally caused
	-- when level geometry intersects with the near plane (with exceptions, see below).
	--
	-- Soft limits are only applied under certain conditions.
	-- They are caused when level geometry occludes the subject without actually intersecting
	-- with the near plane at the target distance.
	--
	-- Soft limits can be promoted to hard limits and hard limits can be demoted to soft limits.
	-- We usually don"t want the latter to happen.
	--
	-- A soft limit will be promoted to a hard limit if an obstruction
	-- lies between the current and target camera positions.
	--------------------------------------------------------------------------------------------
	
	local subjectRoot
	local subjectPart
	
	camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
		local subject = camera.CameraSubject
		if subject:IsA("Humanoid") then
			subjectPart = subject.RootPart
		elseif subject:IsA("BasePart") then
			subjectPart = subject
		else
			subjectPart = nil
		end
	end)
	
	local function canOcclude(part)
		-- Occluders must be:
		-- 1. Opaque
		-- 2. Interactable
		-- 3. Not in the same assembly as the subject
	
		return
			getTotalTransparency(part) < 0.25 and
			part.CanCollide and
			subjectRoot ~= (part:GetRootPart() or part) and
			not part:IsA("TrussPart")
	end
	
	-- Offsets for the volume visibility test
	local SCAN_SAMPLE_OFFSETS = {
		Vector2.new( 0.4, 0.0),
		Vector2.new(-0.4, 0.0),
		Vector2.new( 0.0,-0.4),
		Vector2.new( 0.0, 0.4),
		Vector2.new( 0.0, 0.2),
	}
	
	--------------------------------------------------------------------------------
	-- Piercing raycasts
	
	local function getCollisionPoint(origin, dir)
		local originalSize = #blacklist
		repeat
			local hitPart, hitPoint = workspace:FindPartOnRayWithIgnoreList(
				ray(origin, dir), blacklist, false, true
			)
	
			if hitPart then
				if hitPart.CanCollide then
					eraseFromEnd(blacklist, originalSize)
					return hitPoint, true
				end
				blacklist[#blacklist + 1] = hitPart
			end
		until not hitPart
	
		eraseFromEnd(blacklist, originalSize)
		return origin + dir, false
	end
	
	--------------------------------------------------------------------------------
	
	local function queryPoint(origin, unitDir, dist, lastPos)
		debug.profilebegin("queryPoint")
	
		local originalSize = #blacklist
	
		dist = dist + nearPlaneZ
		local target = origin + unitDir*dist
	
		local softLimit = inf
		local hardLimit = inf
		local movingOrigin = origin
	
		repeat
			local entryPart, entryPos = workspace:FindPartOnRayWithIgnoreList(ray(movingOrigin, target - movingOrigin), blacklist, false, true)
	
			if entryPart then
				if canOcclude(entryPart) then
					local wl = {entryPart}
					local exitPart = workspace:FindPartOnRayWithWhitelist(ray(target, entryPos - target), wl, true)
	
					local lim = (entryPos - origin).Magnitude
	
					if exitPart then
						local promote = false
						if lastPos then
							promote =
								workspace:FindPartOnRayWithWhitelist(ray(lastPos, target - lastPos), wl, true) or
								workspace:FindPartOnRayWithWhitelist(ray(target, lastPos - target), wl, true)
						end
	
						if promote then
							-- Ostensibly a soft limit, but the camera has passed through it in the last frame, so promote to a hard limit.
							hardLimit = lim
						elseif dist < softLimit then
							-- Trivial soft limit
							softLimit = lim
						end
					else
						-- Trivial hard limit
						hardLimit = lim
					end
				end
	
				blacklist[#blacklist + 1] = entryPart
				movingOrigin = entryPos - unitDir*1e-3
			end
		until hardLimit < inf or not entryPart
	
		eraseFromEnd(blacklist, originalSize)
	
		debug.profileend()
		return softLimit - nearPlaneZ, hardLimit - nearPlaneZ
	end
	
	local function queryViewport(focus, dist)
		debug.profilebegin("queryViewport")
	
		local fP =  focus.p
		local fX =  focus.rightVector
		local fY =  focus.upVector
		local fZ = -focus.lookVector
	
		local viewport = camera.ViewportSize
	
		local hardBoxLimit = inf
		local softBoxLimit = inf
	
		-- Center the viewport on the PoI, sweep points on the edge towards the target, and take the minimum limits
		for viewX = 0, 1 do
			local worldX = fX*((viewX - 0.5)*projX)
	
			for viewY = 0, 1 do
				local worldY = fY*((viewY - 0.5)*projY)
	
				local origin = fP + nearPlaneZ*(worldX + worldY)
				local lastPos = camera:ViewportPointToRay(
					viewport.x*viewX,
					viewport.y*viewY
				).Origin
	
				local softPointLimit, hardPointLimit = queryPoint(origin, fZ, dist, lastPos)
	
				if hardPointLimit < hardBoxLimit then
					hardBoxLimit = hardPointLimit
				end
				if softPointLimit < softBoxLimit then
					softBoxLimit = softPointLimit
				end
			end
		end
		debug.profileend()
	
		return softBoxLimit, hardBoxLimit
	end
	
	local function testPromotion(focus, dist, focusExtrapolation)
		debug.profilebegin("testPromotion")
	
		local fP = focus.p
		local fX = focus.rightVector
		local fY = focus.upVector
		local fZ = -focus.lookVector
	
		do
			-- Dead reckoning the camera rotation and focus
			debug.profilebegin("extrapolate")
	
			local SAMPLE_DT = 0.0625
			local SAMPLE_MAX_T = 1.25
	
			local maxDist = (getCollisionPoint(fP, focusExtrapolation.posVelocity*SAMPLE_MAX_T) - fP).Magnitude
			-- Metric that decides how many samples to take
			local combinedSpeed = focusExtrapolation.posVelocity.magnitude
	
			for dt = 0, min(SAMPLE_MAX_T, focusExtrapolation.rotVelocity.magnitude + maxDist/combinedSpeed), SAMPLE_DT do
				local cfDt = focusExtrapolation.extrapolate(dt) -- Extrapolated CFrame at time dt
	
				if queryPoint(cfDt.p, -cfDt.lookVector, dist) >= dist then
					return false
				end
			end
	
			debug.profileend()
		end
	
		do
			-- Test screen-space offsets from the focus for the presence of soft limits
			debug.profilebegin("testOffsets")
	
			for _, offset in ipairs(SCAN_SAMPLE_OFFSETS) do
				local scaledOffset = offset
				local pos = getCollisionPoint(fP, fX*scaledOffset.x + fY*scaledOffset.y)
				if queryPoint(pos, (fP + fZ*dist - pos).Unit, dist) == inf then
					return false
				end
			end
	
			debug.profileend()
		end
	
		debug.profileend()
		return true
	end
	
	local function Popper(focus, targetDist, focusExtrapolation)
		debug.profilebegin("popper")
	
		subjectRoot = subjectPart and subjectPart:GetRootPart() or subjectPart
	
		local dist = targetDist
		local soft, hard = queryViewport(focus, targetDist)
		if hard < dist then
			dist = hard
		end
		if soft < dist and testPromotion(focus, targetDist, focusExtrapolation) then
			dist = soft
		end
	
		subjectRoot = nil
	
		debug.profileend()
		return dist
	end
	
	return Popper
end

function _ZoomController()
	local ZOOM_STIFFNESS = 4.5
	local ZOOM_DEFAULT = 12.5
	local ZOOM_ACCELERATION = 0.0375
	
	local MIN_FOCUS_DIST = 0.5
	local DIST_OPAQUE = 1
	
	local Popper = _Popper()
	
	local clamp = math.clamp
	local exp = math.exp
	local min = math.min
	local max = math.max
	local pi = math.pi
	
	local cameraMinZoomDistance, cameraMaxZoomDistance do
		local Player = game:GetService("Players").LocalPlayer
	
		local function updateBounds()
			cameraMinZoomDistance = Player.CameraMinZoomDistance
			cameraMaxZoomDistance = Player.CameraMaxZoomDistance
		end
	
		updateBounds()
	
		Player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(updateBounds)
		Player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(updateBounds)
	end
	
	local ConstrainedSpring = {} do
		ConstrainedSpring.__index = ConstrainedSpring
	
		function ConstrainedSpring.new(freq, x, minValue, maxValue)
			x = clamp(x, minValue, maxValue)
			return setmetatable({
				freq = freq, -- Undamped frequency (Hz)
				x = x, -- Current position
				v = 0, -- Current velocity
				minValue = minValue, -- Minimum bound
				maxValue = maxValue, -- Maximum bound
				goal = x, -- Goal position
			}, ConstrainedSpring)
		end
	
		function ConstrainedSpring:Step(dt)
			local freq = self.freq*2*pi -- Convert from Hz to rad/s
			local x = self.x
			local v = self.v
			local minValue = self.minValue
			local maxValue = self.maxValue
			local goal = self.goal
	
			-- Solve the spring ODE for position and velocity after time t, assuming critical damping:
			--   2*f*x'[t] + x''[t] = f^2*(g - x[t])
			-- Knowns are x[0] and x'[0].
			-- Solve for x[t] and x'[t].
	
			local offset = goal - x
			local step = freq*dt
			local decay = exp(-step)
	
			local x1 = goal + (v*dt - offset*(step + 1))*decay
			local v1 = ((offset*freq - v)*step + v)*decay
	
			-- Constrain
			if x1 < minValue then
				x1 = minValue
				v1 = 0
			elseif x1 > maxValue then
				x1 = maxValue
				v1 = 0
			end
	
			self.x = x1
			self.v = v1
	
			return x1
		end
	end
	
	local zoomSpring = ConstrainedSpring.new(ZOOM_STIFFNESS, ZOOM_DEFAULT, MIN_FOCUS_DIST, cameraMaxZoomDistance)
	
	local function stepTargetZoom(z, dz, zoomMin, zoomMax)
		z = clamp(z + dz*(1 + z*ZOOM_ACCELERATION), zoomMin, zoomMax)
		if z < DIST_OPAQUE then
			z = dz <= 0 and zoomMin or DIST_OPAQUE
		end
		return z
	end
	
	local zoomDelta = 0
	
	local Zoom = {} do
		function Zoom.Update(renderDt, focus, extrapolation)
			local poppedZoom = math.huge
	
			if zoomSpring.goal > DIST_OPAQUE then
				-- Make a pessimistic estimate of zoom distance for this step without accounting for poppercam
				local maxPossibleZoom = max(
					zoomSpring.x,
					stepTargetZoom(zoomSpring.goal, zoomDelta, cameraMinZoomDistance, cameraMaxZoomDistance)
				)
	
				-- Run the Popper algorithm on the feasible zoom range, [MIN_FOCUS_DIST, maxPossibleZoom]
				poppedZoom = Popper(
					focus*CFrame.new(0, 0, MIN_FOCUS_DIST),
					maxPossibleZoom - MIN_FOCUS_DIST,
					extrapolation
				) + MIN_FOCUS_DIST
			end
	
			zoomSpring.minValue = MIN_FOCUS_DIST
			zoomSpring.maxValue = min(cameraMaxZoomDistance, poppedZoom)
	
			return zoomSpring:Step(renderDt)
		end
	
		function Zoom.SetZoomParameters(targetZoom, newZoomDelta)
			zoomSpring.goal = targetZoom
			zoomDelta = newZoomDelta
		end
	end
	
	return Zoom
end

function _MouseLockController()
	--[[ Constants ]]--
	local DEFAULT_MOUSE_LOCK_CURSOR = "rbxasset://textures/MouseLockedCursor.png"
	
	local CONTEXT_ACTION_NAME = "MouseLockSwitchAction"
	local MOUSELOCK_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
	
	--[[ Services ]]--
	local PlayersService = game:GetService("Players")
	local ContextActionService = game:GetService("ContextActionService")
	local Settings = UserSettings()	-- ignore warning
	local GameSettings = Settings.GameSettings
	local Mouse = PlayersService.LocalPlayer:GetMouse()
	
	--[[ The Module ]]--
	local MouseLockController = {}
	MouseLockController.__index = MouseLockController
	
	function MouseLockController.new()
		local self = setmetatable({}, MouseLockController)
	
		self.isMouseLocked = false
		self.savedMouseCursor = nil
		self.boundKeys = {Enum.KeyCode.LeftShift, Enum.KeyCode.RightShift} -- defaults
	
		self.mouseLockToggledEvent = Instance.new("BindableEvent")
	
		local boundKeysObj = script:FindFirstChild("BoundKeys")
		if (not boundKeysObj) or (not boundKeysObj:IsA("StringValue")) then
			-- If object with correct name was found, but it's not a StringValue, destroy and replace
			if boundKeysObj then
				boundKeysObj:Destroy()
			end
	
			boundKeysObj = Instance.new("StringValue")
			boundKeysObj.Name = "BoundKeys"
			boundKeysObj.Value = "LeftShift,RightShift"
			boundKeysObj.Parent = script
		end
	
		if boundKeysObj then
			boundKeysObj.Changed:Connect(function(value)
				self:OnBoundKeysObjectChanged(value)
			end)
			self:OnBoundKeysObjectChanged(boundKeysObj.Value) -- Initial setup call
		end
	
		-- Watch for changes to user's ControlMode and ComputerMovementMode settings and update the feature availability accordingly
		GameSettings.Changed:Connect(function(property)
			if property == "ControlMode" or property == "ComputerMovementMode" then
				self:UpdateMouseLockAvailability()
			end
		end)
	
		-- Watch for changes to DevEnableMouseLock and update the feature availability accordingly
		PlayersService.LocalPlayer:GetPropertyChangedSignal("DevEnableMouseLock"):Connect(function()
			self:UpdateMouseLockAvailability()
		end)
	
		-- Watch for changes to DevEnableMouseLock and update the feature availability accordingly
		PlayersService.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
			self:UpdateMouseLockAvailability()
		end)
	
		self:UpdateMouseLockAvailability()
	
		return self
	end
	
	function MouseLockController:GetIsMouseLocked()
		return self.isMouseLocked
	end
	
	function MouseLockController:GetBindableToggleEvent()
		return self.mouseLockToggledEvent.Event
	end
	
	function MouseLockController:GetMouseLockOffset()
		local offsetValueObj = script:FindFirstChild("CameraOffset")
		if offsetValueObj and offsetValueObj:IsA("Vector3Value") then
			return offsetValueObj.Value
		else
			-- If CameraOffset object was found but not correct type, destroy
			if offsetValueObj then
				offsetValueObj:Destroy()
			end
			offsetValueObj = Instance.new("Vector3Value")
			offsetValueObj.Name = "CameraOffset"
			offsetValueObj.Value = Vector3.new(1.75,0,0) -- Legacy Default Value
			offsetValueObj.Parent = script
		end
	
		if offsetValueObj and offsetValueObj.Value then
			return offsetValueObj.Value
		end
	
		return Vector3.new(1.75,0,0)
	end
	
	function MouseLockController:UpdateMouseLockAvailability()
		local devAllowsMouseLock = PlayersService.LocalPlayer.DevEnableMouseLock
		local devMovementModeIsScriptable = PlayersService.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.Scriptable
		local userHasMouseLockModeEnabled = GameSettings.ControlMode == Enum.ControlMode.MouseLockSwitch
		local userHasClickToMoveEnabled =  GameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove
		local MouseLockAvailable = devAllowsMouseLock and userHasMouseLockModeEnabled and not userHasClickToMoveEnabled and not devMovementModeIsScriptable
	
		if MouseLockAvailable~=self.enabled then
			self:EnableMouseLock(MouseLockAvailable)
		end
	end
	
	function MouseLockController:OnBoundKeysObjectChanged(newValue)
		self.boundKeys = {} -- Overriding defaults, note: possibly with nothing at all if boundKeysObj.Value is "" or contains invalid values
		for token in string.gmatch(newValue,"[^%s,]+") do
			for _, keyEnum in pairs(Enum.KeyCode:GetEnumItems()) do
				if token == keyEnum.Name then
					self.boundKeys[#self.boundKeys+1] = keyEnum
					break
				end
			end
		end
		self:UnbindContextActions()
		self:BindContextActions()
	end
	
	--[[ Local Functions ]]--
	function MouseLockController:OnMouseLockToggled()
		self.isMouseLocked = not self.isMouseLocked
	
		if self.isMouseLocked then
			local cursorImageValueObj = script:FindFirstChild("CursorImage")
			if cursorImageValueObj and cursorImageValueObj:IsA("StringValue") and cursorImageValueObj.Value then
				self.savedMouseCursor = Mouse.Icon
				Mouse.Icon = cursorImageValueObj.Value
			else
				if cursorImageValueObj then
					cursorImageValueObj:Destroy()
				end
				cursorImageValueObj = Instance.new("StringValue")
				cursorImageValueObj.Name = "CursorImage"
				cursorImageValueObj.Value = DEFAULT_MOUSE_LOCK_CURSOR
				cursorImageValueObj.Parent = script
				self.savedMouseCursor = Mouse.Icon
				Mouse.Icon = DEFAULT_MOUSE_LOCK_CURSOR
			end
		else
			if self.savedMouseCursor then
				Mouse.Icon = self.savedMouseCursor
				self.savedMouseCursor = nil
			end
		end
	
		self.mouseLockToggledEvent:Fire()
	end
	
	function MouseLockController:DoMouseLockSwitch(name, state, input)
		if state == Enum.UserInputState.Begin then
			self:OnMouseLockToggled()
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	
	function MouseLockController:BindContextActions()
		ContextActionService:BindActionAtPriority(CONTEXT_ACTION_NAME, function(name, state, input)
			return self:DoMouseLockSwitch(name, state, input)
		end, false, MOUSELOCK_ACTION_PRIORITY, unpack(self.boundKeys))
	end
	
	function MouseLockController:UnbindContextActions()
		ContextActionService:UnbindAction(CONTEXT_ACTION_NAME)
	end
	
	function MouseLockController:IsMouseLocked()
		return self.enabled and self.isMouseLocked
	end
	
	function MouseLockController:EnableMouseLock(enable)
		if enable ~= self.enabled then
	
			self.enabled = enable
	
			if self.enabled then
				-- Enabling the mode
				self:BindContextActions()
			else
				-- Disabling
				-- Restore mouse cursor
				if Mouse.Icon~="" then
					Mouse.Icon = ""
				end
	
				self:UnbindContextActions()
	
				-- If the mode is disabled while being used, fire the event to toggle it off
				if self.isMouseLocked then
					self.mouseLockToggledEvent:Fire()
				end
	
				self.isMouseLocked = false
			end
	
		end
	end
	
	return MouseLockController
end

function _TransparencyController()
	
	local MAX_TWEEN_RATE = 2.8 -- per second
	
	local Util = _CameraUtils()
	
	--[[ The Module ]]--
	local TransparencyController = {}
	TransparencyController.__index = TransparencyController
	
	function TransparencyController.new()
		local self = setmetatable({}, TransparencyController)
	
		self.lastUpdate = tick()
		self.transparencyDirty = false
		self.enabled = false
		self.lastTransparency = nil
	
		self.descendantAddedConn, self.descendantRemovingConn = nil, nil
		self.toolDescendantAddedConns = {}
		self.toolDescendantRemovingConns = {}
		self.cachedParts = {}
	
		return self
	end
	
	
	function TransparencyController:HasToolAncestor(object)
		if object.Parent == nil then return false end
		return object.Parent:IsA('Tool') or self:HasToolAncestor(object.Parent)
	end
	
	function TransparencyController:IsValidPartToModify(part)
		if part:IsA('BasePart') or part:IsA('Decal') then
			return not self:HasToolAncestor(part)
		end
		return false
	end
	
	function TransparencyController:CachePartsRecursive(object)
		if object then
			if self:IsValidPartToModify(object) then
				self.cachedParts[object] = true
				self.transparencyDirty = true
			end
			for _, child in pairs(object:GetChildren()) do
				self:CachePartsRecursive(child)
			end
		end
	end
	
	function TransparencyController:TeardownTransparency()
		for child, _ in pairs(self.cachedParts) do
			child.LocalTransparencyModifier = 0
		end
		self.cachedParts = {}
		self.transparencyDirty = true
		self.lastTransparency = nil
	
		if self.descendantAddedConn then
			self.descendantAddedConn:disconnect()
			self.descendantAddedConn = nil
		end
		if self.descendantRemovingConn then
			self.descendantRemovingConn:disconnect()
			self.descendantRemovingConn = nil
		end
		for object, conn in pairs(self.toolDescendantAddedConns) do
			conn:Disconnect()
			self.toolDescendantAddedConns[object] = nil
		end
		for object, conn in pairs(self.toolDescendantRemovingConns) do
			conn:Disconnect()
			self.toolDescendantRemovingConns[object] = nil
		end
	end
	
	function TransparencyController:SetupTransparency(character)
		self:TeardownTransparency()
	
		if self.descendantAddedConn then self.descendantAddedConn:disconnect() end
		self.descendantAddedConn = character.DescendantAdded:Connect(function(object)
			-- This is a part we want to invisify
			if self:IsValidPartToModify(object) then
				self.cachedParts[object] = true
				self.transparencyDirty = true
			-- There is now a tool under the character
			elseif object:IsA('Tool') then
				if self.toolDescendantAddedConns[object] then self.toolDescendantAddedConns[object]:Disconnect() end
				self.toolDescendantAddedConns[object] = object.DescendantAdded:Connect(function(toolChild)
					self.cachedParts[toolChild] = nil
					if toolChild:IsA('BasePart') or toolChild:IsA('Decal') then
						-- Reset the transparency
						toolChild.LocalTransparencyModifier = 0
					end
				end)
				if self.toolDescendantRemovingConns[object] then self.toolDescendantRemovingConns[object]:disconnect() end
				self.toolDescendantRemovingConns[object] = object.DescendantRemoving:Connect(function(formerToolChild)
					wait() -- wait for new parent
					if character and formerToolChild and formerToolChild:IsDescendantOf(character) then
						if self:IsValidPartToModify(formerToolChild) then
							self.cachedParts[formerToolChild] = true
							self.transparencyDirty = true
						end
					end
				end)
			end
		end)
		if self.descendantRemovingConn then self.descendantRemovingConn:disconnect() end
		self.descendantRemovingConn = character.DescendantRemoving:connect(function(object)
			if self.cachedParts[object] then
				self.cachedParts[object] = nil
				-- Reset the transparency
				object.LocalTransparencyModifier = 0
			end
		end)
		self:CachePartsRecursive(character)
	end
	
	
	function TransparencyController:Enable(enable)
		if self.enabled ~= enable then
			self.enabled = enable
			self:Update()
		end
	end
	
	function TransparencyController:SetSubject(subject)
		local character = nil
		if subject and subject:IsA("Humanoid") then
			character = subject.Parent
		end
		if subject and subject:IsA("VehicleSeat") and subject.Occupant then
			character = subject.Occupant.Parent
		end
		if character then
			self:SetupTransparency(character)
		else
			self:TeardownTransparency()
		end
	end
	
	function TransparencyController:Update()
		local instant = false
		local now = tick()
		local currentCamera = workspace.CurrentCamera
	
		if currentCamera then
			local transparency = 0
			if not self.enabled then
				instant = true
			else
				local distance = (currentCamera.Focus.p - currentCamera.CoordinateFrame.p).magnitude
				transparency = (distance<2) and (1.0-(distance-0.5)/1.5) or 0 --(7 - distance) / 5
				if transparency < 0.5 then
					transparency = 0
				end
	
				if self.lastTransparency then
					local deltaTransparency = transparency - self.lastTransparency
	
					-- Don't tween transparency if it is instant or your character was fully invisible last frame
					if not instant and transparency < 1 and self.lastTransparency < 0.95 then
						local maxDelta = MAX_TWEEN_RATE * (now - self.lastUpdate)
						deltaTransparency = math.clamp(deltaTransparency, -maxDelta, maxDelta)
					end
					transparency = self.lastTransparency + deltaTransparency
				else
					self.transparencyDirty = true
				end
	
				transparency = math.clamp(Util.Round(transparency, 2), 0, 1)
			end
	
			if self.transparencyDirty or self.lastTransparency ~= transparency then
				for child, _ in pairs(self.cachedParts) do
					child.LocalTransparencyModifier = transparency
				end
				self.transparencyDirty = false
				self.lastTransparency = transparency
			end
		end
		self.lastUpdate = now
	end
	
	return TransparencyController
end

function _Poppercam()
	local ZoomController =  _ZoomController()
	
	local TransformExtrapolator = {} do
		TransformExtrapolator.__index = TransformExtrapolator
	
		local CF_IDENTITY = CFrame.new()
	
		local function cframeToAxis(cframe)
			local axis, angle = cframe:toAxisAngle()
			return axis*angle
		end
	
		local function axisToCFrame(axis)
			local angle = axis.magnitude
			if angle > 1e-5 then
				return CFrame.fromAxisAngle(axis, angle)
			end
			return CF_IDENTITY
		end
	
		local function extractRotation(cf)
			local _, _, _, xx, yx, zx, xy, yy, zy, xz, yz, zz = cf:components()
			return CFrame.new(0, 0, 0, xx, yx, zx, xy, yy, zy, xz, yz, zz)
		end
	
		function TransformExtrapolator.new()
			return setmetatable({
				lastCFrame = nil,
			}, TransformExtrapolator)
		end
	
		function TransformExtrapolator:Step(dt, currentCFrame)
			local lastCFrame = self.lastCFrame or currentCFrame
			self.lastCFrame = currentCFrame
	
			local currentPos = currentCFrame.p
			local currentRot = extractRotation(currentCFrame)
	
			local lastPos = lastCFrame.p
			local lastRot = extractRotation(lastCFrame)
	
			-- Estimate velocities from the delta between now and the last frame
			-- This estimation can be a little noisy.
			local dp = (currentPos - lastPos)/dt
			local dr = cframeToAxis(currentRot*lastRot:inverse())/dt
	
			local function extrapolate(t)
				local p = dp*t + currentPos
				local r = axisToCFrame(dr*t)*currentRot
				return r + p
			end
	
			return {
				extrapolate = extrapolate,
				posVelocity = dp,
				rotVelocity = dr,
			}
		end
	
		function TransformExtrapolator:Reset()
			self.lastCFrame = nil
		end
	end
	
	--[[ The Module ]]--
	local BaseOcclusion = _BaseOcclusion()
	local Poppercam = setmetatable({}, BaseOcclusion)
	Poppercam.__index = Poppercam
	
	function Poppercam.new()
		local self = setmetatable(BaseOcclusion.new(), Poppercam)
		self.focusExtrapolator = TransformExtrapolator.new()
		return self
	end
	
	function Poppercam:GetOcclusionMode()
		return Enum.DevCameraOcclusionMode.Zoom
	end
	
	function Poppercam:Enable(enable)
		self.focusExtrapolator:Reset()
	end
	
	function Poppercam:Update(renderDt, desiredCameraCFrame, desiredCameraFocus, cameraController)
		local rotatedFocus = CFrame.new(desiredCameraFocus.p, desiredCameraCFrame.p)*CFrame.new(
			0, 0, 0,
			-1, 0, 0,
			0, 1, 0,
			0, 0, -1
		)
		local extrapolation = self.focusExtrapolator:Step(renderDt, rotatedFocus)
		local zoom = ZoomController.Update(renderDt, rotatedFocus, extrapolation)
		return rotatedFocus*CFrame.new(0, 0, zoom), desiredCameraFocus
	end
	
	-- Called when character is added
	function Poppercam:CharacterAdded(character, player)
	end
	
	-- Called when character is about to be removed
	function Poppercam:CharacterRemoving(character, player)
	end
	
	function Poppercam:OnCameraSubjectChanged(newSubject)
	end
	
	local ZoomController = _ZoomController()
	
	function Poppercam:Update(renderDt, desiredCameraCFrame, desiredCameraFocus, cameraController)
		local rotatedFocus = desiredCameraFocus * (desiredCameraCFrame - desiredCameraCFrame.p)
		local extrapolation = self.focusExtrapolator:Step(renderDt, rotatedFocus)
		local zoom = ZoomController.Update(renderDt, rotatedFocus, extrapolation)
		return rotatedFocus*CFrame.new(0, 0, zoom), desiredCameraFocus
	end
	
	return Poppercam
end

function _Invisicam()
	
	--[[ Top Level Roblox Services ]]--
	local PlayersService = game:GetService("Players")
	
	--[[ Constants ]]--
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	local USE_STACKING_TRANSPARENCY = true	-- Multiple items between the subject and camera get transparency values that add up to TARGET_TRANSPARENCY
	local TARGET_TRANSPARENCY = 0.75 -- Classic Invisicam's Value, also used by new invisicam for parts hit by head and torso rays
	local TARGET_TRANSPARENCY_PERIPHERAL = 0.5 -- Used by new SMART_CIRCLE mode for items not hit by head and torso rays
	
	local MODE = {
		--CUSTOM = 1, 		-- Retired, unused
		LIMBS = 2, 			-- Track limbs
		MOVEMENT = 3, 		-- Track movement
		CORNERS = 4, 		-- Char model corners
		CIRCLE1 = 5, 		-- Circle of casts around character
		CIRCLE2 = 6, 		-- Circle of casts around character, camera relative
		LIMBMOVE = 7, 		-- LIMBS mode + MOVEMENT mode
		SMART_CIRCLE = 8, 	-- More sample points on and around character
		CHAR_OUTLINE = 9,	-- Dynamic outline around the character
	}
	
	local LIMB_TRACKING_SET = {
		-- Body parts common to R15 and R6
		['Head'] = true,
	
		-- Body parts unique to R6
		['Left Arm'] = true,
		['Right Arm'] = true,
		['Left Leg'] = true,
		['Right Leg'] = true,
	
		-- Body parts unique to R15
		['LeftLowerArm'] = true,
		['RightLowerArm'] = true,
		['LeftUpperLeg'] = true,
		['RightUpperLeg'] = true
	}
	
	local CORNER_FACTORS = {
		Vector3.new(1,1,-1),
		Vector3.new(1,-1,-1),
		Vector3.new(-1,-1,-1),
		Vector3.new(-1,1,-1)
	}
	
	local CIRCLE_CASTS = 10
	local MOVE_CASTS = 3
	local SMART_CIRCLE_CASTS = 24
	local SMART_CIRCLE_INCREMENT = 2.0 * math.pi / SMART_CIRCLE_CASTS
	local CHAR_OUTLINE_CASTS = 24
	
	-- Used to sanitize user-supplied functions
	local function AssertTypes(param, ...)
		local allowedTypes = {}
		local typeString = ''
		for _, typeName in pairs({...}) do
			allowedTypes[typeName] = true
			typeString = typeString .. (typeString == '' and '' or ' or ') .. typeName
		end
		local theType = type(param)
		assert(allowedTypes[theType], typeString .. " type expected, got: " .. theType)
	end
	
	-- Helper function for Determinant of 3x3, not in CameraUtils for performance reasons
	local function Det3x3(a,b,c,d,e,f,g,h,i)
		return (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g))
	end
	
	-- Smart Circle mode needs the intersection of 2 rays that are known to be in the same plane
	-- because they are generated from cross products with a common vector. This function is computing
	-- that intersection, but it's actually the general solution for the point halfway between where
	-- two skew lines come nearest to each other, which is more forgiving.
	local function RayIntersection(p0, v0, p1, v1)
		local v2 = v0:Cross(v1)
		local d1 = p1.x - p0.x
		local d2 = p1.y - p0.y
		local d3 = p1.z - p0.z
		local denom = Det3x3(v0.x,-v1.x,v2.x,v0.y,-v1.y,v2.y,v0.z,-v1.z,v2.z)
	
		if (denom == 0) then
			return ZERO_VECTOR3 -- No solution (rays are parallel)
		end
	
		local t0 = Det3x3(d1,-v1.x,v2.x,d2,-v1.y,v2.y,d3,-v1.z,v2.z) / denom
		local t1 = Det3x3(v0.x,d1,v2.x,v0.y,d2,v2.y,v0.z,d3,v2.z) / denom
		local s0 = p0 + t0 * v0
		local s1 = p1 + t1 * v1
		local s = s0 + 0.5 * ( s1 - s0 )
	
		-- 0.25 studs is a threshold for deciding if the rays are
		-- close enough to be considered intersecting, found through testing 
		if (s1-s0).Magnitude < 0.25 then
			return s
		else
			return ZERO_VECTOR3
		end
	end
	
	
	
	--[[ The Module ]]--
	local BaseOcclusion = _BaseOcclusion()
	local Invisicam = setmetatable({}, BaseOcclusion)
	Invisicam.__index = Invisicam
	
	function Invisicam.new()
		local self = setmetatable(BaseOcclusion.new(), Invisicam)
	
		self.char = nil
		self.humanoidRootPart = nil
		self.torsoPart = nil
		self.headPart = nil
	
		self.childAddedConn = nil
		self.childRemovedConn = nil
	
		self.behaviors = {} 	-- Map of modes to behavior fns
		self.behaviors[MODE.LIMBS] = self.LimbBehavior
		self.behaviors[MODE.MOVEMENT] = self.MoveBehavior
		self.behaviors[MODE.CORNERS] = self.CornerBehavior
		self.behaviors[MODE.CIRCLE1] = self.CircleBehavior
		self.behaviors[MODE.CIRCLE2] = self.CircleBehavior
		self.behaviors[MODE.LIMBMOVE] = self.LimbMoveBehavior
		self.behaviors[MODE.SMART_CIRCLE] = self.SmartCircleBehavior
		self.behaviors[MODE.CHAR_OUTLINE] = self.CharacterOutlineBehavior
	
		self.mode = MODE.SMART_CIRCLE
		self.behaviorFunction = self.SmartCircleBehavior
	
		self.savedHits = {} 	-- Objects currently being faded in/out
		self.trackedLimbs = {}	-- Used in limb-tracking casting modes
	
		self.camera = game.Workspace.CurrentCamera
	
		self.enabled = false
		return self
	end
	
	function Invisicam:Enable(enable)
		self.enabled = enable
	
		if not enable then
			self:Cleanup()
		end
	end
	
	function Invisicam:GetOcclusionMode()
		return Enum.DevCameraOcclusionMode.Invisicam
	end
	
	--[[ Module functions ]]--
	function Invisicam:LimbBehavior(castPoints)
		for limb, _ in pairs(self.trackedLimbs) do
			castPoints[#castPoints + 1] = limb.Position
		end
	end
	
	function Invisicam:MoveBehavior(castPoints)
		for i = 1, MOVE_CASTS do
			local position, velocity = self.humanoidRootPart.Position, self.humanoidRootPart.Velocity
			local horizontalSpeed = Vector3.new(velocity.X, 0, velocity.Z).Magnitude / 2
			local offsetVector = (i - 1) * self.humanoidRootPart.CFrame.lookVector * horizontalSpeed
			castPoints[#castPoints + 1] = position + offsetVector
		end
	end
	
	function Invisicam:CornerBehavior(castPoints)
		local cframe = self.humanoidRootPart.CFrame
		local centerPoint = cframe.p
		local rotation = cframe - centerPoint
		local halfSize = self.char:GetExtentsSize() / 2 --NOTE: Doesn't update w/ limb animations
		castPoints[#castPoints + 1] = centerPoint
		for i = 1, #CORNER_FACTORS do
			castPoints[#castPoints + 1] = centerPoint + (rotation * (halfSize * CORNER_FACTORS[i]))
		end
	end
	
	function Invisicam:CircleBehavior(castPoints)
		local cframe
		if self.mode == MODE.CIRCLE1 then
			cframe = self.humanoidRootPart.CFrame
		else
			local camCFrame = self.camera.CoordinateFrame
			cframe = camCFrame - camCFrame.p + self.humanoidRootPart.Position
		end
		castPoints[#castPoints + 1] = cframe.p
		for i = 0, CIRCLE_CASTS - 1 do
			local angle = (2 * math.pi / CIRCLE_CASTS) * i
			local offset = 3 * Vector3.new(math.cos(angle), math.sin(angle), 0)
			castPoints[#castPoints + 1] = cframe * offset
		end
	end
	
	function Invisicam:LimbMoveBehavior(castPoints)
		self:LimbBehavior(castPoints)
		self:MoveBehavior(castPoints)
	end
	
	function Invisicam:CharacterOutlineBehavior(castPoints)
		local torsoUp = self.torsoPart.CFrame.upVector.unit
		local torsoRight = self.torsoPart.CFrame.rightVector.unit
	
		-- Torso cross of points for interior coverage
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
		if self.headPart then
			castPoints[#castPoints + 1] = self.headPart.CFrame.p
		end
	
		local cframe = CFrame.new(ZERO_VECTOR3,Vector3.new(self.camera.CoordinateFrame.lookVector.X,0,self.camera.CoordinateFrame.lookVector.Z))
		local centerPoint = (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)
	
		local partsWhitelist = {self.torsoPart}
		if self.headPart then
			partsWhitelist[#partsWhitelist + 1] = self.headPart
		end
	
		for i = 1, CHAR_OUTLINE_CASTS do
			local angle = (2 * math.pi * i / CHAR_OUTLINE_CASTS)
			local offset = cframe * (3 * Vector3.new(math.cos(angle), math.sin(angle), 0))
	
			offset = Vector3.new(offset.X, math.max(offset.Y, -2.25), offset.Z)	
	
			local ray = Ray.new(centerPoint + offset, -3 * offset)
			local hit, hitPoint = game.Workspace:FindPartOnRayWithWhitelist(ray, partsWhitelist, false, false)
	
			if hit then
				-- Use hit point as the cast point, but nudge it slightly inside the character so that bumping up against
				-- walls is less likely to cause a transparency glitch
				castPoints[#castPoints + 1] = hitPoint + 0.2 * (centerPoint - hitPoint).unit
			end
		end
	end
	
	function Invisicam:SmartCircleBehavior(castPoints)
		local torsoUp = self.torsoPart.CFrame.upVector.unit
		local torsoRight = self.torsoPart.CFrame.rightVector.unit
	
		-- SMART_CIRCLE mode includes rays to head and 5 to the torso.
		-- Hands, arms, legs and feet are not included since they
		-- are not canCollide and can therefore go inside of parts
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
		if self.headPart then
			castPoints[#castPoints + 1] = self.headPart.CFrame.p
		end
	
		local cameraOrientation = self.camera.CFrame - self.camera.CFrame.p
		local torsoPoint = Vector3.new(0,0.5,0) + (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)
		local radius = 2.5
	
		-- This loop first calculates points in a circle of radius 2.5 around the torso of the character, in the
		-- plane orthogonal to the camera's lookVector. Each point is then raycast to, to determine if it is within
		-- the free space surrounding the player (not inside anything). Two iterations are done to adjust points that
		-- are inside parts, to try to move them to valid locations that are still on their camera ray, so that the
		-- circle remains circular from the camera's perspective, but does not cast rays into walls or parts that are
		-- behind, below or beside the character and not really obstructing view of the character. This minimizes
		-- the undesirable situation where the character walks up to an exterior wall and it is made invisible even
		-- though it is behind the character.
		for i = 1, SMART_CIRCLE_CASTS do
			local angle = SMART_CIRCLE_INCREMENT * i - 0.5 * math.pi
			local offset = radius * Vector3.new(math.cos(angle), math.sin(angle), 0)
			local circlePoint = torsoPoint + cameraOrientation * offset
	
			-- Vector from camera to point on the circle being tested
			local vp = circlePoint - self.camera.CFrame.p
	
			local ray = Ray.new(torsoPoint, circlePoint - torsoPoint)
			local hit, hp, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
			local castPoint = circlePoint
	
			if hit then
				local hprime = hp + 0.1 * hitNormal.unit -- Slightly offset hit point from the hit surface
				local v0 = hprime - torsoPoint -- Vector from torso to offset hit point
	
				local perp = (v0:Cross(vp)).unit
	
				-- Vector from the offset hit point, along the hit surface
				local v1 = (perp:Cross(hitNormal)).unit
	
				-- Vector from camera to offset hit
				local vprime = (hprime - self.camera.CFrame.p).unit
	
				-- This dot product checks to see if the vector along the hit surface would hit the correct
				-- side of the invisicam cone, or if it would cross the camera look vector and hit the wrong side
				if ( v0.unit:Dot(-v1) < v0.unit:Dot(vprime)) then
					castPoint = RayIntersection(hprime, v1, circlePoint, vp)
	
					if castPoint.Magnitude > 0 then
						local ray = Ray.new(hprime, castPoint - hprime)
						local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
	
						if hit then
							local hprime2 = hitPoint + 0.1 * hitNormal.unit
							castPoint = hprime2
						end
					else
						castPoint = hprime
					end
				else
					castPoint = hprime
				end
	
				local ray = Ray.new(torsoPoint, (castPoint - torsoPoint))
				local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
	
				if hit then
					local castPoint2 = hitPoint - 0.1 * (castPoint - torsoPoint).unit
					castPoint = castPoint2
				end
			end
	
			castPoints[#castPoints + 1] = castPoint
		end
	end
	
	function Invisicam:CheckTorsoReference()
		if self.char then
			self.torsoPart = self.char:FindFirstChild("Torso")
			if not self.torsoPart then
				self.torsoPart = self.char:FindFirstChild("UpperTorso")
				if not self.torsoPart then
					self.torsoPart = self.char:FindFirstChild("HumanoidRootPart")
				end
			end
	
			self.headPart = self.char:FindFirstChild("Head")
		end
	end
	
	function Invisicam:CharacterAdded(char, player)
		-- We only want the LocalPlayer's character
		if player~=PlayersService.LocalPlayer then return end
	
		if self.childAddedConn then
			self.childAddedConn:Disconnect()
			self.childAddedConn = nil
		end
		if self.childRemovedConn then
			self.childRemovedConn:Disconnect()
			self.childRemovedConn = nil
		end
	
		self.char = char
	
		self.trackedLimbs = {}
		local function childAdded(child)
			if child:IsA("BasePart") then
				if LIMB_TRACKING_SET[child.Name] then
					self.trackedLimbs[child] = true
				end
	
				if child.Name == "Torso" or child.Name == "UpperTorso" then
					self.torsoPart = child
				end
	
				if child.Name == "Head" then
					self.headPart = child
				end
			end
		end
	
		local function childRemoved(child)
			self.trackedLimbs[child] = nil
	
			-- If removed/replaced part is 'Torso' or 'UpperTorso' double check that we still have a TorsoPart to use
			self:CheckTorsoReference()
		end
	
		self.childAddedConn = char.ChildAdded:Connect(childAdded)
		self.childRemovedConn = char.ChildRemoved:Connect(childRemoved)
		for _, child in pairs(self.char:GetChildren()) do
			childAdded(child)
		end
	end
	
	function Invisicam:SetMode(newMode)
		AssertTypes(newMode, 'number')
		for _, modeNum in pairs(MODE) do
			if modeNum == newMode then
				self.mode = newMode
				self.behaviorFunction = self.behaviors[self.mode]
				return
			end
		end
		error("Invalid mode number")
	end
	
	function Invisicam:GetObscuredParts()
		return self.savedHits
	end
	
	-- Want to turn off Invisicam? Be sure to call this after.
	function Invisicam:Cleanup()
		for hit, originalFade in pairs(self.savedHits) do
			hit.LocalTransparencyModifier = originalFade
		end
	end
	
	function Invisicam:Update(dt, desiredCameraCFrame, desiredCameraFocus)
		-- Bail if there is no Character
		if not self.enabled or not self.char then
			return desiredCameraCFrame, desiredCameraFocus
		end
	
		self.camera = game.Workspace.CurrentCamera
	
		-- TODO: Move this to a GetHumanoidRootPart helper, probably combine with CheckTorsoReference
		-- Make sure we still have a HumanoidRootPart
		if not self.humanoidRootPart then
			local humanoid = self.char:FindFirstChildOfClass("Humanoid")
			if humanoid and humanoid.RootPart then
				self.humanoidRootPart = humanoid.RootPart
			else
				-- Not set up with Humanoid? Try and see if there's one in the Character at all:
				self.humanoidRootPart = self.char:FindFirstChild("HumanoidRootPart")
				if not self.humanoidRootPart then
					-- Bail out, since we're relying on HumanoidRootPart existing
					return desiredCameraCFrame, desiredCameraFocus
				end
			end
	
			-- TODO: Replace this with something more sensible
			local ancestryChangedConn
			ancestryChangedConn = self.humanoidRootPart.AncestryChanged:Connect(function(child, parent)
				if child == self.humanoidRootPart and not parent then 
					self.humanoidRootPart = nil
					if ancestryChangedConn and ancestryChangedConn.Connected then
						ancestryChangedConn:Disconnect()
						ancestryChangedConn = nil
					end
				end
			end)
		end
	
		if not self.torsoPart then
			self:CheckTorsoReference()
			if not self.torsoPart then
				-- Bail out, since we're relying on Torso existing, should never happen since we fall back to using HumanoidRootPart as torso
				return desiredCameraCFrame, desiredCameraFocus
			end
		end
	
		-- Make a list of world points to raycast to
		local castPoints = {}
		self.behaviorFunction(self, castPoints)
	
		-- Cast to get a list of objects between the camera and the cast points
		local currentHits = {}
		local ignoreList = {self.char}
		local function add(hit)
			currentHits[hit] = true
			if not self.savedHits[hit] then
				self.savedHits[hit] = hit.LocalTransparencyModifier
			end
		end
	
		local hitParts
		local hitPartCount = 0
	
		-- Hash table to treat head-ray-hit parts differently than the rest of the hit parts hit by other rays
		-- head/torso ray hit parts will be more transparent than peripheral parts when USE_STACKING_TRANSPARENCY is enabled
		local headTorsoRayHitParts = {}
	
		local perPartTransparencyHeadTorsoHits = TARGET_TRANSPARENCY
		local perPartTransparencyOtherHits = TARGET_TRANSPARENCY
	
		if USE_STACKING_TRANSPARENCY then
	
			-- This first call uses head and torso rays to find out how many parts are stacked up
			-- for the purpose of calculating required per-part transparency
			local headPoint = self.headPart and self.headPart.CFrame.p or castPoints[1]
			local torsoPoint = self.torsoPart and self.torsoPart.CFrame.p or castPoints[2]
			hitParts = self.camera:GetPartsObscuringTarget({headPoint, torsoPoint}, ignoreList)
	
			-- Count how many things the sample rays passed through, including decals. This should only
			-- count decals facing the camera, but GetPartsObscuringTarget does not return surface normals,
			-- so my compromise for now is to just let any decal increase the part count by 1. Only one
			-- decal per part will be considered.
			for i = 1, #hitParts do
				local hitPart = hitParts[i]
				hitPartCount = hitPartCount + 1 -- count the part itself
				headTorsoRayHitParts[hitPart] = true
				for _, child in pairs(hitPart:GetChildren()) do
					if child:IsA('Decal') or child:IsA('Texture') then
						hitPartCount = hitPartCount + 1 -- count first decal hit, then break
						break
					end
				end
			end
	
			if (hitPartCount > 0) then
				perPartTransparencyHeadTorsoHits = math.pow( ((0.5 * TARGET_TRANSPARENCY) + (0.5 * TARGET_TRANSPARENCY / hitPartCount)), 1 / hitPartCount )
				perPartTransparencyOtherHits = math.pow( ((0.5 * TARGET_TRANSPARENCY_PERIPHERAL) + (0.5 * TARGET_TRANSPARENCY_PERIPHERAL / hitPartCount)), 1 / hitPartCount )
			end
		end
	
		-- Now get all the parts hit by all the rays
		hitParts = self.camera:GetPartsObscuringTarget(castPoints, ignoreList)
	
		local partTargetTransparency = {}
	
		-- Include decals and textures
		for i = 1, #hitParts do
			local hitPart = hitParts[i]
	
			partTargetTransparency[hitPart] =headTorsoRayHitParts[hitPart] and perPartTransparencyHeadTorsoHits or perPartTransparencyOtherHits
	
			-- If the part is not already as transparent or more transparent than what invisicam requires, add it to the list of
			-- parts to be modified by invisicam
			if hitPart.Transparency < partTargetTransparency[hitPart] then
				add(hitPart)
			end
	
			-- Check all decals and textures on the part
			for _, child in pairs(hitPart:GetChildren()) do
				if child:IsA('Decal') or child:IsA('Texture') then
					if (child.Transparency < partTargetTransparency[hitPart]) then
						partTargetTransparency[child] = partTargetTransparency[hitPart]
						add(child)
					end
				end
			end
		end
	
		-- Invisibilize objects that are in the way, restore those that aren't anymore
		for hitPart, originalLTM in pairs(self.savedHits) do
			if currentHits[hitPart] then
				-- LocalTransparencyModifier gets whatever value is required to print the part's total transparency to equal perPartTransparency
				hitPart.LocalTransparencyModifier = (hitPart.Transparency < 1) and ((partTargetTransparency[hitPart] - hitPart.Transparency) / (1.0 - hitPart.Transparency)) or 0
			else -- Restore original pre-invisicam value of LTM
				hitPart.LocalTransparencyModifier = originalLTM
				self.savedHits[hitPart] = nil
			end
		end
	
		-- Invisicam does not change the camera values
		return desiredCameraCFrame, desiredCameraFocus
	end
	
	return Invisicam
end

function _LegacyCamera()
	
	local ZERO_VECTOR2 = Vector2.new(0,0)
	
	local Util = _CameraUtils()
	
	--[[ Services ]]--
	local PlayersService = game:GetService('Players')
	
	--[[ The Module ]]--
	local BaseCamera = _BaseCamera()
	local LegacyCamera = setmetatable({}, BaseCamera)
	LegacyCamera.__index = LegacyCamera
	
	function LegacyCamera.new()
		local self = setmetatable(BaseCamera.new(), LegacyCamera)
	
		self.cameraType = Enum.CameraType.Fixed
		self.lastUpdate = tick()
		self.lastDistanceToSubject = nil
	
		return self
	end
	
	function LegacyCamera:GetModuleName()
		return "LegacyCamera"
	end
	
	--[[ Functions overridden from BaseCamera ]]--
	function LegacyCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
		return BaseCamera.SetCameraToSubjectDistance(self,desiredSubjectDistance)
	end
	
	function LegacyCamera:Update(dt)
	
		-- Cannot update until cameraType has been set
		if not self.cameraType then return end
	
		local now = tick()
		local timeDelta = (now - self.lastUpdate)
		local camera = 	workspace.CurrentCamera
		local newCameraCFrame = camera.CFrame
		local newCameraFocus = camera.Focus
		local player = PlayersService.LocalPlayer
	
		if self.lastUpdate == nil or timeDelta > 1 then
			self.lastDistanceToSubject = nil
		end
		local subjectPosition = self:GetSubjectPosition()
	
		if self.cameraType == Enum.CameraType.Fixed then
			if self.lastUpdate then
				-- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
				local delta = math.min(0.1, now - self.lastUpdate)
				local gamepadRotation = self:UpdateGamepad()
				self.rotateInput = self.rotateInput + (gamepadRotation * delta)
			end
	
			if subjectPosition and player and camera then
				local distanceToSubject = self:GetCameraToSubjectDistance()
				local newLookVector = self:CalculateNewLookVector()
				self.rotateInput = ZERO_VECTOR2
	
				newCameraFocus = camera.Focus -- Fixed camera does not change focus
				newCameraCFrame = CFrame.new(camera.CFrame.p, camera.CFrame.p + (distanceToSubject * newLookVector))
			end
		elseif self.cameraType == Enum.CameraType.Attach then
			if subjectPosition and camera then
				local distanceToSubject = self:GetCameraToSubjectDistance()
				local humanoid = self:GetHumanoid()
				if self.lastUpdate and humanoid and humanoid.RootPart then
	
					-- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
					local delta = math.min(0.1, now - self.lastUpdate)
					local gamepadRotation = self:UpdateGamepad()
					self.rotateInput = self.rotateInput + (gamepadRotation * delta)
	
					local forwardVector = humanoid.RootPart.CFrame.lookVector
	
					local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
					if Util.IsFinite(y) then
						-- Preserve vertical rotation from user input
						self.rotateInput = Vector2.new(y, self.rotateInput.Y)
					end
				end
	
				local newLookVector = self:CalculateNewLookVector()
				self.rotateInput = ZERO_VECTOR2
	
				newCameraFocus = CFrame.new(subjectPosition)
				newCameraCFrame = CFrame.new(subjectPosition - (distanceToSubject * newLookVector), subjectPosition)
			end
		elseif self.cameraType == Enum.CameraType.Watch then
			if subjectPosition and player and camera then
				local cameraLook = nil
	
				local humanoid = self:GetHumanoid()
				if humanoid and humanoid.RootPart then
					local diffVector = subjectPosition - camera.CFrame.p
					cameraLook = diffVector.unit
	
					if self.lastDistanceToSubject and self.lastDistanceToSubject == self:GetCameraToSubjectDistance() then
						-- Don't clobber the zoom if they zoomed the camera
						local newDistanceToSubject = diffVector.magnitude
						self:SetCameraToSubjectDistance(newDistanceToSubject)
					end
				end
	
				local distanceToSubject = self:GetCameraToSubjectDistance()
				local newLookVector = self:CalculateNewLookVector(cameraLook)
				self.rotateInput = ZERO_VECTOR2
	
				newCameraFocus = CFrame.new(subjectPosition)
				newCameraCFrame = CFrame.new(subjectPosition - (distanceToSubject * newLookVector), subjectPosition)
	
				self.lastDistanceToSubject = distanceToSubject
			end
		else
			-- Unsupported type, return current values unchanged
			return camera.CFrame, camera.Focus
		end
	
		self.lastUpdate = now
		return newCameraCFrame, newCameraFocus
	end
	
	return LegacyCamera
end

function _OrbitalCamera()
	
	-- Local private variables and constants
	local UNIT_Z = Vector3.new(0,0,1)
	local X1_Y0_Z1 = Vector3.new(1,0,1)	--Note: not a unit vector, used for projecting onto XZ plane
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	local ZERO_VECTOR2 = Vector2.new(0,0)
	local TAU = 2 * math.pi
	
	--[[ Gamepad Support ]]--
	local THUMBSTICK_DEADZONE = 0.2
	
	-- Do not edit these values, they are not the developer-set limits, they are limits
	-- to the values the camera system equations can correctly handle
	local MIN_ALLOWED_ELEVATION_DEG = -80
	local MAX_ALLOWED_ELEVATION_DEG = 80
	
	local externalProperties = {}
	externalProperties["InitialDistance"]  = 25
	externalProperties["MinDistance"]      = 10
	externalProperties["MaxDistance"]      = 100
	externalProperties["InitialElevation"] = 35
	externalProperties["MinElevation"]     = 35
	externalProperties["MaxElevation"]     = 35
	externalProperties["ReferenceAzimuth"] = -45	-- Angle around the Y axis where the camera starts. -45 offsets the camera in the -X and +Z directions equally
	externalProperties["CWAzimuthTravel"]  = 90	-- How many degrees the camera is allowed to rotate from the reference position, CW as seen from above
	externalProperties["CCWAzimuthTravel"] = 90	-- How many degrees the camera is allowed to rotate from the reference position, CCW as seen from above
	externalProperties["UseAzimuthLimits"] = false -- Full rotation around Y axis available by default
	
	local Util = _CameraUtils()
	
	--[[ Services ]]--
	local PlayersService = game:GetService('Players')
	local VRService = game:GetService("VRService")
	
	--[[ The Module ]]--
	local BaseCamera = _BaseCamera()
	local OrbitalCamera = setmetatable({}, BaseCamera)
	OrbitalCamera.__index = OrbitalCamera
	
	
	function OrbitalCamera.new()
		local self = setmetatable(BaseCamera.new(), OrbitalCamera)
	
		self.lastUpdate = tick()
	
		-- OrbitalCamera-specific members
		self.changedSignalConnections = {}
		self.refAzimuthRad = nil
		self.curAzimuthRad = nil
		self.minAzimuthAbsoluteRad = nil
		self.maxAzimuthAbsoluteRad = nil
		self.useAzimuthLimits = nil
		self.curElevationRad = nil
		self.minElevationRad = nil
		self.maxElevationRad = nil
		self.curDistance = nil
		self.minDistance = nil
		self.maxDistance = nil
	
		-- Gamepad
		self.r3ButtonDown = false
		self.l3ButtonDown = false
		self.gamepadDollySpeedMultiplier = 1
	
		self.lastUserPanCamera = tick()
	
		self.externalProperties = {}
		self.externalProperties["InitialDistance"] 	= 25
		self.externalProperties["MinDistance"] 		= 10
		self.externalProperties["MaxDistance"] 		= 100
		self.externalProperties["InitialElevation"] 	= 35
		self.externalProperties["MinElevation"] 		= 35
		self.externalProperties["MaxElevation"] 		= 35
		self.externalProperties["ReferenceAzimuth"] 	= -45	-- Angle around the Y axis where the camera starts. -45 offsets the camera in the -X and +Z directions equally
		self.externalProperties["CWAzimuthTravel"] 	= 90	-- How many degrees the camera is allowed to rotate from the reference position, CW as seen from above
		self.externalProperties["CCWAzimuthTravel"] 	= 90	-- How many degrees the camera is allowed to rotate from the reference position, CCW as seen from above
		self.externalProperties["UseAzimuthLimits"] 	= false -- Full rotation around Y axis available by default
		self:LoadNumberValueParameters()
	
		return self
	end
	
	function OrbitalCamera:LoadOrCreateNumberValueParameter(name, valueType, updateFunction)
		local valueObj = script:FindFirstChild(name)
	
		if valueObj and valueObj:isA(valueType) then
			-- Value object exists and is the correct type, use its value
			self.externalProperties[name] = valueObj.Value
		elseif self.externalProperties[name] ~= nil then
			-- Create missing (or replace incorrectly-typed) valueObject with default value
			valueObj = Instance.new(valueType)
			valueObj.Name = name
			valueObj.Parent = script
			valueObj.Value = self.externalProperties[name]
		else
			print("externalProperties table has no entry for ",name)
			return
		end
	
		if updateFunction then
			if self.changedSignalConnections[name] then
				self.changedSignalConnections[name]:Disconnect()
			end
			self.changedSignalConnections[name] = valueObj.Changed:Connect(function(newValue)
				self.externalProperties[name] = newValue
				updateFunction(self)
			end)
		end
	end
	
	function OrbitalCamera:SetAndBoundsCheckAzimuthValues()
		self.minAzimuthAbsoluteRad = math.rad(self.externalProperties["ReferenceAzimuth"]) - math.abs(math.rad(self.externalProperties["CWAzimuthTravel"]))
		self.maxAzimuthAbsoluteRad = math.rad(self.externalProperties["ReferenceAzimuth"]) + math.abs(math.rad(self.externalProperties["CCWAzimuthTravel"]))
		self.useAzimuthLimits = self.externalProperties["UseAzimuthLimits"]
		if self.useAzimuthLimits then
			self.curAzimuthRad = math.max(self.curAzimuthRad, self.minAzimuthAbsoluteRad)
			self.curAzimuthRad = math.min(self.curAzimuthRad, self.maxAzimuthAbsoluteRad)
		end
	end
	
	function OrbitalCamera:SetAndBoundsCheckElevationValues()
		-- These degree values are the direct user input values. It is deliberate that they are
		-- ranged checked only against the extremes, and not against each other. Any time one
		-- is changed, both of the internal values in radians are recalculated. This allows for
		-- A developer to change the values in any order and for the end results to be that the
		-- internal values adjust to match intent as best as possible.
		local minElevationDeg = math.max(self.externalProperties["MinElevation"], MIN_ALLOWED_ELEVATION_DEG)
		local maxElevationDeg = math.min(self.externalProperties["MaxElevation"], MAX_ALLOWED_ELEVATION_DEG)
	
		-- Set internal values in radians
		self.minElevationRad = math.rad(math.min(minElevationDeg, maxElevationDeg))
		self.maxElevationRad = math.rad(math.max(minElevationDeg, maxElevationDeg))
		self.curElevationRad = math.max(self.curElevationRad, self.minElevationRad)
		self.curElevationRad = math.min(self.curElevationRad, self.maxElevationRad)
	end
	
	function OrbitalCamera:SetAndBoundsCheckDistanceValues()
		self.minDistance = self.externalProperties["MinDistance"]
		self.maxDistance = self.externalProperties["MaxDistance"]
		self.curDistance = math.max(self.curDistance, self.minDistance)
		self.curDistance = math.min(self.curDistance, self.maxDistance)
	end
	
	-- This loads from, or lazily creates, NumberValue objects for exposed parameters
	function OrbitalCamera:LoadNumberValueParameters()
		-- These initial values do not require change listeners since they are read only once
		self:LoadOrCreateNumberValueParameter("InitialElevation", "NumberValue", nil)
		self:LoadOrCreateNumberValueParameter("InitialDistance", "NumberValue", nil)
	
		-- Note: ReferenceAzimuth is also used as an initial value, but needs a change listener because it is used in the calculation of the limits
		self:LoadOrCreateNumberValueParameter("ReferenceAzimuth", "NumberValue", self.SetAndBoundsCheckAzimuthValue)
		self:LoadOrCreateNumberValueParameter("CWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
		self:LoadOrCreateNumberValueParameter("CCWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
		self:LoadOrCreateNumberValueParameter("MinElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
		self:LoadOrCreateNumberValueParameter("MaxElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
		self:LoadOrCreateNumberValueParameter("MinDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
		self:LoadOrCreateNumberValueParameter("MaxDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
		self:LoadOrCreateNumberValueParameter("UseAzimuthLimits", "BoolValue", self.SetAndBoundsCheckAzimuthValues)
	
		-- Internal values set (in radians, from degrees), plus sanitization
		self.curAzimuthRad = math.rad(self.externalProperties["ReferenceAzimuth"])
		self.curElevationRad = math.rad(self.externalProperties["InitialElevation"])
		self.curDistance = self.externalProperties["InitialDistance"]
	
		self:SetAndBoundsCheckAzimuthValues()
		self:SetAndBoundsCheckElevationValues()
		self:SetAndBoundsCheckDistanceValues()
	end
	
	function OrbitalCamera:GetModuleName()
		return "OrbitalCamera"
	end
	
	function OrbitalCamera:SetInitialOrientation(humanoid)
		if not humanoid or not humanoid.RootPart then
			warn("OrbitalCamera could not set initial orientation due to missing humanoid")
			return
		end
		local newDesiredLook = (humanoid.RootPart.CFrame.lookVector - Vector3.new(0,0.23,0)).unit
		local horizontalShift = Util.GetAngleBetweenXZVectors(newDesiredLook, self:GetCameraLookVector())
		local vertShift = math.asin(self:GetCameraLookVector().y) - math.asin(newDesiredLook.y)
		if not Util.IsFinite(horizontalShift) then
			horizontalShift = 0
		end
		if not Util.IsFinite(vertShift) then
			vertShift = 0
		end
		self.rotateInput = Vector2.new(horizontalShift, vertShift)
	end
	
	--[[ Functions of BaseCamera that are overridden by OrbitalCamera ]]--
	function OrbitalCamera:GetCameraToSubjectDistance()
		return self.curDistance
	end
	
	function OrbitalCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
		print("OrbitalCamera SetCameraToSubjectDistance ",desiredSubjectDistance)
		local player = PlayersService.LocalPlayer
		if player then
			self.currentSubjectDistance = math.clamp(desiredSubjectDistance, self.minDistance, self.maxDistance)
	
			-- OrbitalCamera is not allowed to go into the first-person range
			self.currentSubjectDistance = math.max(self.currentSubjectDistance, self.FIRST_PERSON_DISTANCE_THRESHOLD)
		end
		self.inFirstPerson = false
		self:UpdateMouseBehavior()
		return self.currentSubjectDistance
	end
	
	function OrbitalCamera:CalculateNewLookVector(suppliedLookVector, xyRotateVector)
		local currLookVector = suppliedLookVector or self:GetCameraLookVector()
		local currPitchAngle = math.asin(currLookVector.y)
		local yTheta = math.clamp(xyRotateVector.y, currPitchAngle - math.rad(MAX_ALLOWED_ELEVATION_DEG), currPitchAngle - math.rad(MIN_ALLOWED_ELEVATION_DEG))
		local constrainedRotateInput = Vector2.new(xyRotateVector.x, yTheta)
		local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
		local newLookVector = (CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y,0,0)).lookVector
		return newLookVector
	end
	
	function OrbitalCamera:GetGamepadPan(name, state, input)
		if input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.Thumbstick2 then
			if self.r3ButtonDown or self.l3ButtonDown then
			-- R3 or L3 Thumbstick is depressed, right stick controls dolly in/out
				if (input.Position.Y > THUMBSTICK_DEADZONE) then
					self.gamepadDollySpeedMultiplier = 0.96
				elseif (input.Position.Y < -THUMBSTICK_DEADZONE) then
					self.gamepadDollySpeedMultiplier = 1.04
				else
					self.gamepadDollySpeedMultiplier = 1.00
				end
			else
				if state == Enum.UserInputState.Cancel then
					self.gamepadPanningCamera = ZERO_VECTOR2
					return
				end
	
				local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
				if inputVector.magnitude > THUMBSTICK_DEADZONE then
					self.gamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
				else
					self.gamepadPanningCamera = ZERO_VECTOR2
				end
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	
	function OrbitalCamera:DoGamepadZoom(name, state, input)
		if input.UserInputType == self.activeGamepad and (input.KeyCode == Enum.KeyCode.ButtonR3 or input.KeyCode == Enum.KeyCode.ButtonL3) then
			if (state == Enum.UserInputState.Begin) then
				self.r3ButtonDown = input.KeyCode == Enum.KeyCode.ButtonR3
				self.l3ButtonDown = input.KeyCode == Enum.KeyCode.ButtonL3
			elseif (state == Enum.UserInputState.End) then
				if (input.KeyCode == Enum.KeyCode.ButtonR3) then
					self.r3ButtonDown = false
				elseif (input.KeyCode == Enum.KeyCode.ButtonL3) then
					self.l3ButtonDown = false
				end
				if (not self.r3ButtonDown) and (not self.l3ButtonDown) then
					self.gamepadDollySpeedMultiplier = 1.00
				end
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	
	function OrbitalCamera:BindGamepadInputActions()
		self:BindAction("OrbitalCamGamepadPan", function(name, state, input) return self:GetGamepadPan(name, state, input) end,
			false, Enum.KeyCode.Thumbstick2)
		self:BindAction("OrbitalCamGamepadZoom", function(name, state, input) return self:DoGamepadZoom(name, state, input) end,
			false, Enum.KeyCode.ButtonR3, Enum.KeyCode.ButtonL3)
	end
	
	
	-- [[ Update ]]--
	function OrbitalCamera:Update(dt)
		local now = tick()
		local timeDelta = (now - self.lastUpdate)
		local userPanningTheCamera = (self.UserPanningTheCamera == true)
		local camera = 	workspace.CurrentCamera
		local newCameraCFrame = camera.CFrame
		local newCameraFocus = camera.Focus
		local player = PlayersService.LocalPlayer
		local cameraSubject = camera and camera.CameraSubject
		local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
		local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')
	
		if self.lastUpdate == nil or timeDelta > 1 then
			self.lastCameraTransform = nil
		end
	
		if self.lastUpdate then
			local gamepadRotation = self:UpdateGamepad()
	
			if self:ShouldUseVRRotation() then
				self.RotateInput = self.RotateInput + self:GetVRRotationInput()
			else
				-- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
				local delta = math.min(0.1, timeDelta)
	
				if gamepadRotation ~= ZERO_VECTOR2 then
					userPanningTheCamera = true
					self.rotateInput = self.rotateInput + (gamepadRotation * delta)
				end
	
				local angle = 0
				if not (isInVehicle or isOnASkateboard) then
					angle = angle + (self.TurningLeft and -120 or 0)
					angle = angle + (self.TurningRight and 120 or 0)
				end
	
				if angle ~= 0 then
					self.rotateInput = self.rotateInput +  Vector2.new(math.rad(angle * delta), 0)
					userPanningTheCamera = true
				end
			end
		end
	
		-- Reset tween speed if user is panning
		if userPanningTheCamera then
			self.lastUserPanCamera = tick()
		end
	
		local subjectPosition = self:GetSubjectPosition()
	
		if subjectPosition and player and camera then
	
			-- Process any dollying being done by gamepad
			-- TODO: Move this
			if self.gamepadDollySpeedMultiplier ~= 1 then
				self:SetCameraToSubjectDistance(self.currentSubjectDistance * self.gamepadDollySpeedMultiplier)
			end
	
			local VREnabled = VRService.VREnabled
			newCameraFocus = VREnabled and self:GetVRFocus(subjectPosition, timeDelta) or CFrame.new(subjectPosition)
	
			local cameraFocusP = newCameraFocus.p
			if VREnabled and not self:IsInFirstPerson() then
				local cameraHeight = self:GetCameraHeight()
				local vecToSubject = (subjectPosition - camera.CFrame.p)
				local distToSubject = vecToSubject.magnitude
	
				-- Only move the camera if it exceeded a maximum distance to the subject in VR
				if distToSubject > self.currentSubjectDistance or self.rotateInput.x ~= 0 then
					local desiredDist = math.min(distToSubject, self.currentSubjectDistance)
	
					-- Note that CalculateNewLookVector is overridden from BaseCamera
					vecToSubject = self:CalculateNewLookVector(vecToSubject.unit * X1_Y0_Z1, Vector2.new(self.rotateInput.x, 0)) * desiredDist
	
					local newPos = cameraFocusP - vecToSubject
					local desiredLookDir = camera.CFrame.lookVector
					if self.rotateInput.x ~= 0 then
						desiredLookDir = vecToSubject
					end
					local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
					self.RotateInput = ZERO_VECTOR2
	
					newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
				end
			else
				-- self.RotateInput is a Vector2 of mouse movement deltas since last update
				self.curAzimuthRad = self.curAzimuthRad - self.rotateInput.x
	
				if self.useAzimuthLimits then
					self.curAzimuthRad = math.clamp(self.curAzimuthRad, self.minAzimuthAbsoluteRad, self.maxAzimuthAbsoluteRad)
				else
					self.curAzimuthRad = (self.curAzimuthRad ~= 0) and (math.sign(self.curAzimuthRad) * (math.abs(self.curAzimuthRad) % TAU)) or 0
				end
	
				self.curElevationRad = math.clamp(self.curElevationRad + self.rotateInput.y, self.minElevationRad, self.maxElevationRad)
	
				local cameraPosVector = self.currentSubjectDistance * ( CFrame.fromEulerAnglesYXZ( -self.curElevationRad, self.curAzimuthRad, 0 ) * UNIT_Z )
				local camPos = subjectPosition + cameraPosVector
	
				newCameraCFrame = CFrame.new(camPos, subjectPosition)
	
				self.rotateInput = ZERO_VECTOR2
			end
	
			self.lastCameraTransform = newCameraCFrame
			self.lastCameraFocus = newCameraFocus
			if (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
				self.lastSubjectCFrame = cameraSubject.CFrame
			else
				self.lastSubjectCFrame = nil
			end
		end
	
		self.lastUpdate = now
		return newCameraCFrame, newCameraFocus
	end
	
	return OrbitalCamera
end

function _ClassicCamera()
	
	-- Local private variables and constants
	local ZERO_VECTOR2 = Vector2.new(0,0)
	
	local tweenAcceleration = math.rad(220)		--Radians/Second^2
	local tweenSpeed = math.rad(0)				--Radians/Second
	local tweenMaxSpeed = math.rad(250)			--Radians/Second
	local TIME_BEFORE_AUTO_ROTATE = 2.0 		--Seconds, used when auto-aligning camera with vehicles
	
	local INITIAL_CAMERA_ANGLE = CFrame.fromOrientation(math.rad(-15), 0, 0)
	
	local FFlagUserCameraToggle do
		local success, result = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserCameraToggle")
		end)
		FFlagUserCameraToggle = success and result
	end
	
	--[[ Services ]]--
	local PlayersService = game:GetService('Players')
	local VRService = game:GetService("VRService")
	
	local CameraInput = _CameraInput()
	local Util = _CameraUtils()
	
	--[[ The Module ]]--
	local BaseCamera = _BaseCamera()
	local ClassicCamera = setmetatable({}, BaseCamera)
	ClassicCamera.__index = ClassicCamera
	
	function ClassicCamera.new()
		local self = setmetatable(BaseCamera.new(), ClassicCamera)
	
		self.isFollowCamera = false
		self.isCameraToggle = false
		self.lastUpdate = tick()
		self.cameraToggleSpring = Util.Spring.new(5, 0)
	
		return self
	end
	
	function ClassicCamera:GetCameraToggleOffset(dt)
		assert(FFlagUserCameraToggle)
	
		if self.isCameraToggle then
			local zoom = self.currentSubjectDistance
	
			if CameraInput.getTogglePan() then
				self.cameraToggleSpring.goal = math.clamp(Util.map(zoom, 0.5, self.FIRST_PERSON_DISTANCE_THRESHOLD, 0, 1), 0, 1)
			else
				self.cameraToggleSpring.goal = 0
			end
	
			local distanceOffset = math.clamp(Util.map(zoom, 0.5, 64, 0, 1), 0, 1) + 1
			return Vector3.new(0, self.cameraToggleSpring:step(dt)*distanceOffset, 0)
		end
	
		return Vector3.new()
	end
	
	-- Movement mode standardized to Enum.ComputerCameraMovementMode values
	function ClassicCamera:SetCameraMovementMode(cameraMovementMode)
		BaseCamera.SetCameraMovementMode(self, cameraMovementMode)
	
		self.isFollowCamera = cameraMovementMode == Enum.ComputerCameraMovementMode.Follow
		self.isCameraToggle = cameraMovementMode == Enum.ComputerCameraMovementMode.CameraToggle
	end
	
	function ClassicCamera:Update()
		local now = tick()
		local timeDelta = now - self.lastUpdate
	
		local camera = workspace.CurrentCamera
		local newCameraCFrame = camera.CFrame
		local newCameraFocus = camera.Focus
	
		local overrideCameraLookVector = nil
		if self.resetCameraAngle then
			local rootPart = self:GetHumanoidRootPart()
			if rootPart then
				overrideCameraLookVector = (rootPart.CFrame * INITIAL_CAMERA_ANGLE).lookVector
			else
				overrideCameraLookVector = INITIAL_CAMERA_ANGLE.lookVector
			end
			self.resetCameraAngle = false
		end
	
		local player = PlayersService.LocalPlayer
		local humanoid = self:GetHumanoid()
		local cameraSubject = camera.CameraSubject
		local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
		local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')
		local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing
	
		if self.lastUpdate == nil or timeDelta > 1 then
			self.lastCameraTransform = nil
		end
	
		if self.lastUpdate then
			local gamepadRotation = self:UpdateGamepad()
	
			if self:ShouldUseVRRotation() then
				self.rotateInput = self.rotateInput + self:GetVRRotationInput()
			else
				-- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
				local delta = math.min(0.1, timeDelta)
	
				if gamepadRotation ~= ZERO_VECTOR2 then
					self.rotateInput = self.rotateInput + (gamepadRotation * delta)
				end
	
				local angle = 0
				if not (isInVehicle or isOnASkateboard) then
					angle = angle + (self.turningLeft and -120 or 0)
					angle = angle + (self.turningRight and 120 or 0)
				end
	
				if angle ~= 0 then
					self.rotateInput = self.rotateInput +  Vector2.new(math.rad(angle * delta), 0)
				end
			end
		end
	
		local cameraHeight = self:GetCameraHeight()
	
		-- Reset tween speed if user is panning
		if self.userPanningTheCamera then
			tweenSpeed = 0
			self.lastUserPanCamera = tick()
		end
	
		local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFORE_AUTO_ROTATE
		local subjectPosition = self:GetSubjectPosition()
	
		if subjectPosition and player and camera then
			local zoom = self:GetCameraToSubjectDistance()
			if zoom < 0.5 then
				zoom = 0.5
			end
	
			if self:GetIsMouseLocked() and not self:IsInFirstPerson() then
				-- We need to use the right vector of the camera after rotation, not before
				local newLookCFrame = self:CalculateNewLookCFrame(overrideCameraLookVector)
	
				local offset = self:GetMouseLockOffset()
				local cameraRelativeOffset = offset.X * newLookCFrame.rightVector + offset.Y * newLookCFrame.upVector + offset.Z * newLookCFrame.lookVector
	
				--offset can be NAN, NAN, NAN if newLookVector has only y component
				if Util.IsFiniteVector3(cameraRelativeOffset) then
					subjectPosition = subjectPosition + cameraRelativeOffset
				end
			else
				if not self.userPanningTheCamera and self.lastCameraTransform then
	
					local isInFirstPerson = self:IsInFirstPerson()
	
					if (isInVehicle or isOnASkateboard or (self.isFollowCamera and isClimbing)) and self.lastUpdate and humanoid and humanoid.Torso then
						if isInFirstPerson then
							if self.lastSubjectCFrame and (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
								local y = -Util.GetAngleBetweenXZVectors(self.lastSubjectCFrame.lookVector, cameraSubject.CFrame.lookVector)
								if Util.IsFinite(y) then
									self.rotateInput = self.rotateInput + Vector2.new(y, 0)
								end
								tweenSpeed = 0
							end
						elseif not userRecentlyPannedCamera then
							local forwardVector = humanoid.Torso.CFrame.lookVector
							if isOnASkateboard then
								forwardVector = cameraSubject.CFrame.lookVector
							end
	
							tweenSpeed = math.clamp(tweenSpeed + tweenAcceleration * timeDelta, 0, tweenMaxSpeed)
	
							local percent = math.clamp(tweenSpeed * timeDelta, 0, 1)
							if self:IsInFirstPerson() and not (self.isFollowCamera and self.isClimbing) then
								percent = 1
							end
	
							local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
							if Util.IsFinite(y) and math.abs(y) > 0.0001 then
								self.rotateInput = self.rotateInput + Vector2.new(y * percent, 0)
							end
						end
	
					elseif self.isFollowCamera and (not (isInFirstPerson or userRecentlyPannedCamera) and not VRService.VREnabled) then
						-- Logic that was unique to the old FollowCamera module
						local lastVec = -(self.lastCameraTransform.p - subjectPosition)
	
						local y = Util.GetAngleBetweenXZVectors(lastVec, self:GetCameraLookVector())
	
						-- This cutoff is to decide if the humanoid's angle of movement,
						-- relative to the camera's look vector, is enough that
						-- we want the camera to be following them. The point is to provide
						-- a sizable dead zone to allow more precise forward movements.
						local thetaCutoff = 0.4
	
						-- Check for NaNs
						if Util.IsFinite(y) and math.abs(y) > 0.0001 and math.abs(y) > thetaCutoff * timeDelta then
							self.rotateInput = self.rotateInput + Vector2.new(y, 0)
						end
					end
				end
			end
	
			if not self.isFollowCamera then
				local VREnabled = VRService.VREnabled
	
				if VREnabled then
					newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
				else
					newCameraFocus = CFrame.new(subjectPosition)
				end
	
				local cameraFocusP = newCameraFocus.p
				if VREnabled and not self:IsInFirstPerson() then
					local vecToSubject = (subjectPosition - camera.CFrame.p)
					local distToSubject = vecToSubject.magnitude
	
					-- Only move the camera if it exceeded a maximum distance to the subject in VR
					if distToSubject > zoom or self.rotateInput.x ~= 0 then
						local desiredDist = math.min(distToSubject, zoom)
						vecToSubject = self:CalculateNewLookVectorVR() * desiredDist
						local newPos = cameraFocusP - vecToSubject
						local desiredLookDir = camera.CFrame.lookVector
						if self.rotateInput.x ~= 0 then
							desiredLookDir = vecToSubject
						end
						local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
						self.rotateInput = ZERO_VECTOR2
	
						newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
					end
				else
					local newLookVector = self:CalculateNewLookVector(overrideCameraLookVector)
					self.rotateInput = ZERO_VECTOR2
					newCameraCFrame = CFrame.new(cameraFocusP - (zoom * newLookVector), cameraFocusP)
				end
			else -- is FollowCamera
				local newLookVector = self:CalculateNewLookVector(overrideCameraLookVector)
				self.rotateInput = ZERO_VECTOR2
	
				if VRService.VREnabled then
					newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
				else
					newCameraFocus = CFrame.new(subjectPosition)
				end
				newCameraCFrame = CFrame.new(newCameraFocus.p - (zoom * newLookVector), newCameraFocus.p) + Vector3.new(0, cameraHeight, 0)
			end
	
			if FFlagUserCameraToggle then
				local toggleOffset = self:GetCameraToggleOffset(timeDelta)
				newCameraFocus = newCameraFocus + toggleOffset
				newCameraCFrame = newCameraCFrame + toggleOffset
			end
	
			self.lastCameraTransform = newCameraCFrame
			self.lastCameraFocus = newCameraFocus
			if (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
				self.lastSubjectCFrame = cameraSubject.CFrame
			else
				self.lastSubjectCFrame = nil
			end
		end
	
		self.lastUpdate = now
		return newCameraCFrame, newCameraFocus
	end
	
	function ClassicCamera:EnterFirstPerson()
		self.inFirstPerson = true
		self:UpdateMouseBehavior()
	end
	
	function ClassicCamera:LeaveFirstPerson()
		self.inFirstPerson = false
		self:UpdateMouseBehavior()
	end
	
	return ClassicCamera
end

function _CameraUtils()

	local CameraUtils = {}
	
	local FFlagUserCameraToggle do
		local success, result = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserCameraToggle")
		end)
		FFlagUserCameraToggle = success and result
	end
	
	local function round(num)
		return math.floor(num + 0.5)
	end
	
	-- Critically damped spring class for fluid motion effects
	local Spring = {} do
		Spring.__index = Spring
	
		-- Initialize to a given undamped frequency and default position
		function Spring.new(freq, pos)
			return setmetatable({
				freq = freq,
				goal = pos,
				pos = pos,
				vel = 0,
			}, Spring)
		end
	
		-- Advance the spring simulation by `dt` seconds
		function Spring:step(dt)
			local f = self.freq*2*math.pi
			local g = self.goal
			local p0 = self.pos
			local v0 = self.vel
	
			local offset = p0 - g
			local decay = math.exp(-f*dt)
	
			local p1 = (offset*(1 + f*dt) + v0*dt)*decay + g
			local v1 = (v0*(1 - f*dt) - offset*(f*f*dt))*decay
	
			self.pos = p1
			self.vel = v1
	
			return p1
		end
	end
	
	CameraUtils.Spring = Spring
	
	-- map a value from one range to another
	function CameraUtils.map(x, inMin, inMax, outMin, outMax)
		return (x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin
	end
	
	-- From TransparencyController
	function CameraUtils.Round(num, places)
		local decimalPivot = 10^places
		return math.floor(num * decimalPivot + 0.5) / decimalPivot
	end
	
	function CameraUtils.IsFinite(val)
		return val == val and val ~= math.huge and val ~= -math.huge
	end
	
	function CameraUtils.IsFiniteVector3(vec3)
		return CameraUtils.IsFinite(vec3.X) and CameraUtils.IsFinite(vec3.Y) and CameraUtils.IsFinite(vec3.Z)
	end
	
	-- Legacy implementation renamed
	function CameraUtils.GetAngleBetweenXZVectors(v1, v2)
		return math.atan2(v2.X*v1.Z-v2.Z*v1.X, v2.X*v1.X+v2.Z*v1.Z)
	end
	
	function  CameraUtils.RotateVectorByAngleAndRound(camLook, rotateAngle, roundAmount)
		if camLook.Magnitude > 0 then
			camLook = camLook.unit
			local currAngle = math.atan2(camLook.z, camLook.x)
			local newAngle = round((math.atan2(camLook.z, camLook.x) + rotateAngle) / roundAmount) * roundAmount
			return newAngle - currAngle
		end
		return 0
	end
	
	-- K is a tunable parameter that changes the shape of the S-curve
	-- the larger K is the more straight/linear the curve gets
	local k = 0.35
	local lowerK = 0.8
	local function SCurveTranform(t)
		t = math.clamp(t, -1, 1)
		if t >= 0 then
			return (k*t) / (k - t + 1)
		end
		return -((lowerK*-t) / (lowerK + t + 1))
	end
	
	local DEADZONE = 0.1
	local function toSCurveSpace(t)
		return (1 + DEADZONE) * (2*math.abs(t) - 1) - DEADZONE
	end
	
	local function fromSCurveSpace(t)
		return t/2 + 0.5
	end
	
	function CameraUtils.GamepadLinearToCurve(thumbstickPosition)
		local function onAxis(axisValue)
			local sign = 1
			if axisValue < 0 then
				sign = -1
			end
			local point = fromSCurveSpace(SCurveTranform(toSCurveSpace(math.abs(axisValue))))
			point = point * sign
			return math.clamp(point, -1, 1)
		end
		return Vector2.new(onAxis(thumbstickPosition.x), onAxis(thumbstickPosition.y))
	end
	
	-- This function converts 4 different, redundant enumeration types to one standard so the values can be compared
	function CameraUtils.ConvertCameraModeEnumToStandard(enumValue)
		if enumValue == Enum.TouchCameraMovementMode.Default then
			return Enum.ComputerCameraMovementMode.Follow
		end
	
		if enumValue == Enum.ComputerCameraMovementMode.Default then
			return Enum.ComputerCameraMovementMode.Classic
		end
	
		if enumValue == Enum.TouchCameraMovementMode.Classic or
			enumValue == Enum.DevTouchCameraMovementMode.Classic or
			enumValue == Enum.DevComputerCameraMovementMode.Classic or
			enumValue == Enum.ComputerCameraMovementMode.Classic then
			return Enum.ComputerCameraMovementMode.Classic
		end
	
		if enumValue == Enum.TouchCameraMovementMode.Follow or
			enumValue == Enum.DevTouchCameraMovementMode.Follow or
			enumValue == Enum.DevComputerCameraMovementMode.Follow or
			enumValue == Enum.ComputerCameraMovementMode.Follow then
			return Enum.ComputerCameraMovementMode.Follow
		end
	
		if enumValue == Enum.TouchCameraMovementMode.Orbital or
			enumValue == Enum.DevTouchCameraMovementMode.Orbital or
			enumValue == Enum.DevComputerCameraMovementMode.Orbital or
			enumValue == Enum.ComputerCameraMovementMode.Orbital then
			return Enum.ComputerCameraMovementMode.Orbital
		end
	
		if FFlagUserCameraToggle then
			if enumValue == Enum.ComputerCameraMovementMode.CameraToggle or
				enumValue == Enum.DevComputerCameraMovementMode.CameraToggle then
				return Enum.ComputerCameraMovementMode.CameraToggle
			end
		end
	
		-- Note: Only the Dev versions of the Enums have UserChoice as an option
		if enumValue == Enum.DevTouchCameraMovementMode.UserChoice or
			enumValue == Enum.DevComputerCameraMovementMode.UserChoice then
			return Enum.DevComputerCameraMovementMode.UserChoice
		end
	
		-- For any unmapped options return Classic camera
		return Enum.ComputerCameraMovementMode.Classic
	end
	
	return CameraUtils
end

function _CameraModule()
	local CameraModule = {}
	CameraModule.__index = CameraModule
	
	local FFlagUserCameraToggle do
		local success, result = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserCameraToggle")
		end)
		FFlagUserCameraToggle = success and result
	end
	
	local FFlagUserRemoveTheCameraApi do
		local success, result = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserRemoveTheCameraApi")
		end)
		FFlagUserRemoveTheCameraApi = success and result
	end
	
	-- NOTICE: Player property names do not all match their StarterPlayer equivalents,
	-- with the differences noted in the comments on the right
	local PLAYER_CAMERA_PROPERTIES =
	{
		"CameraMinZoomDistance",
		"CameraMaxZoomDistance",
		"CameraMode",
		"DevCameraOcclusionMode",
		"DevComputerCameraMode",			-- Corresponds to StarterPlayer.DevComputerCameraMovementMode
		"DevTouchCameraMode",				-- Corresponds to StarterPlayer.DevTouchCameraMovementMode
	
		-- Character movement mode
		"DevComputerMovementMode",
		"DevTouchMovementMode",
		"DevEnableMouseLock",				-- Corresponds to StarterPlayer.EnableMouseLockOption
	}
	
	local USER_GAME_SETTINGS_PROPERTIES =
	{
		"ComputerCameraMovementMode",
		"ComputerMovementMode",
		"ControlMode",
		"GamepadCameraSensitivity",
		"MouseSensitivity",
		"RotationType",
		"TouchCameraMovementMode",
		"TouchMovementMode",
	}
	
	--[[ Roblox Services ]]--
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local UserGameSettings = UserSettings():GetService("UserGameSettings")
	
	-- Camera math utility library
	local CameraUtils = _CameraUtils()
	
	-- Load Roblox Camera Controller Modules
	local ClassicCamera = _ClassicCamera()
	local OrbitalCamera = _OrbitalCamera()
	local LegacyCamera = _LegacyCamera()
	
	-- Load Roblox Occlusion Modules
	local Invisicam = _Invisicam()
	local Poppercam = _Poppercam()
	
	-- Load the near-field character transparency controller and the mouse lock "shift lock" controller
	local TransparencyController = _TransparencyController()
	local MouseLockController = _MouseLockController()
	
	-- Table of camera controllers that have been instantiated. They are instantiated as they are used.
	local instantiatedCameraControllers = {}
	local instantiatedOcclusionModules = {}
	
	-- Management of which options appear on the Roblox User Settings screen
	do
		local PlayerScripts = Players.LocalPlayer:WaitForChild("PlayerScripts")
	
		PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Default)
		PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Follow)
		PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Classic)
	
		PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Default)
		PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Follow)
		PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Classic)
		if FFlagUserCameraToggle then
			PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.CameraToggle)
		end
	end
	
	CameraModule.FFlagUserCameraToggle = FFlagUserCameraToggle
	
	
	function CameraModule.new()
		local self = setmetatable({},CameraModule)
	
		-- Current active controller instances
		self.activeCameraController = nil
		self.activeOcclusionModule = nil
		self.activeTransparencyController = nil
		self.activeMouseLockController = nil
	
		self.currentComputerCameraMovementMode = nil
	
		-- Connections to events
		self.cameraSubjectChangedConn = nil
		self.cameraTypeChangedConn = nil
	
		-- Adds CharacterAdded and CharacterRemoving event handlers for all current players
		for _,player in pairs(Players:GetPlayers()) do
			self:OnPlayerAdded(player)
		end
	
		-- Adds CharacterAdded and CharacterRemoving event handlers for all players who join in the future
		Players.PlayerAdded:Connect(function(player)
			self:OnPlayerAdded(player)
		end)
	
		self.activeTransparencyController = TransparencyController.new()
		self.activeTransparencyController:Enable(true)
	
		if not UserInputService.TouchEnabled then
			self.activeMouseLockController = MouseLockController.new()
			local toggleEvent = self.activeMouseLockController:GetBindableToggleEvent()
			if toggleEvent then
				toggleEvent:Connect(function()
					self:OnMouseLockToggled()
				end)
			end
		end
	
		self:ActivateCameraController(self:GetCameraControlChoice())
		self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
		self:OnCurrentCameraChanged() -- Does initializations and makes first camera controller
		RunService:BindToRenderStep("cameraRenderUpdate", Enum.RenderPriority.Camera.Value, function(dt) self:Update(dt) end)
	
		-- Connect listeners to camera-related properties
		for _, propertyName in pairs(PLAYER_CAMERA_PROPERTIES) do
			Players.LocalPlayer:GetPropertyChangedSignal(propertyName):Connect(function()
				self:OnLocalPlayerCameraPropertyChanged(propertyName)
			end)
		end
	
		for _, propertyName in pairs(USER_GAME_SETTINGS_PROPERTIES) do
			UserGameSettings:GetPropertyChangedSignal(propertyName):Connect(function()
				self:OnUserGameSettingsPropertyChanged(propertyName)
			end)
		end
		game.Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
			self:OnCurrentCameraChanged()
		end)
	
		self.lastInputType = UserInputService:GetLastInputType()
		UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
			self.lastInputType = newLastInputType
		end)
	
		return self
	end
	
	function CameraModule:GetCameraMovementModeFromSettings()
		local cameraMode = Players.LocalPlayer.CameraMode
	
		-- Lock First Person trumps all other settings and forces ClassicCamera
		if cameraMode == Enum.CameraMode.LockFirstPerson then
			return CameraUtils.ConvertCameraModeEnumToStandard(Enum.ComputerCameraMovementMode.Classic)
		end
	
		local devMode, userMode
		if UserInputService.TouchEnabled then
			devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevTouchCameraMode)
			userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.TouchCameraMovementMode)
		else
			devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevComputerCameraMode)
			userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
		end
	
		if devMode == Enum.DevComputerCameraMovementMode.UserChoice then
			-- Developer is allowing user choice, so user setting is respected
			return userMode
		end
	
		return devMode
	end
	
	function CameraModule:ActivateOcclusionModule( occlusionMode )
		local newModuleCreator
		if occlusionMode == Enum.DevCameraOcclusionMode.Zoom then
			newModuleCreator = Poppercam
		elseif occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
			newModuleCreator = Invisicam
		else
			warn("CameraScript ActivateOcclusionModule called with unsupported mode")
			return
		end
	
		-- First check to see if there is actually a change. If the module being requested is already
		-- the currently-active solution then just make sure it's enabled and exit early
		if self.activeOcclusionModule and self.activeOcclusionModule:GetOcclusionMode() == occlusionMode then
			if not self.activeOcclusionModule:GetEnabled() then
				self.activeOcclusionModule:Enable(true)
			end
			return
		end
	
		-- Save a reference to the current active module (may be nil) so that we can disable it if
		-- we are successful in activating its replacement
		local prevOcclusionModule = self.activeOcclusionModule
	
		-- If there is no active module, see if the one we need has already been instantiated
		self.activeOcclusionModule = instantiatedOcclusionModules[newModuleCreator]
	
		-- If the module was not already instantiated and selected above, instantiate it
		if not self.activeOcclusionModule then
			self.activeOcclusionModule = newModuleCreator.new()
			if self.activeOcclusionModule then
				instantiatedOcclusionModules[newModuleCreator] = self.activeOcclusionModule
			end
		end
	
		-- If we were successful in either selecting or instantiating the module,
		-- enable it if it's not already the currently-active enabled module
		if self.activeOcclusionModule then
			local newModuleOcclusionMode = self.activeOcclusionModule:GetOcclusionMode()
			-- Sanity check that the module we selected or instantiated actually supports the desired occlusionMode
			if newModuleOcclusionMode ~= occlusionMode then
				warn("CameraScript ActivateOcclusionModule mismatch: ",self.activeOcclusionModule:GetOcclusionMode(),"~=",occlusionMode)
			end
	
			-- Deactivate current module if there is one
			if prevOcclusionModule then
				-- Sanity check that current module is not being replaced by itself (that should have been handled above)
				if prevOcclusionModule ~= self.activeOcclusionModule then
					prevOcclusionModule:Enable(false)
				else
					warn("CameraScript ActivateOcclusionModule failure to detect already running correct module")
				end
			end
	
			-- Occlusion modules need to be initialized with information about characters and cameraSubject
			-- Invisicam needs the LocalPlayer's character
			-- Poppercam needs all player characters and the camera subject
			if occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
				-- Optimization to only send Invisicam what we know it needs
				if Players.LocalPlayer.Character then
					self.activeOcclusionModule:CharacterAdded(Players.LocalPlayer.Character, Players.LocalPlayer )
				end
			else
				-- When Poppercam is enabled, we send it all existing player characters for its raycast ignore list
				for _, player in pairs(Players:GetPlayers()) do
					if player and player.Character then
						self.activeOcclusionModule:CharacterAdded(player.Character, player)
					end
				end
				self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
			end
	
			-- Activate new choice
			self.activeOcclusionModule:Enable(true)
		end
	end
	
	-- When supplied, legacyCameraType is used and cameraMovementMode is ignored (should be nil anyways)
	-- Next, if userCameraCreator is passed in, that is used as the cameraCreator
	function CameraModule:ActivateCameraController(cameraMovementMode, legacyCameraType)
		local newCameraCreator = nil
	
		if legacyCameraType~=nil then
			--[[
				This function has been passed a CameraType enum value. Some of these map to the use of
				the LegacyCamera module, the value "Custom" will be translated to a movementMode enum
				value based on Dev and User settings, and "Scriptable" will disable the camera controller.
			--]]
	
			if legacyCameraType == Enum.CameraType.Scriptable then
				if self.activeCameraController then
					self.activeCameraController:Enable(false)
					self.activeCameraController = nil
					return
				end
			elseif legacyCameraType == Enum.CameraType.Custom then
				cameraMovementMode = self:GetCameraMovementModeFromSettings()
	
			elseif legacyCameraType == Enum.CameraType.Track then
				-- Note: The TrackCamera module was basically an older, less fully-featured
				-- version of ClassicCamera, no longer actively maintained, but it is re-implemented in
				-- case a game was dependent on its lack of ClassicCamera's extra functionality.
				cameraMovementMode = Enum.ComputerCameraMovementMode.Classic
	
			elseif legacyCameraType == Enum.CameraType.Follow then
				cameraMovementMode = Enum.ComputerCameraMovementMode.Follow
	
			elseif legacyCameraType == Enum.CameraType.Orbital then
				cameraMovementMode = Enum.ComputerCameraMovementMode.Orbital
	
			elseif legacyCameraType == Enum.CameraType.Attach or
				   legacyCameraType == Enum.CameraType.Watch or
				   legacyCameraType == Enum.CameraType.Fixed then
				newCameraCreator = LegacyCamera
			else
				warn("CameraScript encountered an unhandled Camera.CameraType value: ",legacyCameraType)
			end
		end
	
		if not newCameraCreator then
			if cameraMovementMode == Enum.ComputerCameraMovementMode.Classic or
				cameraMovementMode == Enum.ComputerCameraMovementMode.Follow or
				cameraMovementMode == Enum.ComputerCameraMovementMode.Default or
				(FFlagUserCameraToggle and cameraMovementMode == Enum.ComputerCameraMovementMode.CameraToggle) then
				newCameraCreator = ClassicCamera
			elseif cameraMovementMode == Enum.ComputerCameraMovementMode.Orbital then
				newCameraCreator = OrbitalCamera
			else
				warn("ActivateCameraController did not select a module.")
				return
			end
		end
	
		-- Create the camera control module we need if it does not already exist in instantiatedCameraControllers
		local newCameraController
		if not instantiatedCameraControllers[newCameraCreator] then
			newCameraController = newCameraCreator.new()
			instantiatedCameraControllers[newCameraCreator] = newCameraController
		else
			newCameraController = instantiatedCameraControllers[newCameraCreator]
		end
	
		-- If there is a controller active and it's not the one we need, disable it,
		-- if it is the one we need, make sure it's enabled
		if self.activeCameraController then
			if self.activeCameraController ~= newCameraController then
				self.activeCameraController:Enable(false)
				self.activeCameraController = newCameraController
				self.activeCameraController:Enable(true)
			elseif not self.activeCameraController:GetEnabled() then
				self.activeCameraController:Enable(true)
			end
		elseif newCameraController ~= nil then
			self.activeCameraController = newCameraController
			self.activeCameraController:Enable(true)
		end
	
		if self.activeCameraController then
			if cameraMovementMode~=nil then
				self.activeCameraController:SetCameraMovementMode(cameraMovementMode)
			elseif legacyCameraType~=nil then
				-- Note that this is only called when legacyCameraType is not a type that
				-- was convertible to a ComputerCameraMovementMode value, i.e. really only applies to LegacyCamera
				self.activeCameraController:SetCameraType(legacyCameraType)
			end
		end
	end
	
	-- Note: The active transparency controller could be made to listen for this event itself.
	function CameraModule:OnCameraSubjectChanged()
		if self.activeTransparencyController then
			self.activeTransparencyController:SetSubject(game.Workspace.CurrentCamera.CameraSubject)
		end
	
		if self.activeOcclusionModule then
			self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
		end
	end
	
	function CameraModule:OnCameraTypeChanged(newCameraType)
		if newCameraType == Enum.CameraType.Scriptable then
			if UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
				UserInputService.MouseBehavior = Enum.MouseBehavior.Default
			end
		end
	
		-- Forward the change to ActivateCameraController to handle
		self:ActivateCameraController(nil, newCameraType)
	end
	
	-- Note: Called whenever workspace.CurrentCamera changes, but also on initialization of this script
	function CameraModule:OnCurrentCameraChanged()
		local currentCamera = game.Workspace.CurrentCamera
		if not currentCamera then return end
	
		if self.cameraSubjectChangedConn then
			self.cameraSubjectChangedConn:Disconnect()
		end
	
		if self.cameraTypeChangedConn then
			self.cameraTypeChangedConn:Disconnect()
		end
	
		self.cameraSubjectChangedConn = currentCamera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
			self:OnCameraSubjectChanged(currentCamera.CameraSubject)
		end)
	
		self.cameraTypeChangedConn = currentCamera:GetPropertyChangedSignal("CameraType"):Connect(function()
			self:OnCameraTypeChanged(currentCamera.CameraType)
		end)
	
		self:OnCameraSubjectChanged(currentCamera.CameraSubject)
		self:OnCameraTypeChanged(currentCamera.CameraType)
	end
	
	function CameraModule:OnLocalPlayerCameraPropertyChanged(propertyName)
		if propertyName == "CameraMode" then
			-- CameraMode is only used to turn on/off forcing the player into first person view. The
			-- Note: The case "Classic" is used for all other views and does not correspond only to the ClassicCamera module
			if Players.LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson then
				-- Locked in first person, use ClassicCamera which supports this
				if not self.activeCameraController or self.activeCameraController:GetModuleName() ~= "ClassicCamera" then
					self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(Enum.DevComputerCameraMovementMode.Classic))
				end
	
				if self.activeCameraController then
					self.activeCameraController:UpdateForDistancePropertyChange()
				end
			elseif Players.LocalPlayer.CameraMode == Enum.CameraMode.Classic then
				-- Not locked in first person view
				local cameraMovementMode =self: GetCameraMovementModeFromSettings()
				self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
			else
				warn("Unhandled value for property player.CameraMode: ",Players.LocalPlayer.CameraMode)
			end
	
		elseif propertyName == "DevComputerCameraMode" or 
			   propertyName == "DevTouchCameraMode" then
			local cameraMovementMode = self:GetCameraMovementModeFromSettings()
			self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
	
		elseif propertyName == "DevCameraOcclusionMode" then
			self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
	
		elseif propertyName == "CameraMinZoomDistance" or propertyName == "CameraMaxZoomDistance" then
			if self.activeCameraController then
				self.activeCameraController:UpdateForDistancePropertyChange()
			end
		elseif propertyName == "DevTouchMovementMode" then
		elseif propertyName == "DevComputerMovementMode" then
		elseif propertyName == "DevEnableMouseLock" then
			-- This is the enabling/disabling of "Shift Lock" mode, not LockFirstPerson (which is a CameraMode)
			-- Note: Enabling and disabling of MouseLock mode is normally only a publish-time choice made via
			-- the corresponding EnableMouseLockOption checkbox of StarterPlayer, and this script does not have
			-- support for changing the availability of MouseLock at runtime (this would require listening to
			-- Player.DevEnableMouseLock changes)
		end
	end
	
	function CameraModule:OnUserGameSettingsPropertyChanged(propertyName)
		if propertyName == 	"ComputerCameraMovementMode" then
			local cameraMovementMode = self:GetCameraMovementModeFromSettings()
			self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
		end
	end
	
	--[[
		Main RenderStep Update. The camera controller and occlusion module both have opportunities
		to set and modify (respectively) the CFrame and Focus before it is set once on CurrentCamera.
		The camera and occlusion modules should only return CFrames, not set the CFrame property of
		CurrentCamera directly.
	--]]
	function CameraModule:Update(dt)
		if self.activeCameraController then
			if FFlagUserCameraToggle then
				self.activeCameraController:UpdateMouseBehavior()
			end
	
			local newCameraCFrame, newCameraFocus = self.activeCameraController:Update(dt)
			self.activeCameraController:ApplyVRTransform()
			if self.activeOcclusionModule then
				newCameraCFrame, newCameraFocus = self.activeOcclusionModule:Update(dt, newCameraCFrame, newCameraFocus)
			end
	
			-- Here is where the new CFrame and Focus are set for this render frame
			game.Workspace.CurrentCamera.CFrame = newCameraCFrame
			game.Workspace.CurrentCamera.Focus = newCameraFocus
	
			-- Update to character local transparency as needed based on camera-to-subject distance
			if self.activeTransparencyController then
				self.activeTransparencyController:Update()
			end
		end
	end
	
	-- Formerly getCurrentCameraMode, this function resolves developer and user camera control settings to
	-- decide which camera control module should be instantiated. The old method of converting redundant enum types
	function CameraModule:GetCameraControlChoice()
		local player = Players.LocalPlayer
	
		if player then
			if self.lastInputType == Enum.UserInputType.Touch or UserInputService.TouchEnabled then
				-- Touch
				if player.DevTouchCameraMode == Enum.DevTouchCameraMovementMode.UserChoice then
					return CameraUtils.ConvertCameraModeEnumToStandard( UserGameSettings.TouchCameraMovementMode )
				else
					return CameraUtils.ConvertCameraModeEnumToStandard( player.DevTouchCameraMode )
				end
			else
				-- Computer
				if player.DevComputerCameraMode == Enum.DevComputerCameraMovementMode.UserChoice then
					local computerMovementMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
					return CameraUtils.ConvertCameraModeEnumToStandard(computerMovementMode)
				else
					return CameraUtils.ConvertCameraModeEnumToStandard(player.DevComputerCameraMode)
				end
			end
		end
	end
	
	function CameraModule:OnCharacterAdded(char, player)
		if self.activeOcclusionModule then
			self.activeOcclusionModule:CharacterAdded(char, player)
		end
	end
	
	function CameraModule:OnCharacterRemoving(char, player)
		if self.activeOcclusionModule then
			self.activeOcclusionModule:CharacterRemoving(char, player)
		end
	end
	
	function CameraModule:OnPlayerAdded(player)
		player.CharacterAdded:Connect(function(char)
			self:OnCharacterAdded(char, player)
		end)
		player.CharacterRemoving:Connect(function(char)
			self:OnCharacterRemoving(char, player)
		end)
	end
	
	function CameraModule:OnMouseLockToggled()
		if self.activeMouseLockController then
			local mouseLocked = self.activeMouseLockController:GetIsMouseLocked()
			local mouseLockOffset = self.activeMouseLockController:GetMouseLockOffset()
			if self.activeCameraController then
				self.activeCameraController:SetIsMouseLocked(mouseLocked)
				self.activeCameraController:SetMouseLockOffset(mouseLockOffset)
			end
		end
	end
	--begin edit
	local Camera = CameraModule
	local IDENTITYCF = CFrame.new()
	local lastUpCFrame = IDENTITYCF
	
	Camera.UpVector = Vector3.new(0, 1, 0)
	Camera.TransitionRate = 0.15
	Camera.UpCFrame = IDENTITYCF
	
	function Camera:GetUpVector(oldUpVector)
		return oldUpVector
	end
	local function getRotationBetween(u, v, axis)
		local dot, uxv = u:Dot(v), u:Cross(v)
		if (dot < -0.99999) then return CFrame.fromAxisAngle(axis, math.pi) end
		return CFrame.new(0, 0, 0, uxv.x, uxv.y, uxv.z, 1 + dot)
	end
	function Camera:CalculateUpCFrame()
		local oldUpVector = self.UpVector
		local newUpVector = self:GetUpVector(oldUpVector)
		
		local backup = game.Workspace.CurrentCamera.CFrame.RightVector
		local transitionCF = getRotationBetween(oldUpVector, newUpVector, backup)
		local vecSlerpCF = IDENTITYCF:Lerp(transitionCF, self.TransitionRate)
		
		self.UpVector = vecSlerpCF * oldUpVector
		self.UpCFrame = vecSlerpCF * self.UpCFrame
		
		lastUpCFrame = self.UpCFrame
	end
	
	function Camera:Update(dt)
		if self.activeCameraController then
			if Camera.FFlagUserCameraToggle then
				self.activeCameraController:UpdateMouseBehavior()
			end
			
			local newCameraCFrame, newCameraFocus = self.activeCameraController:Update(dt)
			self.activeCameraController:ApplyVRTransform()
			
			self:CalculateUpCFrame()
			self.activeCameraController:UpdateUpCFrame(self.UpCFrame)
			
			-- undo shift-lock offset
	
			local lockOffset = Vector3.new(0, 0, 0)
			if (self.activeMouseLockController and self.activeMouseLockController:GetIsMouseLocked()) then
				lockOffset = self.activeMouseLockController:GetMouseLockOffset()
			end
			
			local offset = newCameraFocus:ToObjectSpace(newCameraCFrame)
			local camRotation = self.UpCFrame * offset
			newCameraFocus = newCameraFocus - newCameraCFrame:VectorToWorldSpace(lockOffset) + camRotation:VectorToWorldSpace(lockOffset)
			newCameraCFrame = newCameraFocus * camRotation
			
			--local offset = newCameraFocus:Inverse() * newCameraCFrame
			--newCameraCFrame = newCameraFocus * self.UpCFrame * offset
			
			if (self.activeCameraController.lastCameraTransform) then
				self.activeCameraController.lastCameraTransform = newCameraCFrame
				self.activeCameraController.lastCameraFocus = newCameraFocus
			end
			
			if self.activeOcclusionModule then
				newCameraCFrame, newCameraFocus = self.activeOcclusionModule:Update(dt, newCameraCFrame, newCameraFocus)
			end
	
			game.Workspace.CurrentCamera.CFrame = newCameraCFrame
			game.Workspace.CurrentCamera.Focus = newCameraFocus
	
			if self.activeTransparencyController then
				self.activeTransparencyController:Update()
			end
		end
	end
	
	function Camera:IsFirstPerson()
		if self.activeCameraController then
			return self.activeCameraController:InFirstPerson()
		end
		return false
	end
	
	function Camera:IsMouseLocked()
		if self.activeCameraController then
			return self.activeCameraController:GetIsMouseLocked()
		end
		return false
	end
	function Camera:IsToggleMode()
		if self.activeCameraController then
			return self.activeCameraController.isCameraToggle
		end
		return false
	end
	function Camera:IsCamRelative()
		return self:IsMouseLocked() or self:IsFirstPerson()
		--return self:IsToggleMode(), self:IsMouseLocked(), self:IsFirstPerson()
	end
	--
	local Utils = _CameraUtils()
	function Utils.GetAngleBetweenXZVectors(v1, v2)
		local upCFrame = lastUpCFrame
		v1 = upCFrame:VectorToObjectSpace(v1)
		v2 = upCFrame:VectorToObjectSpace(v2)
		return math.atan2(v2.X*v1.Z-v2.Z*v1.X, v2.X*v1.X+v2.Z*v1.Z)
	end
	--end edit
	local cameraModuleObject = CameraModule.new()
	local cameraApi = {}
	return cameraModuleObject
end

function _ClickToMoveDisplay()
	local ClickToMoveDisplay = {}
	
	local FAILURE_ANIMATION_ID = "rbxassetid://2874840706"
	
	local TrailDotIcon = "rbxasset://textures/ui/traildot.png"
	local EndWaypointIcon = "rbxasset://textures/ui/waypoint.png"
	
	local WaypointsAlwaysOnTop = false
	
	local WAYPOINT_INCLUDE_FACTOR = 2
	local LAST_DOT_DISTANCE = 3
	
	local WAYPOINT_BILLBOARD_SIZE = UDim2.new(0, 1.68 * 25, 0, 2 * 25)
	
	local ENDWAYPOINT_SIZE_OFFSET_MIN = Vector2.new(0, 0.5)
	local ENDWAYPOINT_SIZE_OFFSET_MAX = Vector2.new(0, 1)
	
	local FAIL_WAYPOINT_SIZE_OFFSET_CENTER = Vector2.new(0, 0.5)
	local FAIL_WAYPOINT_SIZE_OFFSET_LEFT = Vector2.new(0.1, 0.5)
	local FAIL_WAYPOINT_SIZE_OFFSET_RIGHT = Vector2.new(-0.1, 0.5)
	
	local FAILURE_TWEEN_LENGTH = 0.125
	local FAILURE_TWEEN_COUNT = 4
	
	local TWEEN_WAYPOINT_THRESHOLD = 5
	
	local TRAIL_DOT_PARENT_NAME = "ClickToMoveDisplay"
	
	local TrailDotSize = Vector2.new(1.5, 1.5)
	
	local TRAIL_DOT_MIN_SCALE = 1
	local TRAIL_DOT_MIN_DISTANCE = 10
	local TRAIL_DOT_MAX_SCALE = 2.5
	local TRAIL_DOT_MAX_DISTANCE = 100
	
	local PlayersService = game:GetService("Players")
	local TweenService = game:GetService("TweenService")
	local RunService = game:GetService("RunService")
	local Workspace = game:GetService("Workspace")
	
	local LocalPlayer = PlayersService.LocalPlayer
	
	local function CreateWaypointTemplates()
		local TrailDotTemplate = Instance.new("Part")
		TrailDotTemplate.Size = Vector3.new(1, 1, 1)
		TrailDotTemplate.Anchored = true
		TrailDotTemplate.CanCollide = false
		TrailDotTemplate.Name = "TrailDot"
		TrailDotTemplate.Transparency = 1
		local TrailDotImage = Instance.new("ImageHandleAdornment")
		TrailDotImage.Name = "TrailDotImage"
		TrailDotImage.Size = TrailDotSize
		TrailDotImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
		TrailDotImage.AlwaysOnTop = WaypointsAlwaysOnTop
		TrailDotImage.Image = TrailDotIcon
		TrailDotImage.Adornee = TrailDotTemplate
		TrailDotImage.Parent = TrailDotTemplate
	
		local EndWaypointTemplate = Instance.new("Part")
		EndWaypointTemplate.Size = Vector3.new(2, 2, 2)
		EndWaypointTemplate.Anchored = true
		EndWaypointTemplate.CanCollide = false
		EndWaypointTemplate.Name = "EndWaypoint"
		EndWaypointTemplate.Transparency = 1
		local EndWaypointImage = Instance.new("ImageHandleAdornment")
		EndWaypointImage.Name = "TrailDotImage"
		EndWaypointImage.Size = TrailDotSize
		EndWaypointImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
		EndWaypointImage.AlwaysOnTop = WaypointsAlwaysOnTop
		EndWaypointImage.Image = TrailDotIcon
		EndWaypointImage.Adornee = EndWaypointTemplate
		EndWaypointImage.Parent = EndWaypointTemplate
		local EndWaypointBillboard = Instance.new("BillboardGui")
		EndWaypointBillboard.Name = "EndWaypointBillboard"
		EndWaypointBillboard.Size = WAYPOINT_BILLBOARD_SIZE
		EndWaypointBillboard.LightInfluence = 0
		EndWaypointBillboard.SizeOffset = ENDWAYPOINT_SIZE_OFFSET_MIN
		EndWaypointBillboard.AlwaysOnTop = true
		EndWaypointBillboard.Adornee = EndWaypointTemplate
		EndWaypointBillboard.Parent = EndWaypointTemplate
		local EndWaypointImageLabel = Instance.new("ImageLabel")
		EndWaypointImageLabel.Image = EndWaypointIcon
		EndWaypointImageLabel.BackgroundTransparency = 1
		EndWaypointImageLabel.Size = UDim2.new(1, 0, 1, 0)
		EndWaypointImageLabel.Parent = EndWaypointBillboard
	
	
		local FailureWaypointTemplate = Instance.new("Part")
		FailureWaypointTemplate.Size = Vector3.new(2, 2, 2)
		FailureWaypointTemplate.Anchored = true
		FailureWaypointTemplate.CanCollide = false
		FailureWaypointTemplate.Name = "FailureWaypoint"
		FailureWaypointTemplate.Transparency = 1
		local FailureWaypointImage = Instance.new("ImageHandleAdornment")
		FailureWaypointImage.Name = "TrailDotImage"
		FailureWaypointImage.Size = TrailDotSize
		FailureWaypointImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
		FailureWaypointImage.AlwaysOnTop = WaypointsAlwaysOnTop
		FailureWaypointImage.Image = TrailDotIcon
		FailureWaypointImage.Adornee = FailureWaypointTemplate
		FailureWaypointImage.Parent = FailureWaypointTemplate
		local FailureWaypointBillboard = Instance.new("BillboardGui")
		FailureWaypointBillboard.Name = "FailureWaypointBillboard"
		FailureWaypointBillboard.Size = WAYPOINT_BILLBOARD_SIZE
		FailureWaypointBillboard.LightInfluence = 0
		FailureWaypointBillboard.SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_CENTER
		FailureWaypointBillboard.AlwaysOnTop = true
		FailureWaypointBillboard.Adornee = FailureWaypointTemplate
		FailureWaypointBillboard.Parent = FailureWaypointTemplate
		local FailureWaypointFrame = Instance.new("Frame")
		FailureWaypointFrame.BackgroundTransparency = 1
		FailureWaypointFrame.Size = UDim2.new(0, 0, 0, 0)
		FailureWaypointFrame.Position = UDim2.new(0.5, 0, 1, 0)
		FailureWaypointFrame.Parent = FailureWaypointBillboard
		local FailureWaypointImageLabel = Instance.new("ImageLabel")
		FailureWaypointImageLabel.Image = EndWaypointIcon
		FailureWaypointImageLabel.BackgroundTransparency = 1
		FailureWaypointImageLabel.Position = UDim2.new(
			0, -WAYPOINT_BILLBOARD_SIZE.X.Offset/2, 0, -WAYPOINT_BILLBOARD_SIZE.Y.Offset
		)
		FailureWaypointImageLabel.Size = WAYPOINT_BILLBOARD_SIZE
		FailureWaypointImageLabel.Parent = FailureWaypointFrame
	
		return TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate
	end
	
	local TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
	
	local function getTrailDotParent()
		local camera = Workspace.CurrentCamera
		local trailParent = camera:FindFirstChild(TRAIL_DOT_PARENT_NAME)
		if not trailParent then
			trailParent = Instance.new("Model")
			trailParent.Name = TRAIL_DOT_PARENT_NAME
			trailParent.Parent = camera
		end
		return trailParent
	end
	
	local function placePathWaypoint(waypointModel, position)
		local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
		local hitPart, hitPoint, hitNormal = Workspace:FindPartOnRayWithIgnoreList(
			ray,
			{ Workspace.CurrentCamera, LocalPlayer.Character }
		)
		if hitPart then
			waypointModel.CFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
			waypointModel.Parent = getTrailDotParent()
		end
	end
	
	local TrailDot = {}
	TrailDot.__index = TrailDot
	
	function TrailDot:Destroy()
		self.DisplayModel:Destroy()
	end
	
	function TrailDot:NewDisplayModel(position)
		local newDisplayModel = TrailDotTemplate:Clone()
		placePathWaypoint(newDisplayModel, position)
		return newDisplayModel
	end
	
	function TrailDot.new(position, closestWaypoint)
		local self = setmetatable({}, TrailDot)
	
		self.DisplayModel = self:NewDisplayModel(position)
		self.ClosestWayPoint = closestWaypoint
	
		return self
	end
	
	local EndWaypoint = {}
	EndWaypoint.__index = EndWaypoint
	
	function EndWaypoint:Destroy()
		self.Destroyed = true
		self.Tween:Cancel()
		self.DisplayModel:Destroy()
	end
	
	function EndWaypoint:NewDisplayModel(position)
		local newDisplayModel = EndWaypointTemplate:Clone()
		placePathWaypoint(newDisplayModel, position)
		return newDisplayModel
	end
	
	function EndWaypoint:CreateTween()
		local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, -1, true)
		local tween = TweenService:Create(
			self.DisplayModel.EndWaypointBillboard,
			tweenInfo,
			{ SizeOffset = ENDWAYPOINT_SIZE_OFFSET_MAX }
		)
		tween:Play()
		return tween
	end
	
	function EndWaypoint:TweenInFrom(originalPosition)
		local currentPositon = self.DisplayModel.Position
		local studsOffset = originalPosition - currentPositon
		self.DisplayModel.EndWaypointBillboard.StudsOffset = Vector3.new(0, studsOffset.Y, 0)
		local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		local tween = TweenService:Create(
			self.DisplayModel.EndWaypointBillboard,
			tweenInfo,
			{ StudsOffset = Vector3.new(0, 0, 0) }
		)
		tween:Play()
		return tween
	end
	
	function EndWaypoint.new(position, closestWaypoint, originalPosition)
		local self = setmetatable({}, EndWaypoint)
	
		self.DisplayModel = self:NewDisplayModel(position)
		self.Destroyed = false
		if originalPosition and (originalPosition - position).magnitude > TWEEN_WAYPOINT_THRESHOLD then
			self.Tween = self:TweenInFrom(originalPosition)
			coroutine.wrap(function()
				self.Tween.Completed:Wait()
				if not self.Destroyed then
					self.Tween = self:CreateTween()
				end
			end)()
		else
			self.Tween = self:CreateTween()
		end
		self.ClosestWayPoint = closestWaypoint
	
		return self
	end
	
	local FailureWaypoint = {}
	FailureWaypoint.__index = FailureWaypoint
	
	function FailureWaypoint:Hide()
		self.DisplayModel.Parent = nil
	end
	
	function FailureWaypoint:Destroy()
		self.DisplayModel:Destroy()
	end
	
	function FailureWaypoint:NewDisplayModel(position)
		local newDisplayModel = FailureWaypointTemplate:Clone()
		placePathWaypoint(newDisplayModel, position)
		local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
		local hitPart, hitPoint, hitNormal = Workspace:FindPartOnRayWithIgnoreList(
			ray, { Workspace.CurrentCamera, LocalPlayer.Character }
		)
		if hitPart then
			newDisplayModel.CFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
			newDisplayModel.Parent = getTrailDotParent()
		end
		return newDisplayModel
	end
	
	function FailureWaypoint:RunFailureTween()
		wait(FAILURE_TWEEN_LENGTH) -- Delay one tween length betfore starting tweening
		-- Tween out from center
		local tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH/2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		local tweenLeft = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
			{ SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_LEFT })
		tweenLeft:Play()
	
		local tweenLeftRoation = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
			{ Rotation = 10 })
		tweenLeftRoation:Play()
	
		tweenLeft.Completed:wait()
	
		-- Tween back and forth
		tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH, Enum.EasingStyle.Sine, Enum.EasingDirection.Out,
			FAILURE_TWEEN_COUNT - 1, true)
		local tweenSideToSide = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
			{ SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_RIGHT})
		tweenSideToSide:Play()
	
		-- Tween flash dark and roate left and right
		tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH, Enum.EasingStyle.Sine, Enum.EasingDirection.Out,
			FAILURE_TWEEN_COUNT - 1, true)
		local tweenFlash = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame.ImageLabel, tweenInfo,
			{ ImageColor3 = Color3.new(0.75, 0.75, 0.75)})
		tweenFlash:Play()
	
		local tweenRotate = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
			{ Rotation = -10 })
		tweenRotate:Play()
	
		tweenSideToSide.Completed:wait()
	
		-- Tween back to center
		tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH/2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		local tweenCenter = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
			{ SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_CENTER })
		tweenCenter:Play()
	
		local tweenRoation = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
			{ Rotation = 0 })
		tweenRoation:Play()
	
		tweenCenter.Completed:wait()
	
		wait(FAILURE_TWEEN_LENGTH) -- Delay one tween length betfore removing
	end
	
	function FailureWaypoint.new(position)
		local self = setmetatable({}, FailureWaypoint)
	
		self.DisplayModel = self:NewDisplayModel(position)
	
		return self
	end
	
	local failureAnimation = Instance.new("Animation")
	failureAnimation.AnimationId = FAILURE_ANIMATION_ID
	
	local lastHumanoid = nil
	local lastFailureAnimationTrack = nil
	
	local function getFailureAnimationTrack(myHumanoid)
		if myHumanoid == lastHumanoid then
			return lastFailureAnimationTrack
		end
		lastFailureAnimationTrack = myHumanoid:LoadAnimation(failureAnimation)
		lastFailureAnimationTrack.Priority = Enum.AnimationPriority.Action
		lastFailureAnimationTrack.Looped = false
		return lastFailureAnimationTrack
	end
	
	local function findPlayerHumanoid()
		local character = LocalPlayer.Character
		if character then
			return character:FindFirstChildOfClass("Humanoid")
		end
	end
	
	local function createTrailDots(wayPoints, originalEndWaypoint)
		local newTrailDots = {}
		local count = 1
		for i = 1, #wayPoints - 1 do
			local closeToEnd = (wayPoints[i].Position - wayPoints[#wayPoints].Position).magnitude < LAST_DOT_DISTANCE
			local includeWaypoint = i % WAYPOINT_INCLUDE_FACTOR == 0 and not closeToEnd
			if includeWaypoint then
				local trailDot = TrailDot.new(wayPoints[i].Position, i)
				newTrailDots[count] = trailDot
				count = count + 1
			end
		end
	
		local newEndWaypoint = EndWaypoint.new(wayPoints[#wayPoints].Position, #wayPoints, originalEndWaypoint)
		table.insert(newTrailDots, newEndWaypoint)
	
		local reversedTrailDots = {}
		count = 1
		for i = #newTrailDots, 1, -1 do
			reversedTrailDots[count] = newTrailDots[i]
			count = count + 1
		end
		return reversedTrailDots
	end
	
	local function getTrailDotScale(distanceToCamera, defaultSize)
		local rangeLength = TRAIL_DOT_MAX_DISTANCE - TRAIL_DOT_MIN_DISTANCE
		local inRangePoint = math.clamp(distanceToCamera - TRAIL_DOT_MIN_DISTANCE, 0, rangeLength)/rangeLength
		local scale = TRAIL_DOT_MIN_SCALE + (TRAIL_DOT_MAX_SCALE - TRAIL_DOT_MIN_SCALE)*inRangePoint
		return defaultSize * scale
	end
	
	local createPathCount = 0
	-- originalEndWaypoint is optional, causes the waypoint to tween from that position.
	function ClickToMoveDisplay.CreatePathDisplay(wayPoints, originalEndWaypoint)
		createPathCount = createPathCount + 1
		local trailDots = createTrailDots(wayPoints, originalEndWaypoint)
	
		local function removePathBeforePoint(wayPointNumber)
			-- kill all trailDots before and at wayPointNumber
			for i = #trailDots, 1, -1 do
				local trailDot = trailDots[i]
				if trailDot.ClosestWayPoint <= wayPointNumber then
					trailDot:Destroy()
					trailDots[i] = nil
				else
					break
				end
			end
		end
	
		local reiszeTrailDotsUpdateName = "ClickToMoveResizeTrail" ..createPathCount
		local function resizeTrailDots()
			if #trailDots == 0 then
				RunService:UnbindFromRenderStep(reiszeTrailDotsUpdateName)
				return
			end
			local cameraPos = Workspace.CurrentCamera.CFrame.p
			for i = 1, #trailDots do
				local trailDotImage = trailDots[i].DisplayModel:FindFirstChild("TrailDotImage")
				if trailDotImage then
					local distanceToCamera = (trailDots[i].DisplayModel.Position - cameraPos).magnitude
					trailDotImage.Size = getTrailDotScale(distanceToCamera, TrailDotSize)
				end
			end
		end
		RunService:BindToRenderStep(reiszeTrailDotsUpdateName, Enum.RenderPriority.Camera.Value - 1, resizeTrailDots)
	
		local function removePath()
			removePathBeforePoint(#wayPoints)
		end
	
		return removePath, removePathBeforePoint
	end
	
	local lastFailureWaypoint = nil
	function ClickToMoveDisplay.DisplayFailureWaypoint(position)
		if lastFailureWaypoint then
			lastFailureWaypoint:Hide()
		end
		local failureWaypoint = FailureWaypoint.new(position)
		lastFailureWaypoint = failureWaypoint
		coroutine.wrap(function()
			failureWaypoint:RunFailureTween()
			failureWaypoint:Destroy()
			failureWaypoint = nil
		end)()
	end
	
	function ClickToMoveDisplay.CreateEndWaypoint(position)
		return EndWaypoint.new(position)
	end
	
	function ClickToMoveDisplay.PlayFailureAnimation()
		local myHumanoid = findPlayerHumanoid()
		if myHumanoid then
			local animationTrack = getFailureAnimationTrack(myHumanoid)
			animationTrack:Play()
		end
	end
	
	function ClickToMoveDisplay.CancelFailureAnimation()
		if lastFailureAnimationTrack ~= nil and lastFailureAnimationTrack.IsPlaying then
			lastFailureAnimationTrack:Stop()
		end
	end
	
	function ClickToMoveDisplay.SetWaypointTexture(texture)
		TrailDotIcon = texture
		TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
	end
	
	function ClickToMoveDisplay.GetWaypointTexture()
		return TrailDotIcon
	end
	
	function ClickToMoveDisplay.SetWaypointRadius(radius)
		TrailDotSize = Vector2.new(radius, radius)
		TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
	end
	
	function ClickToMoveDisplay.GetWaypointRadius()
		return TrailDotSize.X
	end
	
	function ClickToMoveDisplay.SetEndWaypointTexture(texture)
		EndWaypointIcon = texture
		TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
	end
	
	function ClickToMoveDisplay.GetEndWaypointTexture()
		return EndWaypointIcon
	end
	
	function ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
		WaypointsAlwaysOnTop = alwaysOnTop
		TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
	end
	
	function ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
		return WaypointsAlwaysOnTop
	end
	
	return ClickToMoveDisplay
end

function _BaseCharacterController()

	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	
	--[[ The Module ]]--
	local BaseCharacterController = {}
	BaseCharacterController.__index = BaseCharacterController
	
	function BaseCharacterController.new()
		local self = setmetatable({}, BaseCharacterController)
		self.enabled = false
		self.moveVector = ZERO_VECTOR3
		self.moveVectorIsCameraRelative = true
		self.isJumping = false
		return self
	end
	
	function BaseCharacterController:OnRenderStepped(dt)
		-- By default, nothing to do
	end
	
	function BaseCharacterController:GetMoveVector()
		return self.moveVector
	end
	
	function BaseCharacterController:IsMoveVectorCameraRelative()
		return self.moveVectorIsCameraRelative
	end
	
	function BaseCharacterController:GetIsJumping()
		return self.isJumping
	end
	
	-- Override in derived classes to set self.enabled and return boolean indicating
	-- whether Enable/Disable was successful. Return true if controller is already in the requested state.
	function BaseCharacterController:Enable(enable)
		error("BaseCharacterController:Enable must be overridden in derived classes and should not be called.")
		return false
	end
	
	return BaseCharacterController
end

function _VehicleController()
	local ContextActionService = game:GetService("ContextActionService")
	
	--[[ Constants ]]--
	-- Set this to true if you want to instead use the triggers for the throttle
	local useTriggersForThrottle = true
	-- Also set this to true if you want the thumbstick to not affect throttle, only triggers when a gamepad is conected
	local onlyTriggersForThrottle = false
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	
	local AUTO_PILOT_DEFAULT_MAX_STEERING_ANGLE = 35
	
	
	-- Note that VehicleController does not derive from BaseCharacterController, it is a special case
	local VehicleController = {}
	VehicleController.__index = VehicleController
	
	function VehicleController.new(CONTROL_ACTION_PRIORITY)
		local self = setmetatable({}, VehicleController)
	
		self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	
		self.enabled = false
		self.vehicleSeat = nil
		self.throttle = 0
		self.steer = 0
	
		self.acceleration = 0
		self.decceleration = 0
		self.turningRight = 0
		self.turningLeft = 0
	
		self.vehicleMoveVector = ZERO_VECTOR3
	
		self.autoPilot = {}
		self.autoPilot.MaxSpeed = 0
		self.autoPilot.MaxSteeringAngle = 0
	
		return self
	end
	
	function VehicleController:BindContextActions()
		if useTriggersForThrottle then
			ContextActionService:BindActionAtPriority("throttleAccel", (function(actionName, inputState, inputObject)
				self:OnThrottleAccel(actionName, inputState, inputObject)
				return Enum.ContextActionResult.Pass
			end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonR2)
			ContextActionService:BindActionAtPriority("throttleDeccel", (function(actionName, inputState, inputObject)
				self:OnThrottleDeccel(actionName, inputState, inputObject)
				return Enum.ContextActionResult.Pass
			end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonL2)
		end
		ContextActionService:BindActionAtPriority("arrowSteerRight", (function(actionName, inputState, inputObject)
			self:OnSteerRight(actionName, inputState, inputObject)
			return Enum.ContextActionResult.Pass
		end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Right)
		ContextActionService:BindActionAtPriority("arrowSteerLeft", (function(actionName, inputState, inputObject)
			self:OnSteerLeft(actionName, inputState, inputObject)
			return Enum.ContextActionResult.Pass
		end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Left)
	end
	
	function VehicleController:Enable(enable, vehicleSeat)
		if enable == self.enabled and vehicleSeat == self.vehicleSeat then
			return
		end
	
		self.enabled = enable
		self.vehicleMoveVector = ZERO_VECTOR3
	
		if enable then
			if vehicleSeat then
				self.vehicleSeat = vehicleSeat
	
				self:SetupAutoPilot()
				self:BindContextActions()
			end
		else
			if useTriggersForThrottle then
				ContextActionService:UnbindAction("throttleAccel")
				ContextActionService:UnbindAction("throttleDeccel")
			end
			ContextActionService:UnbindAction("arrowSteerRight")
			ContextActionService:UnbindAction("arrowSteerLeft")
			self.vehicleSeat = nil
		end
	end
	
	function VehicleController:OnThrottleAccel(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
			self.acceleration = 0
		else
			self.acceleration = -1
		end
		self.throttle = self.acceleration + self.decceleration
	end
	
	function VehicleController:OnThrottleDeccel(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
			self.decceleration = 0
		else
			self.decceleration = 1
		end
		self.throttle = self.acceleration + self.decceleration
	end
	
	function VehicleController:OnSteerRight(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
			self.turningRight = 0
		else
			self.turningRight = 1
		end
		self.steer = self.turningRight + self.turningLeft
	end
	
	function VehicleController:OnSteerLeft(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
			self.turningLeft = 0
		else
			self.turningLeft = -1
		end
		self.steer = self.turningRight + self.turningLeft
	end
	
	-- Call this from a function bound to Renderstep with Input Priority
	function VehicleController:Update(moveVector, cameraRelative, usingGamepad)
		if self.vehicleSeat then
			if cameraRelative then
				-- This is the default steering mode
				moveVector = moveVector + Vector3.new(self.steer, 0, self.throttle)
				if usingGamepad and onlyTriggersForThrottle and useTriggersForThrottle then
					self.vehicleSeat.ThrottleFloat = -self.throttle
				else
					self.vehicleSeat.ThrottleFloat = -moveVector.Z
				end
				self.vehicleSeat.SteerFloat = moveVector.X
	
				return moveVector, true
			else
				-- This is the path following mode
				local localMoveVector = self.vehicleSeat.Occupant.RootPart.CFrame:VectorToObjectSpace(moveVector)
	
				self.vehicleSeat.ThrottleFloat = self:ComputeThrottle(localMoveVector)
				self.vehicleSeat.SteerFloat = self:ComputeSteer(localMoveVector)
	
				return ZERO_VECTOR3, true
			end
		end
		return moveVector, false
	end
	
	function VehicleController:ComputeThrottle(localMoveVector)
		if localMoveVector ~= ZERO_VECTOR3 then
			local throttle = -localMoveVector.Z
			return throttle
		else
			return 0.0
		end
	end
	
	function VehicleController:ComputeSteer(localMoveVector)
		if localMoveVector ~= ZERO_VECTOR3 then
			local steerAngle = -math.atan2(-localMoveVector.x, -localMoveVector.z) * (180 / math.pi)
			return steerAngle / self.autoPilot.MaxSteeringAngle
		else
			return 0.0
		end
	end
	
	function VehicleController:SetupAutoPilot()
		-- Setup default
		self.autoPilot.MaxSpeed = self.vehicleSeat.MaxSpeed
		self.autoPilot.MaxSteeringAngle = AUTO_PILOT_DEFAULT_MAX_STEERING_ANGLE
	
		-- VehicleSeat should have a MaxSteeringAngle as well.
		-- Or we could look for a child "AutoPilotConfigModule" to find these values
		-- Or allow developer to set them through the API as like the CLickToMove customization API
	end
	
	return VehicleController
end

function _TouchJump()
	
	local Players = game:GetService("Players")
	local GuiService = game:GetService("GuiService")
	
	--[[ Constants ]]--
	local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"
	
	--[[ The Module ]]--
	local BaseCharacterController = _BaseCharacterController()
	local TouchJump = setmetatable({}, BaseCharacterController)
	TouchJump.__index = TouchJump
	
	function TouchJump.new()
		local self = setmetatable(BaseCharacterController.new(), TouchJump)
	
		self.parentUIFrame = nil
		self.jumpButton = nil
		self.characterAddedConn = nil
		self.humanoidStateEnabledChangedConn = nil
		self.humanoidJumpPowerConn = nil
		self.humanoidParentConn = nil
		self.externallyEnabled = false
		self.jumpPower = 0
		self.jumpStateEnabled = true
		self.isJumping = false
		self.humanoid = nil -- saved reference because property change connections are made using it
	
		return self
	end
	
	function TouchJump:EnableButton(enable)
		if enable then
			if not self.jumpButton then
				self:Create()
			end
			local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
			if humanoid and self.externallyEnabled then
				if self.externallyEnabled then
					if humanoid.JumpPower > 0 then
						self.jumpButton.Visible = true
					end
				end
			end
		else
			self.jumpButton.Visible = false
			self.isJumping = false
			self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
		end
	end
	
	function TouchJump:UpdateEnabled()
		if self.jumpPower > 0 and self.jumpStateEnabled then
			self:EnableButton(true)
		else
			self:EnableButton(false)
		end
	end
	
	function TouchJump:HumanoidChanged(prop)
		local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			if prop == "JumpPower" then
				self.jumpPower =  humanoid.JumpPower
				self:UpdateEnabled()
			elseif prop == "Parent" then
				if not humanoid.Parent then
					self.humanoidChangeConn:Disconnect()
				end
			end
		end
	end
	
	function TouchJump:HumanoidStateEnabledChanged(state, isEnabled)
		if state == Enum.HumanoidStateType.Jumping then
			self.jumpStateEnabled = isEnabled
			self:UpdateEnabled()
		end
	end
	
	function TouchJump:CharacterAdded(char)
		if self.humanoidChangeConn then
			self.humanoidChangeConn:Disconnect()
			self.humanoidChangeConn = nil
		end
	
		self.humanoid = char:FindFirstChildOfClass("Humanoid")
		while not self.humanoid do
			char.ChildAdded:wait()
			self.humanoid = char:FindFirstChildOfClass("Humanoid")
		end
	
		self.humanoidJumpPowerConn = self.humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
			self.jumpPower =  self.humanoid.JumpPower
			self:UpdateEnabled()
		end)
	
		self.humanoidParentConn = self.humanoid:GetPropertyChangedSignal("Parent"):Connect(function()
			if not self.humanoid.Parent then
				self.humanoidJumpPowerConn:Disconnect()
				self.humanoidJumpPowerConn = nil
				self.humanoidParentConn:Disconnect()
				self.humanoidParentConn = nil
			end
		end)
	
		self.humanoidStateEnabledChangedConn = self.humanoid.StateEnabledChanged:Connect(function(state, enabled)
			self:HumanoidStateEnabledChanged(state, enabled)
		end)
	
		self.jumpPower = self.humanoid.JumpPower
		self.jumpStateEnabled = self.humanoid:GetStateEnabled(Enum.HumanoidStateType.Jumping)
		self:UpdateEnabled()
	end
	
	function TouchJump:SetupCharacterAddedFunction()
		self.characterAddedConn = Players.LocalPlayer.CharacterAdded:Connect(function(char)
			self:CharacterAdded(char)
		end)
		if Players.LocalPlayer.Character then
			self:CharacterAdded(Players.LocalPlayer.Character)
		end
	end
	
	function TouchJump:Enable(enable, parentFrame)
		if parentFrame then
			self.parentUIFrame = parentFrame
		end
		self.externallyEnabled = enable
		self:EnableButton(enable)
	end
	
	function TouchJump:Create()
		if not self.parentUIFrame then
			return
		end
	
		if self.jumpButton then
			self.jumpButton:Destroy()
			self.jumpButton = nil
		end
	
		local minAxis = math.min(self.parentUIFrame.AbsoluteSize.x, self.parentUIFrame.AbsoluteSize.y)
		local isSmallScreen = minAxis <= 500
		local jumpButtonSize = isSmallScreen and 70 or 120
	
		self.jumpButton = Instance.new("ImageButton")
		self.jumpButton.Name = "JumpButton"
		self.jumpButton.Visible = false
		self.jumpButton.BackgroundTransparency = 1
		self.jumpButton.Image = TOUCH_CONTROL_SHEET
		self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
		self.jumpButton.ImageRectSize = Vector2.new(144, 144)
		self.jumpButton.Size = UDim2.new(0, jumpButtonSize, 0, jumpButtonSize)
	
	    self.jumpButton.Position = isSmallScreen and UDim2.new(1, -(jumpButtonSize*1.5-10), 1, -jumpButtonSize - 20) or
	        UDim2.new(1, -(jumpButtonSize*1.5-10), 1, -jumpButtonSize * 1.75)
	
		local touchObject = nil
		self.jumpButton.InputBegan:connect(function(inputObject)
			--A touch that starts elsewhere on the screen will be sent to a frame's InputBegan event
			--if it moves over the frame. So we check that this is actually a new touch (inputObject.UserInputState ~= Enum.UserInputState.Begin)
			if touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch
				or inputObject.UserInputState ~= Enum.UserInputState.Begin then
				return
			end
	
			touchObject = inputObject
			self.jumpButton.ImageRectOffset = Vector2.new(146, 146)
			self.isJumping = true
		end)
	
		local OnInputEnded = function()
			touchObject = nil
			self.isJumping = false
			self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
		end
	
		self.jumpButton.InputEnded:connect(function(inputObject)
			if inputObject == touchObject then
				OnInputEnded()
			end
		end)
	
		GuiService.MenuOpened:connect(function()
			if touchObject then
				OnInputEnded()
			end
		end)
	
		if not self.characterAddedConn then
			self:SetupCharacterAddedFunction()
		end
	
		self.jumpButton.Parent = self.parentUIFrame
	end
	
	return TouchJump
end

function _ClickToMoveController()
	--[[ Roblox Services ]]--
	local UserInputService = game:GetService("UserInputService")
	local PathfindingService = game:GetService("PathfindingService")
	local Players = game:GetService("Players")
	local DebrisService = game:GetService('Debris')
	local StarterGui = game:GetService("StarterGui")
	local Workspace = game:GetService("Workspace")
	local CollectionService = game:GetService("CollectionService")
	local GuiService = game:GetService("GuiService")
	
	--[[ Configuration ]]
	local ShowPath = true
	local PlayFailureAnimation = true
	local UseDirectPath = false
	local UseDirectPathForVehicle = true
	local AgentSizeIncreaseFactor = 1.0
	local UnreachableWaypointTimeout = 8
	
	--[[ Constants ]]--
	local movementKeys = {
		[Enum.KeyCode.W] = true;
		[Enum.KeyCode.A] = true;
		[Enum.KeyCode.S] = true;
		[Enum.KeyCode.D] = true;
		[Enum.KeyCode.Up] = true;
		[Enum.KeyCode.Down] = true;
	}
	
	local FFlagUserNavigationClickToMoveSkipPassedWaypointsSuccess, FFlagUserNavigationClickToMoveSkipPassedWaypointsResult = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNavigationClickToMoveSkipPassedWaypoints") end)
	local FFlagUserNavigationClickToMoveSkipPassedWaypoints = FFlagUserNavigationClickToMoveSkipPassedWaypointsSuccess and FFlagUserNavigationClickToMoveSkipPassedWaypointsResult
	
	local Player = Players.LocalPlayer
	
	local ClickToMoveDisplay = _ClickToMoveDisplay()
	
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	local ALMOST_ZERO = 0.000001
	
	
	--------------------------UTIL LIBRARY-------------------------------
	local Utility = {}
	do
		local function FindCharacterAncestor(part)
			if part then
				local humanoid = part:FindFirstChildOfClass("Humanoid")
				if humanoid then
					return part, humanoid
				else
					return FindCharacterAncestor(part.Parent)
				end
			end
		end
		Utility.FindCharacterAncestor = FindCharacterAncestor
	
		local function Raycast(ray, ignoreNonCollidable, ignoreList)
			ignoreList = ignoreList or {}
			local hitPart, hitPos, hitNorm, hitMat = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
			if hitPart then
				if ignoreNonCollidable and hitPart.CanCollide == false then
					-- We always include character parts so a user can click on another character
					-- to walk to them.
					local _, humanoid = FindCharacterAncestor(hitPart)
					if humanoid == nil then
						table.insert(ignoreList, hitPart)
						return Raycast(ray, ignoreNonCollidable, ignoreList)
					end
				end
				return hitPart, hitPos, hitNorm, hitMat
			end
			return nil, nil
		end
		Utility.Raycast = Raycast
	end
	
	local humanoidCache = {}
	local function findPlayerHumanoid(player)
		local character = player and player.Character
		if character then
			local resultHumanoid = humanoidCache[player]
			if resultHumanoid and resultHumanoid.Parent == character then
				return resultHumanoid
			else
				humanoidCache[player] = nil -- Bust Old Cache
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoidCache[player] = humanoid
				end
				return humanoid
			end
		end
	end
	
	--------------------------CHARACTER CONTROL-------------------------------
	local CurrentIgnoreList
	local CurrentIgnoreTag = nil
	
	local TaggedInstanceAddedConnection = nil
	local TaggedInstanceRemovedConnection = nil
	
	local function GetCharacter()
		return Player and Player.Character
	end
	
	local function UpdateIgnoreTag(newIgnoreTag)
		if newIgnoreTag == CurrentIgnoreTag then
			return
		end
		if TaggedInstanceAddedConnection then
			TaggedInstanceAddedConnection:Disconnect()
			TaggedInstanceAddedConnection = nil
		end
		if TaggedInstanceRemovedConnection then
			TaggedInstanceRemovedConnection:Disconnect()
			TaggedInstanceRemovedConnection = nil
		end
		CurrentIgnoreTag = newIgnoreTag
		CurrentIgnoreList = {GetCharacter()}
		if CurrentIgnoreTag ~= nil then
			local ignoreParts = CollectionService:GetTagged(CurrentIgnoreTag)
			for _, ignorePart in ipairs(ignoreParts) do
				table.insert(CurrentIgnoreList, ignorePart)
			end
			TaggedInstanceAddedConnection = CollectionService:GetInstanceAddedSignal(
				CurrentIgnoreTag):Connect(function(ignorePart)
				table.insert(CurrentIgnoreList, ignorePart)
			end)
			TaggedInstanceRemovedConnection = CollectionService:GetInstanceRemovedSignal(
				CurrentIgnoreTag):Connect(function(ignorePart)
				for i = 1, #CurrentIgnoreList do
					if CurrentIgnoreList[i] == ignorePart then
						CurrentIgnoreList[i] = CurrentIgnoreList[#CurrentIgnoreList]
						table.remove(CurrentIgnoreList)
						break
					end
				end
			end)
		end
	end
	
	local function getIgnoreList()
		if CurrentIgnoreList then
			return CurrentIgnoreList
		end
		CurrentIgnoreList = {}
		table.insert(CurrentIgnoreList, GetCharacter())
		return CurrentIgnoreList
	end
	
	-----------------------------------PATHER--------------------------------------
	
	local function Pather(endPoint, surfaceNormal, overrideUseDirectPath)
		local this = {}
	
		local directPathForHumanoid
		local directPathForVehicle
		if overrideUseDirectPath ~= nil then
			directPathForHumanoid = overrideUseDirectPath
			directPathForVehicle = overrideUseDirectPath
		else
			directPathForHumanoid = UseDirectPath
			directPathForVehicle = UseDirectPathForVehicle
		end
	
		this.Cancelled = false
		this.Started = false
	
		this.Finished = Instance.new("BindableEvent")
		this.PathFailed = Instance.new("BindableEvent")
	
		this.PathComputing = false
		this.PathComputed = false
	
		this.OriginalTargetPoint = endPoint
		this.TargetPoint = endPoint
		this.TargetSurfaceNormal = surfaceNormal
	
		this.DiedConn = nil
		this.SeatedConn = nil
		this.BlockedConn = nil
		this.TeleportedConn = nil
	
		this.CurrentPoint = 0
	
		this.HumanoidOffsetFromPath = ZERO_VECTOR3
	
		this.CurrentWaypointPosition = nil
		this.CurrentWaypointPlaneNormal = ZERO_VECTOR3
		this.CurrentWaypointPlaneDistance = 0
		this.CurrentWaypointNeedsJump = false;
	
		this.CurrentHumanoidPosition = ZERO_VECTOR3
		this.CurrentHumanoidVelocity = 0
	
		this.NextActionMoveDirection = ZERO_VECTOR3
		this.NextActionJump = false
	
		this.Timeout = 0
	
		this.Humanoid = findPlayerHumanoid(Player)
		this.OriginPoint = nil
		this.AgentCanFollowPath = false
		this.DirectPath = false
		this.DirectPathRiseFirst = false
	
		local rootPart = this.Humanoid and this.Humanoid.RootPart
		if rootPart then
			-- Setup origin
			this.OriginPoint = rootPart.CFrame.p
	
			-- Setup agent
			local agentRadius = 2
			local agentHeight = 5
			local agentCanJump = true
	
			local seat = this.Humanoid.SeatPart
			if seat and seat:IsA("VehicleSeat") then
				-- Humanoid is seated on a vehicle
				local vehicle = seat:FindFirstAncestorOfClass("Model")
				if vehicle then
					-- Make sure the PrimaryPart is set to the vehicle seat while we compute the extends.
					local tempPrimaryPart = vehicle.PrimaryPart
					vehicle.PrimaryPart = seat
	
					-- For now, only direct path
					if directPathForVehicle then
						local extents = vehicle:GetExtentsSize()
						agentRadius = AgentSizeIncreaseFactor * 0.5 * math.sqrt(extents.X * extents.X + extents.Z * extents.Z)
						agentHeight = AgentSizeIncreaseFactor * extents.Y
						agentCanJump = false
						this.AgentCanFollowPath = true
						this.DirectPath = directPathForVehicle
					end
	
					-- Reset PrimaryPart
					vehicle.PrimaryPart = tempPrimaryPart
				end
			else
				local extents = GetCharacter():GetExtentsSize()
				agentRadius = AgentSizeIncreaseFactor * 0.5 * math.sqrt(extents.X * extents.X + extents.Z * extents.Z)
				agentHeight = AgentSizeIncreaseFactor * extents.Y
				agentCanJump = (this.Humanoid.JumpPower > 0)
				this.AgentCanFollowPath = true
				this.DirectPath = directPathForHumanoid
				this.DirectPathRiseFirst = this.Humanoid.Sit
			end
	
			-- Build path object
			this.pathResult = PathfindingService:CreatePath({AgentRadius = agentRadius, AgentHeight = agentHeight, AgentCanJump = agentCanJump})
		end
	
		function this:Cleanup()
			if this.stopTraverseFunc then
				this.stopTraverseFunc()
				this.stopTraverseFunc = nil
			end
	
			if this.MoveToConn then
				this.MoveToConn:Disconnect()
				this.MoveToConn = nil
			end
	
			if this.BlockedConn then
				this.BlockedConn:Disconnect()
				this.BlockedConn = nil
			end
	
			if this.DiedConn then
				this.DiedConn:Disconnect()
				this.DiedConn = nil
			end
	
			if this.SeatedConn then
				this.SeatedConn:Disconnect()
				this.SeatedConn = nil
			end
	
			if this.TeleportedConn then
				this.TeleportedConn:Disconnect()
				this.TeleportedConn = nil
			end
	
			this.Started = false
		end
	
		function this:Cancel()
			this.Cancelled = true
			this:Cleanup()
		end
	
		function this:IsActive()
			return this.AgentCanFollowPath and this.Started and not this.Cancelled
		end
	
		function this:OnPathInterrupted()
			-- Stop moving
			this.Cancelled = true
			this:OnPointReached(false)
		end
	
		function this:ComputePath()
			if this.OriginPoint then
				if this.PathComputed or this.PathComputing then return end
				this.PathComputing = true
				if this.AgentCanFollowPath then
					if this.DirectPath then
						this.pointList = {
							PathWaypoint.new(this.OriginPoint, Enum.PathWaypointAction.Walk),
							PathWaypoint.new(this.TargetPoint, this.DirectPathRiseFirst and Enum.PathWaypointAction.Jump or Enum.PathWaypointAction.Walk)
						}
						this.PathComputed = true
					else
						this.pathResult:ComputeAsync(this.OriginPoint, this.TargetPoint)
						this.pointList = this.pathResult:GetWaypoints()
						this.BlockedConn = this.pathResult.Blocked:Connect(function(blockedIdx) this:OnPathBlocked(blockedIdx) end)
						this.PathComputed = this.pathResult.Status == Enum.PathStatus.Success
					end
				end
				this.PathComputing = false
			end
		end
	
		function this:IsValidPath()
			this:ComputePath()
			return this.PathComputed and this.AgentCanFollowPath
		end
	
		this.Recomputing = false
		function this:OnPathBlocked(blockedWaypointIdx)
			local pathBlocked = blockedWaypointIdx >= this.CurrentPoint
			if not pathBlocked or this.Recomputing then
				return
			end
	
			this.Recomputing = true
	
			if this.stopTraverseFunc then
				this.stopTraverseFunc()
				this.stopTraverseFunc = nil
			end
	
			this.OriginPoint = this.Humanoid.RootPart.CFrame.p
	
			this.pathResult:ComputeAsync(this.OriginPoint, this.TargetPoint)
			this.pointList = this.pathResult:GetWaypoints()
			if #this.pointList > 0 then
				this.HumanoidOffsetFromPath = this.pointList[1].Position - this.OriginPoint
			end
			this.PathComputed = this.pathResult.Status == Enum.PathStatus.Success
	
			if ShowPath then
				this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList)
			end
			if this.PathComputed then
				this.CurrentPoint = 1 -- The first waypoint is always the start location. Skip it.
				this:OnPointReached(true) -- Move to first point
			else
				this.PathFailed:Fire()
				this:Cleanup()
			end
	
			this.Recomputing = false
		end
	
		function this:OnRenderStepped(dt)
			if this.Started and not this.Cancelled then
				-- Check for Timeout (if a waypoint is not reached within the delay, we fail)
				this.Timeout = this.Timeout + dt
				if this.Timeout > UnreachableWaypointTimeout then
					this:OnPointReached(false)
					return
				end
	
				-- Get Humanoid position and velocity
				this.CurrentHumanoidPosition = this.Humanoid.RootPart.Position + this.HumanoidOffsetFromPath
				this.CurrentHumanoidVelocity = this.Humanoid.RootPart.Velocity
	
				-- Check if it has reached some waypoints
				while this.Started and this:IsCurrentWaypointReached() do
					this:OnPointReached(true)
				end
	
				-- If still started, update actions
				if this.Started then
					-- Move action
					this.NextActionMoveDirection = this.CurrentWaypointPosition - this.CurrentHumanoidPosition
					if this.NextActionMoveDirection.Magnitude > ALMOST_ZERO then
						this.NextActionMoveDirection = this.NextActionMoveDirection.Unit
					else
						this.NextActionMoveDirection = ZERO_VECTOR3
					end
					-- Jump action
					if this.CurrentWaypointNeedsJump then
						this.NextActionJump = true
						this.CurrentWaypointNeedsJump = false	-- Request jump only once
					else
						this.NextActionJump = false
					end
				end
			end
		end
	
		function this:IsCurrentWaypointReached()
			local reached = false
	
			-- Check we do have a plane, if not, we consider the waypoint reached
			if this.CurrentWaypointPlaneNormal ~= ZERO_VECTOR3 then
				-- Compute distance of Humanoid from destination plane
				local dist = this.CurrentWaypointPlaneNormal:Dot(this.CurrentHumanoidPosition) - this.CurrentWaypointPlaneDistance
				-- Compute the component of the Humanoid velocity that is towards the plane
				local velocity = -this.CurrentWaypointPlaneNormal:Dot(this.CurrentHumanoidVelocity)
				-- Compute the threshold from the destination plane based on Humanoid velocity
				local threshold = math.max(1.0, 0.0625 * velocity)
				-- If we are less then threshold in front of the plane (between 0 and threshold) or if we are behing the plane (less then 0), we consider we reached it
				reached = dist < threshold
			else
				reached = true
			end
	
			if reached then
				this.CurrentWaypointPosition = nil
				this.CurrentWaypointPlaneNormal	= ZERO_VECTOR3
				this.CurrentWaypointPlaneDistance = 0
			end
	
			return reached
		end
	
		function this:OnPointReached(reached)
	
			if reached and not this.Cancelled then
				-- First, destroyed the current displayed waypoint
				if this.setPointFunc then
					this.setPointFunc(this.CurrentPoint)
				end
	
				local nextWaypointIdx = this.CurrentPoint + 1
	
				if nextWaypointIdx > #this.pointList then
					-- End of path reached
					if this.stopTraverseFunc then
						this.stopTraverseFunc()
					end
					this.Finished:Fire()
					this:Cleanup()
				else
					local currentWaypoint = this.pointList[this.CurrentPoint]
					local nextWaypoint = this.pointList[nextWaypointIdx]
	
					-- If airborne, only allow to keep moving
					-- if nextWaypoint.Action ~= Jump, or path mantains a direction
					-- Otherwise, wait until the humanoid gets to the ground
					local currentState = this.Humanoid:GetState()
					local isInAir = currentState == Enum.HumanoidStateType.FallingDown
						or currentState == Enum.HumanoidStateType.Freefall
						or currentState == Enum.HumanoidStateType.Jumping
	
					if isInAir then
						local shouldWaitForGround = nextWaypoint.Action == Enum.PathWaypointAction.Jump
						if not shouldWaitForGround and this.CurrentPoint > 1 then
							local prevWaypoint = this.pointList[this.CurrentPoint - 1]
	
							local prevDir = currentWaypoint.Position - prevWaypoint.Position
							local currDir = nextWaypoint.Position - currentWaypoint.Position
	
							local prevDirXZ = Vector2.new(prevDir.x, prevDir.z).Unit
							local currDirXZ = Vector2.new(currDir.x, currDir.z).Unit
	
							local THRESHOLD_COS = 0.996 -- ~cos(5 degrees)
							shouldWaitForGround = prevDirXZ:Dot(currDirXZ) < THRESHOLD_COS
						end
	
						if shouldWaitForGround then
							this.Humanoid.FreeFalling:Wait()
	
							-- Give time to the humanoid's state to change
							-- Otherwise, the jump flag in Humanoid
							-- will be reset by the state change
							wait(0.1)
						end
					end
	
					-- Move to the next point
					if FFlagUserNavigationClickToMoveSkipPassedWaypoints then
						this:MoveToNextWayPoint(currentWaypoint, nextWaypoint, nextWaypointIdx)
					else
						if this.setPointFunc then
							this.setPointFunc(nextWaypointIdx)
						end
						if nextWaypoint.Action == Enum.PathWaypointAction.Jump then
							this.Humanoid.Jump = true
						end
						this.Humanoid:MoveTo(nextWaypoint.Position)
	
						this.CurrentPoint = nextWaypointIdx
					end
				end
			else
				this.PathFailed:Fire()
				this:Cleanup()
			end
		end
	
		function this:MoveToNextWayPoint(currentWaypoint, nextWaypoint, nextWaypointIdx)
			-- Build next destination plane
			-- (plane normal is perpendicular to the y plane and is from next waypoint towards current one (provided the two waypoints are not at the same location))
			-- (plane location is at next waypoint)
			this.CurrentWaypointPlaneNormal = currentWaypoint.Position - nextWaypoint.Position
			this.CurrentWaypointPlaneNormal = Vector3.new(this.CurrentWaypointPlaneNormal.X, 0, this.CurrentWaypointPlaneNormal.Z)
			if this.CurrentWaypointPlaneNormal.Magnitude > ALMOST_ZERO then
				this.CurrentWaypointPlaneNormal	= this.CurrentWaypointPlaneNormal.Unit
				this.CurrentWaypointPlaneDistance = this.CurrentWaypointPlaneNormal:Dot(nextWaypoint.Position)
			else
				-- Next waypoint is the same as current waypoint so no plane
				this.CurrentWaypointPlaneNormal	= ZERO_VECTOR3
				this.CurrentWaypointPlaneDistance = 0
			end
	
			-- Should we jump
			this.CurrentWaypointNeedsJump = nextWaypoint.Action == Enum.PathWaypointAction.Jump;
	
			-- Remember next waypoint position
			this.CurrentWaypointPosition = nextWaypoint.Position
	
			-- Move to next point
			this.CurrentPoint = nextWaypointIdx
	
			-- Finally reset Timeout
			this.Timeout = 0
		end
	
		function this:Start(overrideShowPath)
			if not this.AgentCanFollowPath then
				this.PathFailed:Fire()
				return
			end
	
			if this.Started then return end
			this.Started = true
	
			ClickToMoveDisplay.CancelFailureAnimation()
	
			if ShowPath then
				if overrideShowPath == nil or overrideShowPath then
					this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList, this.OriginalTargetPoint)
				end
			end
	
			if #this.pointList > 0 then
				-- Determine the humanoid offset from the path's first point
				-- Offset of the first waypoint from the path's origin point
				this.HumanoidOffsetFromPath = Vector3.new(0, this.pointList[1].Position.Y - this.OriginPoint.Y, 0)
	
				-- As well as its current position and velocity
				this.CurrentHumanoidPosition = this.Humanoid.RootPart.Position + this.HumanoidOffsetFromPath
				this.CurrentHumanoidVelocity = this.Humanoid.RootPart.Velocity
	
				-- Connect to events
				this.SeatedConn = this.Humanoid.Seated:Connect(function(isSeated, seat) this:OnPathInterrupted() end)
				this.DiedConn = this.Humanoid.Died:Connect(function() this:OnPathInterrupted() end)
				this.TeleportedConn = this.Humanoid.RootPart:GetPropertyChangedSignal("CFrame"):Connect(function() this:OnPathInterrupted() end)
	
				-- Actually start
				this.CurrentPoint = 1 -- The first waypoint is always the start location. Skip it.
				this:OnPointReached(true) -- Move to first point
			else
				this.PathFailed:Fire()
				if this.stopTraverseFunc then
					this.stopTraverseFunc()
				end
			end
		end
	
		--We always raycast to the ground in the case that the user clicked a wall.
		local offsetPoint = this.TargetPoint + this.TargetSurfaceNormal*1.5
		local ray = Ray.new(offsetPoint, Vector3.new(0,-1,0)*50)
		local newHitPart, newHitPos = Workspace:FindPartOnRayWithIgnoreList(ray, getIgnoreList())
		if newHitPart then
			this.TargetPoint = newHitPos
		end
		this:ComputePath()
	
		return this
	end
	
	-------------------------------------------------------------------------
	
	local function CheckAlive()
		local humanoid = findPlayerHumanoid(Player)
		return humanoid ~= nil and humanoid.Health > 0
	end
	
	local function GetEquippedTool(character)
		if character ~= nil then
			for _, child in pairs(character:GetChildren()) do
				if child:IsA('Tool') then
					return child
				end
			end
		end
	end
	
	local ExistingPather = nil
	local ExistingIndicator = nil
	local PathCompleteListener = nil
	local PathFailedListener = nil
	
	local function CleanupPath()
		if ExistingPather then
			ExistingPather:Cancel()
			ExistingPather = nil
		end
		if PathCompleteListener then
			PathCompleteListener:Disconnect()
			PathCompleteListener = nil
		end
		if PathFailedListener then
			PathFailedListener:Disconnect()
			PathFailedListener = nil
		end
		if ExistingIndicator then
			ExistingIndicator:Destroy()
		end
	end
	
	local function HandleMoveTo(thisPather, hitPt, hitChar, character, overrideShowPath)
		if ExistingPather then
			CleanupPath()
		end
		ExistingPather = thisPather
		thisPather:Start(overrideShowPath)
	
		PathCompleteListener = thisPather.Finished.Event:Connect(function()
			CleanupPath()
			if hitChar then
				local currentWeapon = GetEquippedTool(character)
				if currentWeapon then
					currentWeapon:Activate()
				end
			end
		end)
		PathFailedListener = thisPather.PathFailed.Event:Connect(function()
			CleanupPath()
			if overrideShowPath == nil or overrideShowPath then
				local shouldPlayFailureAnim = PlayFailureAnimation and not (ExistingPather and ExistingPather:IsActive())
				if shouldPlayFailureAnim then
					ClickToMoveDisplay.PlayFailureAnimation()
				end
				ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
			end
		end)
	end
	
	local function ShowPathFailedFeedback(hitPt)
		if ExistingPather and ExistingPather:IsActive() then
			ExistingPather:Cancel()
		end
		if PlayFailureAnimation then
			ClickToMoveDisplay.PlayFailureAnimation()
		end
		ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
	end
	
	function OnTap(tapPositions, goToPoint, wasTouchTap)
		-- Good to remember if this is the latest tap event
		local camera = Workspace.CurrentCamera
		local character = Player.Character
	
		if not CheckAlive() then return end
	
		-- This is a path tap position
		if #tapPositions == 1 or goToPoint then
			if camera then
				local unitRay = camera:ScreenPointToRay(tapPositions[1].x, tapPositions[1].y)
				local ray = Ray.new(unitRay.Origin, unitRay.Direction*1000)
	
				local myHumanoid = findPlayerHumanoid(Player)
				local hitPart, hitPt, hitNormal = Utility.Raycast(ray, true, getIgnoreList())
	
				local hitChar, hitHumanoid = Utility.FindCharacterAncestor(hitPart)
				if wasTouchTap and hitHumanoid and StarterGui:GetCore("AvatarContextMenuEnabled") then
					local clickedPlayer = Players:GetPlayerFromCharacter(hitHumanoid.Parent)
					if clickedPlayer then
						CleanupPath()
						return
					end
				end
				if goToPoint then
					hitPt = goToPoint
					hitChar = nil
				end
				if hitPt and character then
					-- Clean up current path
					CleanupPath()
					local thisPather = Pather(hitPt, hitNormal)
					if thisPather:IsValidPath() then
						HandleMoveTo(thisPather, hitPt, hitChar, character)
					else
						-- Clean up
						thisPather:Cleanup()
						-- Feedback here for when we don't have a good path
						ShowPathFailedFeedback(hitPt)
					end
				end
			end
		elseif #tapPositions >= 2 then
			if camera then
				-- Do shoot
				local currentWeapon = GetEquippedTool(character)
				if currentWeapon then
					currentWeapon:Activate()
				end
			end
		end
	end
	
	local function DisconnectEvent(event)
		if event then
			event:Disconnect()
		end
	end
	
	--[[ The ClickToMove Controller Class ]]--
	local KeyboardController = _Keyboard()
	local ClickToMove = setmetatable({}, KeyboardController)
	ClickToMove.__index = ClickToMove
	
	function ClickToMove.new(CONTROL_ACTION_PRIORITY)
		local self = setmetatable(KeyboardController.new(CONTROL_ACTION_PRIORITY), ClickToMove)
	
		self.fingerTouches = {}
		self.numUnsunkTouches = 0
		-- PC simulation
		self.mouse1Down = tick()
		self.mouse1DownPos = Vector2.new()
		self.mouse2DownTime = tick()
		self.mouse2DownPos = Vector2.new()
		self.mouse2UpTime = tick()
	
		self.keyboardMoveVector = ZERO_VECTOR3
	
		self.tapConn = nil
		self.inputBeganConn = nil
		self.inputChangedConn = nil
		self.inputEndedConn = nil
		self.humanoidDiedConn = nil
		self.characterChildAddedConn = nil
		self.onCharacterAddedConn = nil
		self.characterChildRemovedConn = nil
		self.renderSteppedConn = nil
		self.menuOpenedConnection = nil
	
		self.running = false
	
		self.wasdEnabled = false
	
		return self
	end
	
	function ClickToMove:DisconnectEvents()
		DisconnectEvent(self.tapConn)
		DisconnectEvent(self.inputBeganConn)
		DisconnectEvent(self.inputChangedConn)
		DisconnectEvent(self.inputEndedConn)
		DisconnectEvent(self.humanoidDiedConn)
		DisconnectEvent(self.characterChildAddedConn)
		DisconnectEvent(self.onCharacterAddedConn)
		DisconnectEvent(self.renderSteppedConn)
		DisconnectEvent(self.characterChildRemovedConn)
		DisconnectEvent(self.menuOpenedConnection)
	end
	
	function ClickToMove:OnTouchBegan(input, processed)
		if self.fingerTouches[input] == nil and not processed then
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
		self.fingerTouches[input] = processed
	end
	
	function ClickToMove:OnTouchChanged(input, processed)
		if self.fingerTouches[input] == nil then
			self.fingerTouches[input] = processed
			if not processed then
				self.numUnsunkTouches = self.numUnsunkTouches + 1
			end
		end
	end
	
	function ClickToMove:OnTouchEnded(input, processed)
		if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
			self.numUnsunkTouches = self.numUnsunkTouches - 1
		end
		self.fingerTouches[input] = nil
	end
	
	
	function ClickToMove:OnCharacterAdded(character)
		self:DisconnectEvents()
	
		self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch then
				self:OnTouchBegan(input, processed)
			end
	
			-- Cancel path when you use the keyboard controls if wasd is enabled.
			if self.wasdEnabled and processed == false and input.UserInputType == Enum.UserInputType.Keyboard
				and movementKeys[input.KeyCode] then
				CleanupPath()
				ClickToMoveDisplay.CancelFailureAnimation()
			end
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				self.mouse1DownTime = tick()
				self.mouse1DownPos = input.Position
			end
			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				self.mouse2DownTime = tick()
				self.mouse2DownPos = input.Position
			end
		end)
	
		self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch then
				self:OnTouchChanged(input, processed)
			end
		end)
	
		self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch then
				self:OnTouchEnded(input, processed)
			end
	
			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				self.mouse2UpTime = tick()
				local currPos = input.Position
				-- We allow click to move during path following or if there is no keyboard movement
				local allowed = ExistingPather or self.keyboardMoveVector.Magnitude <= 0
				if self.mouse2UpTime - self.mouse2DownTime < 0.25 and (currPos - self.mouse2DownPos).magnitude < 5 and allowed then
					local positions = {currPos}
					OnTap(positions)
				end
			end
		end)
	
		self.tapConn = UserInputService.TouchTap:Connect(function(touchPositions, processed)
			if not processed then
				OnTap(touchPositions, nil, true)
			end
		end)
	
		self.menuOpenedConnection = GuiService.MenuOpened:Connect(function()
			CleanupPath()
		end)
	
		local function OnCharacterChildAdded(child)
			if UserInputService.TouchEnabled then
				if child:IsA('Tool') then
					child.ManualActivationOnly = true
				end
			end
			if child:IsA('Humanoid') then
				DisconnectEvent(self.humanoidDiedConn)
				self.humanoidDiedConn = child.Died:Connect(function()
					if ExistingIndicator then
						DebrisService:AddItem(ExistingIndicator.Model, 1)
					end
				end)
			end
		end
	
		self.characterChildAddedConn = character.ChildAdded:Connect(function(child)
			OnCharacterChildAdded(child)
		end)
		self.characterChildRemovedConn = character.ChildRemoved:Connect(function(child)
			if UserInputService.TouchEnabled then
				if child:IsA('Tool') then
					child.ManualActivationOnly = false
				end
			end
		end)
		for _, child in pairs(character:GetChildren()) do
			OnCharacterChildAdded(child)
		end
	end
	
	function ClickToMove:Start()
		self:Enable(true)
	end
	
	function ClickToMove:Stop()
		self:Enable(false)
	end
	
	function ClickToMove:CleanupPath()
		CleanupPath()
	end
	
	function ClickToMove:Enable(enable, enableWASD, touchJumpController)
		if enable then
			if not self.running then
				if Player.Character then -- retro-listen
					self:OnCharacterAdded(Player.Character)
				end
				self.onCharacterAddedConn = Player.CharacterAdded:Connect(function(char)
					self:OnCharacterAdded(char)
				end)
				self.running = true
			end
			self.touchJumpController = touchJumpController
			if self.touchJumpController then
				self.touchJumpController:Enable(self.jumpEnabled)
			end
		else
			if self.running then
				self:DisconnectEvents()
				CleanupPath()
				-- Restore tool activation on shutdown
				if UserInputService.TouchEnabled then
					local character = Player.Character
					if character then
						for _, child in pairs(character:GetChildren()) do
							if child:IsA('Tool') then
								child.ManualActivationOnly = false
							end
						end
					end
				end
				self.running = false
			end
			if self.touchJumpController and not self.jumpEnabled then
				self.touchJumpController:Enable(true)
			end
			self.touchJumpController = nil
		end
	
		-- Extension for initializing Keyboard input as this class now derives from Keyboard
		if UserInputService.KeyboardEnabled and enable ~= self.enabled then
	
			self.forwardValue  = 0
			self.backwardValue = 0
			self.leftValue = 0
			self.rightValue = 0
	
			self.moveVector = ZERO_VECTOR3
	
			if enable then
				self:BindContextActions()
				self:ConnectFocusEventListeners()
			else
				self:UnbindContextActions()
				self:DisconnectFocusEventListeners()
			end
		end
	
		self.wasdEnabled = enable and enableWASD or false
		self.enabled = enable
	end
	
	function ClickToMove:OnRenderStepped(dt)
		-- Reset jump
		self.isJumping = false
	
		-- Handle Pather
		if ExistingPather then
			-- Let the Pather update
			ExistingPather:OnRenderStepped(dt)
	
			-- If we still have a Pather, set the resulting actions
			if ExistingPather then
				-- Setup move (NOT relative to camera)
				self.moveVector = ExistingPather.NextActionMoveDirection
				self.moveVectorIsCameraRelative = false
	
				-- Setup jump (but do NOT prevent the base Keayboard class from requesting jumps as well)
				if ExistingPather.NextActionJump then
					self.isJumping = true
				end
			else
				self.moveVector = self.keyboardMoveVector
				self.moveVectorIsCameraRelative = true
			end
		else
			self.moveVector = self.keyboardMoveVector
			self.moveVectorIsCameraRelative = true
		end
	
		-- Handle Keyboard's jump
		if self.jumpRequested then
			self.isJumping = true
		end
	end
	
	-- Overrides Keyboard:UpdateMovement(inputState) to conditionally consider self.wasdEnabled and let OnRenderStepped handle the movement
	function ClickToMove:UpdateMovement(inputState)
		if inputState == Enum.UserInputState.Cancel then
			self.keyboardMoveVector = ZERO_VECTOR3
		elseif self.wasdEnabled then
			self.keyboardMoveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
		end
	end
	
	-- Overrides Keyboard:UpdateJump() because jump is handled in OnRenderStepped
	function ClickToMove:UpdateJump()
		-- Nothing to do (handled in OnRenderStepped)
	end
	
	--Public developer facing functions
	function ClickToMove:SetShowPath(value)
		ShowPath = value
	end
	
	function ClickToMove:GetShowPath()
		return ShowPath
	end
	
	function ClickToMove:SetWaypointTexture(texture)
		ClickToMoveDisplay.SetWaypointTexture(texture)
	end
	
	function ClickToMove:GetWaypointTexture()
		return ClickToMoveDisplay.GetWaypointTexture()
	end
	
	function ClickToMove:SetWaypointRadius(radius)
		ClickToMoveDisplay.SetWaypointRadius(radius)
	end
	
	function ClickToMove:GetWaypointRadius()
		return ClickToMoveDisplay.GetWaypointRadius()
	end
	
	function ClickToMove:SetEndWaypointTexture(texture)
		ClickToMoveDisplay.SetEndWaypointTexture(texture)
	end
	
	function ClickToMove:GetEndWaypointTexture()
		return ClickToMoveDisplay.GetEndWaypointTexture()
	end
	
	function ClickToMove:SetWaypointsAlwaysOnTop(alwaysOnTop)
		ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
	end
	
	function ClickToMove:GetWaypointsAlwaysOnTop()
		return ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
	end
	
	function ClickToMove:SetFailureAnimationEnabled(enabled)
		PlayFailureAnimation = enabled
	end
	
	function ClickToMove:GetFailureAnimationEnabled()
		return PlayFailureAnimation
	end
	
	function ClickToMove:SetIgnoredPartsTag(tag)
		UpdateIgnoreTag(tag)
	end
	
	function ClickToMove:GetIgnoredPartsTag()
		return CurrentIgnoreTag
	end
	
	function ClickToMove:SetUseDirectPath(directPath)
		UseDirectPath = directPath
	end
	
	function ClickToMove:GetUseDirectPath()
		return UseDirectPath
	end
	
	function ClickToMove:SetAgentSizeIncreaseFactor(increaseFactorPercent)
		AgentSizeIncreaseFactor = 1.0 + (increaseFactorPercent / 100.0)
	end
	
	function ClickToMove:GetAgentSizeIncreaseFactor()
		return (AgentSizeIncreaseFactor - 1.0) * 100.0
	end
	
	function ClickToMove:SetUnreachableWaypointTimeout(timeoutInSec)
		UnreachableWaypointTimeout = timeoutInSec
	end
	
	function ClickToMove:GetUnreachableWaypointTimeout()
		return UnreachableWaypointTimeout
	end
	
	function ClickToMove:SetUserJumpEnabled(jumpEnabled)
		self.jumpEnabled = jumpEnabled
		if self.touchJumpController then
			self.touchJumpController:Enable(jumpEnabled)
		end
	end
	
	function ClickToMove:GetUserJumpEnabled()
		return self.jumpEnabled
	end
	
	function ClickToMove:MoveTo(position, showPath, useDirectPath)
		local character = Player.Character
		if character == nil then
			return false
		end
		local thisPather = Pather(position, Vector3.new(0, 1, 0), useDirectPath)
		if thisPather and thisPather:IsValidPath() then
			HandleMoveTo(thisPather, position, nil, character, showPath)
			return true
		end
		return false
	end
	
	return ClickToMove
end

function _TouchThumbstick()
	local Players = game:GetService("Players")
	local GuiService = game:GetService("GuiService")
	local UserInputService = game:GetService("UserInputService")
	--[[ Constants ]]--
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"
	--[[ The Module ]]--
	local BaseCharacterController = _BaseCharacterController()
	local TouchThumbstick = setmetatable({}, BaseCharacterController)
	TouchThumbstick.__index = TouchThumbstick
	function TouchThumbstick.new()
		local self = setmetatable(BaseCharacterController.new(), TouchThumbstick)
		
		self.isFollowStick = false
		
		self.thumbstickFrame = nil
		self.moveTouchObject = nil
		self.onTouchMovedConn = nil
		self.onTouchEndedConn = nil
		self.screenPos = nil
		self.stickImage = nil
		self.thumbstickSize = nil -- Float
		
		return self
	end
	function TouchThumbstick:Enable(enable, uiParentFrame)
		if enable == nil then return false end			-- If nil, return false (invalid argument)
		enable = enable and true or false				-- Force anything non-nil to boolean before comparison
		if self.enabled == enable then return true end	-- If no state change, return true indicating already in requested state
		
		self.moveVector = ZERO_VECTOR3
		self.isJumping = false
		
		if enable then
			-- Enable
			if not self.thumbstickFrame then
				self:Create(uiParentFrame)
			end
			self.thumbstickFrame.Visible = true
		else 
			-- Disable
			self.thumbstickFrame.Visible = false
			self:OnInputEnded()
		end
		self.enabled = enable
	end
	function TouchThumbstick:OnInputEnded()
		self.thumbstickFrame.Position = self.screenPos
		self.stickImage.Position = UDim2.new(0, self.thumbstickFrame.Size.X.Offset/2 - self.thumbstickSize/4, 0, self.thumbstickFrame.Size.Y.Offset/2 - self.thumbstickSize/4)
		
		self.moveVector = ZERO_VECTOR3
		self.isJumping = false
		self.thumbstickFrame.Position = self.screenPos
		self.moveTouchObject = nil
	end
	function TouchThumbstick:Create(parentFrame)
		
		if self.thumbstickFrame then
			self.thumbstickFrame:Destroy()
			self.thumbstickFrame = nil
			if self.onTouchMovedConn then
				self.onTouchMovedConn:Disconnect()
				self.onTouchMovedConn = nil
			end
			if self.onTouchEndedConn then
				self.onTouchEndedConn:Disconnect()
				self.onTouchEndedConn = nil
			end
		end
		
		local minAxis = math.min(parentFrame.AbsoluteSize.x, parentFrame.AbsoluteSize.y)
		local isSmallScreen = minAxis <= 500
		self.thumbstickSize = isSmallScreen and 70 or 120
		self.screenPos = isSmallScreen and UDim2.new(0, (self.thumbstickSize/2) - 10, 1, -self.thumbstickSize - 20) or
			UDim2.new(0, self.thumbstickSize/2, 1, -self.thumbstickSize * 1.75)
			
		self.thumbstickFrame = Instance.new("Frame")
		self.thumbstickFrame.Name = "ThumbstickFrame"
		self.thumbstickFrame.Active = true
		self.thumbstickFrame.Visible = false
		self.thumbstickFrame.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
		self.thumbstickFrame.Position = self.screenPos
		self.thumbstickFrame.BackgroundTransparency = 1
		
		local outerImage = Instance.new("ImageLabel")
		outerImage.Name = "OuterImage"
		outerImage.Image = TOUCH_CONTROL_SHEET
		outerImage.ImageRectOffset = Vector2.new()
		outerImage.ImageRectSize = Vector2.new(220, 220)
		outerImage.BackgroundTransparency = 1
		outerImage.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
		outerImage.Position = UDim2.new(0, 0, 0, 0)
		outerImage.Parent = self.thumbstickFrame
		
		self.stickImage = Instance.new("ImageLabel")
		self.stickImage.Name = "StickImage"
		self.stickImage.Image = TOUCH_CONTROL_SHEET
		self.stickImage.ImageRectOffset = Vector2.new(220, 0)
		self.stickImage.ImageRectSize = Vector2.new(111, 111)
		self.stickImage.BackgroundTransparency = 1
		self.stickImage.Size = UDim2.new(0, self.thumbstickSize/2, 0, self.thumbstickSize/2)
		self.stickImage.Position = UDim2.new(0, self.thumbstickSize/2 - self.thumbstickSize/4, 0, self.thumbstickSize/2 - self.thumbstickSize/4)
		self.stickImage.ZIndex = 2
		self.stickImage.Parent = self.thumbstickFrame
		
		local centerPosition = nil
		local deadZone = 0.05
		
		local function DoMove(direction)
			
			local currentMoveVector = direction / (self.thumbstickSize/2)
			
			-- Scaled Radial Dead Zone
			local inputAxisMagnitude = currentMoveVector.magnitude
			if inputAxisMagnitude < deadZone then
				currentMoveVector = Vector3.new()
			else
				currentMoveVector = currentMoveVector.unit * ((inputAxisMagnitude - deadZone) / (1 - deadZone))
				-- NOTE: Making currentMoveVector a unit vector will cause the player to instantly go max speed
				-- must check for zero length vector is using unit
				currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
			end
			
			self.moveVector = currentMoveVector
		end
		
		local function MoveStick(pos)
			local relativePosition = Vector2.new(pos.x - centerPosition.x, pos.y - centerPosition.y)
			local length = relativePosition.magnitude
			local maxLength = self.thumbstickFrame.AbsoluteSize.x/2
			if self.isFollowStick and length > maxLength then
				local offset = relativePosition.unit * maxLength
				self.thumbstickFrame.Position = UDim2.new(
					0, pos.x - self.thumbstickFrame.AbsoluteSize.x/2 - offset.x,
					0, pos.y - self.thumbstickFrame.AbsoluteSize.y/2 - offset.y)
			else
				length = math.min(length, maxLength)
				relativePosition = relativePosition.unit * length
			end
			self.stickImage.Position = UDim2.new(0, relativePosition.x + self.stickImage.AbsoluteSize.x/2, 0, relativePosition.y + self.stickImage.AbsoluteSize.y/2)
		end
		
		-- input connections
		self.thumbstickFrame.InputBegan:Connect(function(inputObject)
			--A touch that starts elsewhere on the screen will be sent to a frame's InputBegan event
			--if it moves over the frame. So we check that this is actually a new touch (inputObject.UserInputState ~= Enum.UserInputState.Begin)
			if self.moveTouchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch
				or inputObject.UserInputState ~= Enum.UserInputState.Begin then
				return
			end
			
			self.moveTouchObject = inputObject
			self.thumbstickFrame.Position = UDim2.new(0, inputObject.Position.x - self.thumbstickFrame.Size.X.Offset/2, 0, inputObject.Position.y - self.thumbstickFrame.Size.Y.Offset/2)
			centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x/2,
				self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y/2)
			local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
		end)
		
		self.onTouchMovedConn = UserInputService.TouchMoved:Connect(function(inputObject, isProcessed)
			if inputObject == self.moveTouchObject then
				centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x/2,
					self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y/2)
				local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
				DoMove(direction)
				MoveStick(inputObject.Position)
			end
		end)
		
		self.onTouchEndedConn = UserInputService.TouchEnded:Connect(function(inputObject, isProcessed)
			if inputObject == self.moveTouchObject then
				self:OnInputEnded()
			end
		end)
		
		GuiService.MenuOpened:Connect(function()
			if self.moveTouchObject then
				self:OnInputEnded()
			end
		end)	
		
		self.thumbstickFrame.Parent = parentFrame
	end
	return TouchThumbstick
end

function _DynamicThumbstick()
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	local TOUCH_CONTROLS_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"
	
	local DYNAMIC_THUMBSTICK_ACTION_NAME = "DynamicThumbstickAction"
	local DYNAMIC_THUMBSTICK_ACTION_PRIORITY = Enum.ContextActionPriority.High.Value
	
	local MIDDLE_TRANSPARENCIES = {
		1 - 0.89,
		1 - 0.70,
		1 - 0.60,
		1 - 0.50,
		1 - 0.40,
		1 - 0.30,
		1 - 0.25
	}
	local NUM_MIDDLE_IMAGES = #MIDDLE_TRANSPARENCIES
	
	local FADE_IN_OUT_BACKGROUND = true
	local FADE_IN_OUT_MAX_ALPHA = 0.35
	
	local FADE_IN_OUT_HALF_DURATION_DEFAULT = 0.3
	local FADE_IN_OUT_BALANCE_DEFAULT = 0.5
	local ThumbstickFadeTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
	
	local Players = game:GetService("Players")
	local GuiService = game:GetService("GuiService")
	local UserInputService = game:GetService("UserInputService")
	local ContextActionService = game:GetService("ContextActionService")
	local RunService = game:GetService("RunService")
	local TweenService = game:GetService("TweenService")
	
	local LocalPlayer = Players.LocalPlayer
	if not LocalPlayer then
		Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
		LocalPlayer = Players.LocalPlayer
	end
	
	--[[ The Module ]]--
	local BaseCharacterController = _BaseCharacterController()
	local DynamicThumbstick = setmetatable({}, BaseCharacterController)
	DynamicThumbstick.__index = DynamicThumbstick
	
	function DynamicThumbstick.new()
		local self = setmetatable(BaseCharacterController.new(), DynamicThumbstick)
	
		self.moveTouchObject = nil
		self.moveTouchLockedIn = false
		self.moveTouchFirstChanged = false
		self.moveTouchStartPosition = nil
	
		self.startImage = nil
		self.endImage = nil
		self.middleImages = {}
	
		self.startImageFadeTween = nil
		self.endImageFadeTween = nil
		self.middleImageFadeTweens = {}
	
		self.isFirstTouch = true
	
		self.thumbstickFrame = nil
	
		self.onRenderSteppedConn = nil
	
		self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
		self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
		self.hasFadedBackgroundInPortrait = false
		self.hasFadedBackgroundInLandscape = false
	
		self.tweenInAlphaStart = nil
		self.tweenOutAlphaStart = nil
	
		return self
	end
	
	-- Note: Overrides base class GetIsJumping with get-and-clear behavior to do a single jump
	-- rather than sustained jumping. This is only to preserve the current behavior through the refactor.
	function DynamicThumbstick:GetIsJumping()
		local wasJumping = self.isJumping
		self.isJumping = false
		return wasJumping
	end
	
	function DynamicThumbstick:Enable(enable, uiParentFrame)
		if enable == nil then return false end			-- If nil, return false (invalid argument)
		enable = enable and true or false				-- Force anything non-nil to boolean before comparison
		if self.enabled == enable then return true end	-- If no state change, return true indicating already in requested state
	
		if enable then
			-- Enable
			if not self.thumbstickFrame then
				self:Create(uiParentFrame)
			end
	
			self:BindContextActions()
		else
			ContextActionService:UnbindAction(DYNAMIC_THUMBSTICK_ACTION_NAME)
			-- Disable
			self:OnInputEnded() -- Cleanup
		end
	
		self.enabled = enable
		self.thumbstickFrame.Visible = enable
	end
	
	-- Was called OnMoveTouchEnded in previous version
	function DynamicThumbstick:OnInputEnded()
		self.moveTouchObject = nil
		self.moveVector = ZERO_VECTOR3
		self:FadeThumbstick(false)
	end
	
	function DynamicThumbstick:FadeThumbstick(visible)
		if not visible and self.moveTouchObject then
			return
		end
		if self.isFirstTouch then return end
	
		if self.startImageFadeTween then
			self.startImageFadeTween:Cancel()
		end
		if self.endImageFadeTween then
			self.endImageFadeTween:Cancel()
		end
		for i = 1, #self.middleImages do
			if self.middleImageFadeTweens[i] then
				self.middleImageFadeTweens[i]:Cancel()
			end
		end
	
		if visible then
			self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, { ImageTransparency = 0 })
			self.startImageFadeTween:Play()
	
			self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, { ImageTransparency = 0.2 })
			self.endImageFadeTween:Play()
	
			for i = 1, #self.middleImages do
				self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, { ImageTransparency = MIDDLE_TRANSPARENCIES[i] })
				self.middleImageFadeTweens[i]:Play()
			end
		else
			self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
			self.startImageFadeTween:Play()
	
			self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
			self.endImageFadeTween:Play()
	
			for i = 1, #self.middleImages do
				self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
				self.middleImageFadeTweens[i]:Play()
			end
		end
	end
	
	function DynamicThumbstick:FadeThumbstickFrame(fadeDuration, fadeRatio)
		self.fadeInAndOutHalfDuration = fadeDuration * 0.5
		self.fadeInAndOutBalance = fadeRatio
		self.tweenInAlphaStart = tick()
	end
	
	function DynamicThumbstick:InputInFrame(inputObject)
		local frameCornerTopLeft = self.thumbstickFrame.AbsolutePosition
		local frameCornerBottomRight = frameCornerTopLeft + self.thumbstickFrame.AbsoluteSize
		local inputPosition = inputObject.Position
		if inputPosition.X >= frameCornerTopLeft.X and inputPosition.Y >= frameCornerTopLeft.Y then
			if inputPosition.X <= frameCornerBottomRight.X and inputPosition.Y <= frameCornerBottomRight.Y then
				return true
			end
		end
		return false
	end
	
	function DynamicThumbstick:DoFadeInBackground()
		local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
		local hasFadedBackgroundInOrientation = false
	
		-- only fade in/out the background once per orientation
		if playerGui then
			if playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or
				playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight then
					hasFadedBackgroundInOrientation = self.hasFadedBackgroundInLandscape
					self.hasFadedBackgroundInLandscape = true
			elseif playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait then
					hasFadedBackgroundInOrientation = self.hasFadedBackgroundInPortrait
					self.hasFadedBackgroundInPortrait = true
			end
		end
	
		if not hasFadedBackgroundInOrientation then
			self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
			self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
			self.tweenInAlphaStart = tick()
		end
	end
	
	function DynamicThumbstick:DoMove(direction)
		local currentMoveVector = direction
	
		-- Scaled Radial Dead Zone
		local inputAxisMagnitude = currentMoveVector.magnitude
		if inputAxisMagnitude < self.radiusOfDeadZone then
			currentMoveVector = ZERO_VECTOR3
		else
			currentMoveVector = currentMoveVector.unit*(
				1 - math.max(0, (self.radiusOfMaxSpeed - currentMoveVector.magnitude)/self.radiusOfMaxSpeed)
			)
			currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
		end
	
		self.moveVector = currentMoveVector
	end
	
	
	function DynamicThumbstick:LayoutMiddleImages(startPos, endPos)
		local startDist = (self.thumbstickSize / 2) + self.middleSize
		local vector = endPos - startPos
		local distAvailable = vector.magnitude - (self.thumbstickRingSize / 2) - self.middleSize
		local direction = vector.unit
	
		local distNeeded = self.middleSpacing * NUM_MIDDLE_IMAGES
		local spacing = self.middleSpacing
	
		if distNeeded < distAvailable then
			spacing = distAvailable / NUM_MIDDLE_IMAGES
		end
	
		for i = 1, NUM_MIDDLE_IMAGES do
			local image = self.middleImages[i]
			local distWithout = startDist + (spacing * (i - 2))
			local currentDist = startDist + (spacing * (i - 1))
	
			if distWithout < distAvailable then
				local pos = endPos - direction * currentDist
				local exposedFraction = math.clamp(1 - ((currentDist - distAvailable) / spacing), 0, 1)
	
				image.Visible = true
				image.Position = UDim2.new(0, pos.X, 0, pos.Y)
				image.Size = UDim2.new(0, self.middleSize * exposedFraction, 0, self.middleSize * exposedFraction)
			else
				image.Visible = false
			end
		end
	end
	
	function DynamicThumbstick:MoveStick(pos)
		local vector2StartPosition = Vector2.new(self.moveTouchStartPosition.X, self.moveTouchStartPosition.Y)
		local startPos = vector2StartPosition - self.thumbstickFrame.AbsolutePosition
		local endPos = Vector2.new(pos.X, pos.Y) - self.thumbstickFrame.AbsolutePosition
		self.endImage.Position = UDim2.new(0, endPos.X, 0, endPos.Y)
		self:LayoutMiddleImages(startPos, endPos)
	end
	
	function DynamicThumbstick:BindContextActions()
		local function inputBegan(inputObject)
			if self.moveTouchObject then
				return Enum.ContextActionResult.Pass
			end
	
			if not self:InputInFrame(inputObject) then
				return Enum.ContextActionResult.Pass
			end
	
			if self.isFirstTouch then
				self.isFirstTouch = false
				local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out,0,false,0)
				TweenService:Create(self.startImage, tweenInfo, {Size = UDim2.new(0, 0, 0, 0)}):Play()
				TweenService:Create(
					self.endImage,
					tweenInfo,
					{Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize), ImageColor3 = Color3.new(0,0,0)}
				):Play()
			end
	
			self.moveTouchLockedIn = false
			self.moveTouchObject = inputObject
			self.moveTouchStartPosition = inputObject.Position
			self.moveTouchFirstChanged = true
	
			if FADE_IN_OUT_BACKGROUND then
				self:DoFadeInBackground()
			end
	
			return Enum.ContextActionResult.Pass
		end
	
		local function inputChanged(inputObject)
			if inputObject == self.moveTouchObject then
				if self.moveTouchFirstChanged then
					self.moveTouchFirstChanged = false
	
					local startPosVec2 = Vector2.new(
						inputObject.Position.X - self.thumbstickFrame.AbsolutePosition.X,
						inputObject.Position.Y - self.thumbstickFrame.AbsolutePosition.Y
					)
					self.startImage.Visible = true
					self.startImage.Position = UDim2.new(0, startPosVec2.X, 0, startPosVec2.Y)
					self.endImage.Visible = true
					self.endImage.Position = self.startImage.Position
	
					self:FadeThumbstick(true)
					self:MoveStick(inputObject.Position)
				end
	
				self.moveTouchLockedIn = true
	
				local direction = Vector2.new(
					inputObject.Position.x - self.moveTouchStartPosition.x,
					inputObject.Position.y - self.moveTouchStartPosition.y
				)
				if math.abs(direction.x) > 0 or math.abs(direction.y) > 0 then
					self:DoMove(direction)
					self:MoveStick(inputObject.Position)
				end
				return Enum.ContextActionResult.Sink
			end
			return Enum.ContextActionResult.Pass
		end
	
		local function inputEnded(inputObject)
			if inputObject == self.moveTouchObject then
				self:OnInputEnded()
				if self.moveTouchLockedIn then
					return Enum.ContextActionResult.Sink
				end
			end
			return Enum.ContextActionResult.Pass
		end
	
		local function handleInput(actionName, inputState, inputObject)
			if inputState == Enum.UserInputState.Begin then
				return inputBegan(inputObject)
			elseif inputState == Enum.UserInputState.Change then
				return inputChanged(inputObject)
			elseif inputState == Enum.UserInputState.End then
				return inputEnded(inputObject)
			elseif inputState == Enum.UserInputState.Cancel then
				self:OnInputEnded()
			end
		end
	
		ContextActionService:BindActionAtPriority(
			DYNAMIC_THUMBSTICK_ACTION_NAME,
			handleInput,
			false,
			DYNAMIC_THUMBSTICK_ACTION_PRIORITY,
			Enum.UserInputType.Touch)
	end
	
	function DynamicThumbstick:Create(parentFrame)
		if self.thumbstickFrame then
			self.thumbstickFrame:Destroy()
			self.thumbstickFrame = nil
			if self.onRenderSteppedConn then
				self.onRenderSteppedConn:Disconnect()
				self.onRenderSteppedConn = nil
			end
		end
	
		self.thumbstickSize = 45
		self.thumbstickRingSize = 20
		self.middleSize = 10
		self.middleSpacing = self.middleSize + 4
		self.radiusOfDeadZone = 2
		self.radiusOfMaxSpeed = 20
	
		local screenSize = parentFrame.AbsoluteSize
		local isBigScreen = math.min(screenSize.x, screenSize.y) > 500
		if isBigScreen then
			self.thumbstickSize = self.thumbstickSize * 2
			self.thumbstickRingSize = self.thumbstickRingSize * 2
			self.middleSize = self.middleSize * 2
			self.middleSpacing = self.middleSpacing * 2
			self.radiusOfDeadZone = self.radiusOfDeadZone * 2
			self.radiusOfMaxSpeed = self.radiusOfMaxSpeed * 2
		end
	
		local function layoutThumbstickFrame(portraitMode)
			if portraitMode then
				self.thumbstickFrame.Size = UDim2.new(1, 0, 0.4, 0)
				self.thumbstickFrame.Position = UDim2.new(0, 0, 0.6, 0)
			else
				self.thumbstickFrame.Size = UDim2.new(0.4, 0, 2/3, 0)
				self.thumbstickFrame.Position = UDim2.new(0, 0, 1/3, 0)
			end
		end
	
		self.thumbstickFrame = Instance.new("Frame")
		self.thumbstickFrame.BorderSizePixel = 0
		self.thumbstickFrame.Name = "DynamicThumbstickFrame"
		self.thumbstickFrame.Visible = false
		self.thumbstickFrame.BackgroundTransparency = 1.0
		self.thumbstickFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		self.thumbstickFrame.Active = false
		layoutThumbstickFrame(false)
	
		self.startImage = Instance.new("ImageLabel")
		self.startImage.Name = "ThumbstickStart"
		self.startImage.Visible = true
		self.startImage.BackgroundTransparency = 1
		self.startImage.Image = TOUCH_CONTROLS_SHEET
		self.startImage.ImageRectOffset = Vector2.new(1,1)
		self.startImage.ImageRectSize = Vector2.new(144, 144)
		self.startImage.ImageColor3 = Color3.new(0, 0, 0)
		self.startImage.AnchorPoint = Vector2.new(0.5, 0.5)
		self.startImage.Position = UDim2.new(0, self.thumbstickRingSize * 3.3, 1, -self.thumbstickRingSize  * 2.8)
		self.startImage.Size = UDim2.new(0, self.thumbstickRingSize  * 3.7, 0, self.thumbstickRingSize  * 3.7)
		self.startImage.ZIndex = 10
		self.startImage.Parent = self.thumbstickFrame
	
		self.endImage = Instance.new("ImageLabel")
		self.endImage.Name = "ThumbstickEnd"
		self.endImage.Visible = true
		self.endImage.BackgroundTransparency = 1
		self.endImage.Image = TOUCH_CONTROLS_SHEET
		self.endImage.ImageRectOffset = Vector2.new(1,1)
		self.endImage.ImageRectSize =  Vector2.new(144, 144)
		self.endImage.AnchorPoint = Vector2.new(0.5, 0.5)
		self.endImage.Position = self.startImage.Position
		self.endImage.Size = UDim2.new(0, self.thumbstickSize * 0.8, 0, self.thumbstickSize * 0.8)
		self.endImage.ZIndex = 10
		self.endImage.Parent = self.thumbstickFrame
	
		for i = 1, NUM_MIDDLE_IMAGES do
			self.middleImages[i] = Instance.new("ImageLabel")
			self.middleImages[i].Name = "ThumbstickMiddle"
			self.middleImages[i].Visible = false
			self.middleImages[i].BackgroundTransparency = 1
			self.middleImages[i].Image = TOUCH_CONTROLS_SHEET
			self.middleImages[i].ImageRectOffset = Vector2.new(1,1)
			self.middleImages[i].ImageRectSize = Vector2.new(144, 144)
			self.middleImages[i].ImageTransparency = MIDDLE_TRANSPARENCIES[i]
			self.middleImages[i].AnchorPoint = Vector2.new(0.5, 0.5)
			self.middleImages[i].ZIndex = 9
			self.middleImages[i].Parent = self.thumbstickFrame
		end
	
		local CameraChangedConn = nil
		local function onCurrentCameraChanged()
			if CameraChangedConn then
				CameraChangedConn:Disconnect()
				CameraChangedConn = nil
			end
			local newCamera = workspace.CurrentCamera
			if newCamera then
				local function onViewportSizeChanged()
					local size = newCamera.ViewportSize
					local portraitMode = size.X < size.Y
					layoutThumbstickFrame(portraitMode)
				end
				CameraChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(onViewportSizeChanged)
				onViewportSizeChanged()
			end
		end
		workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(onCurrentCameraChanged)
		if workspace.CurrentCamera then
			onCurrentCameraChanged()
		end
	
		self.moveTouchStartPosition = nil
	
		self.startImageFadeTween = nil
		self.endImageFadeTween = nil
		self.middleImageFadeTweens = {}
	
		self.onRenderSteppedConn = RunService.RenderStepped:Connect(function()
			if self.tweenInAlphaStart ~= nil then
				local delta = tick() - self.tweenInAlphaStart
				local fadeInTime = (self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance)
				self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA*math.min(delta/fadeInTime, 1)
				if delta > fadeInTime then
					self.tweenOutAlphaStart = tick()
					self.tweenInAlphaStart = nil
				end
			elseif self.tweenOutAlphaStart ~= nil then
				local delta = tick() - self.tweenOutAlphaStart
				local fadeOutTime = (self.fadeInAndOutHalfDuration * 2) - (self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance)
				self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA + FADE_IN_OUT_MAX_ALPHA*math.min(delta/fadeOutTime, 1)
				if delta > fadeOutTime  then
					self.tweenOutAlphaStart = nil
				end
			end
		end)
	
		self.onTouchEndedConn = UserInputService.TouchEnded:connect(function(inputObject)
			if inputObject == self.moveTouchObject then
				self:OnInputEnded()
			end
		end)
	
		GuiService.MenuOpened:connect(function()
			if self.moveTouchObject then
				self:OnInputEnded()
			end
		end)
	
		local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
		while not playerGui do
			LocalPlayer.ChildAdded:wait()
			playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
		end
	
		local playerGuiChangedConn = nil
		local originalScreenOrientationWasLandscape =	playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or
														playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight
	
		local function longShowBackground()
			self.fadeInAndOutHalfDuration = 2.5
			self.fadeInAndOutBalance = 0.05
			self.tweenInAlphaStart = tick()
		end
	
		playerGuiChangedConn = playerGui:GetPropertyChangedSignal("CurrentScreenOrientation"):Connect(function()
			if (originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait) or
				(not originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation ~= Enum.ScreenOrientation.Portrait) then
	
				playerGuiChangedConn:disconnect()
				longShowBackground()
	
				if originalScreenOrientationWasLandscape then
					self.hasFadedBackgroundInPortrait = true
				else
					self.hasFadedBackgroundInLandscape = true
				end
			end
		end)
	
		self.thumbstickFrame.Parent = parentFrame
	
		if game:IsLoaded() then
			longShowBackground()
		else
			coroutine.wrap(function()
				game.Loaded:Wait()
				longShowBackground()
			end)()
		end
	end
	
	return DynamicThumbstick
end

function _Gamepad()
	local UserInputService = game:GetService("UserInputService")
	local ContextActionService = game:GetService("ContextActionService")
	
	--[[ Constants ]]--
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	local NONE = Enum.UserInputType.None
	local thumbstickDeadzone = 0.2
	
	--[[ The Module ]]--
	local BaseCharacterController = _BaseCharacterController()
	local Gamepad = setmetatable({}, BaseCharacterController)
	Gamepad.__index = Gamepad
	
	function Gamepad.new(CONTROL_ACTION_PRIORITY)
		local self = setmetatable(BaseCharacterController.new(), Gamepad)
	
		self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	
		self.forwardValue  = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
	
		self.activeGamepad = NONE	-- Enum.UserInputType.Gamepad1, 2, 3...
		self.gamepadConnectedConn = nil
		self.gamepadDisconnectedConn = nil
		return self
	end
	
	function Gamepad:Enable(enable)
		if not UserInputService.GamepadEnabled then
			return false
		end
	
		if enable == self.enabled then
			-- Module is already in the state being requested. True is returned here since the module will be in the state
			-- expected by the code that follows the Enable() call. This makes more sense than returning false to indicate
			-- no action was necessary. False indicates failure to be in requested/expected state.
			return true
		end
	
		self.forwardValue  = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
		self.moveVector = ZERO_VECTOR3
		self.isJumping = false
	
		if enable then
			self.activeGamepad = self:GetHighestPriorityGamepad()
			if self.activeGamepad ~= NONE then
				self:BindContextActions()
				self:ConnectGamepadConnectionListeners()
			else
				-- No connected gamepads, failure to enable
				return false
			end
		else
			self:UnbindContextActions()
			self:DisconnectGamepadConnectionListeners()
			self.activeGamepad = NONE
		end
	
		self.enabled = enable
		return true
	end
	
	-- This function selects the lowest number gamepad from the currently-connected gamepad
	-- and sets it as the active gamepad
	function Gamepad:GetHighestPriorityGamepad()
		local connectedGamepads = UserInputService:GetConnectedGamepads()
		local bestGamepad = NONE -- Note that this value is higher than all valid gamepad values
		for _, gamepad in pairs(connectedGamepads) do
			if gamepad.Value < bestGamepad.Value then
				bestGamepad = gamepad
			end
		end
		return bestGamepad
	end
	
	function Gamepad:BindContextActions()
	
		if self.activeGamepad == NONE then
			-- There must be an active gamepad to set up bindings
			return false
		end
	
		local handleJumpAction = function(actionName, inputState, inputObject)
			self.isJumping = (inputState == Enum.UserInputState.Begin)
			return Enum.ContextActionResult.Sink
		end
	
		local handleThumbstickInput = function(actionName, inputState, inputObject)
	
			if inputState == Enum.UserInputState.Cancel then
				self.moveVector = ZERO_VECTOR3
				return Enum.ContextActionResult.Sink
			end
	
			if self.activeGamepad ~= inputObject.UserInputType then
				return Enum.ContextActionResult.Pass
			end
			if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end
	
			if inputObject.Position.magnitude > thumbstickDeadzone then
				self.moveVector  =  Vector3.new(inputObject.Position.X, 0, -inputObject.Position.Y)
			else
				self.moveVector = ZERO_VECTOR3
			end
			return Enum.ContextActionResult.Sink
		end
	
		ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
		ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false,
			self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonA)
		ContextActionService:BindActionAtPriority("moveThumbstick", handleThumbstickInput, false,
			self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Thumbstick1)
	
		return true
	end
	
	function Gamepad:UnbindContextActions()
		if self.activeGamepad ~= NONE then
			ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
		end
		ContextActionService:UnbindAction("moveThumbstick")
		ContextActionService:UnbindAction("jumpAction")
	end
	
	function Gamepad:OnNewGamepadConnected()
		-- A new gamepad has been connected.
		local bestGamepad = self:GetHighestPriorityGamepad()
	
		if bestGamepad == self.activeGamepad then
			-- A new gamepad was connected, but our active gamepad is not changing
			return
		end
	
		if bestGamepad == NONE then
			-- There should be an active gamepad when GamepadConnected fires, so this should not
			-- normally be hit. If there is no active gamepad, unbind actions but leave
			-- the module enabled and continue to listen for a new gamepad connection.
			warn("Gamepad:OnNewGamepadConnected found no connected gamepads")
			self:UnbindContextActions()
			return
		end
	
		if self.activeGamepad ~= NONE then
			-- Switching from one active gamepad to another
			self:UnbindContextActions()
		end
	
		self.activeGamepad = bestGamepad
		self:BindContextActions()
	end
	
	function Gamepad:OnCurrentGamepadDisconnected()
		if self.activeGamepad ~= NONE then
			ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
		end
	
		local bestGamepad = self:GetHighestPriorityGamepad()
	
		if self.activeGamepad ~= NONE and bestGamepad == self.activeGamepad then
			warn("Gamepad:OnCurrentGamepadDisconnected found the supposedly disconnected gamepad in connectedGamepads.")
			self:UnbindContextActions()
			self.activeGamepad = NONE
			return
		end
	
		if bestGamepad == NONE then
			-- No active gamepad, unbinding actions but leaving gamepad connection listener active
			self:UnbindContextActions()
			self.activeGamepad = NONE
		else
			-- Set new gamepad as active and bind to tool activation
			self.activeGamepad = bestGamepad
			ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
		end
	end
	
	function Gamepad:ConnectGamepadConnectionListeners()
		self.gamepadConnectedConn = UserInputService.GamepadConnected:Connect(function(gamepadEnum)
			self:OnNewGamepadConnected()
		end)
	
		self.gamepadDisconnectedConn = UserInputService.GamepadDisconnected:Connect(function(gamepadEnum)
			if self.activeGamepad == gamepadEnum then
				self:OnCurrentGamepadDisconnected()
			end
		end)
	
	end
	
	function Gamepad:DisconnectGamepadConnectionListeners()
		if self.gamepadConnectedConn then
			self.gamepadConnectedConn:Disconnect()
			self.gamepadConnectedConn = nil
		end
	
		if self.gamepadDisconnectedConn then
			self.gamepadDisconnectedConn:Disconnect()
			self.gamepadDisconnectedConn = nil
		end
	end
	
	return Gamepad
end

function _Keyboard()
	
	--[[ Roblox Services ]]--
	local UserInputService = game:GetService("UserInputService")
	local ContextActionService = game:GetService("ContextActionService")
	
	--[[ Constants ]]--
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	
	--[[ The Module ]]--
	local BaseCharacterController = _BaseCharacterController()
	local Keyboard = setmetatable({}, BaseCharacterController)
	Keyboard.__index = Keyboard
	
	function Keyboard.new(CONTROL_ACTION_PRIORITY)
		local self = setmetatable(BaseCharacterController.new(), Keyboard)
	
		self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	
		self.textFocusReleasedConn = nil
		self.textFocusGainedConn = nil
		self.windowFocusReleasedConn = nil
	
		self.forwardValue  = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
	
		self.jumpEnabled = true
	
		return self
	end
	
	function Keyboard:Enable(enable)
		if not UserInputService.KeyboardEnabled then
			return false
		end
	
		if enable == self.enabled then
			-- Module is already in the state being requested. True is returned here since the module will be in the state
			-- expected by the code that follows the Enable() call. This makes more sense than returning false to indicate
			-- no action was necessary. False indicates failure to be in requested/expected state.
			return true
		end
	
		self.forwardValue  = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
		self.moveVector = ZERO_VECTOR3
		self.jumpRequested = false
		self:UpdateJump()
	
		if enable then
			self:BindContextActions()
			self:ConnectFocusEventListeners()
		else
			self:UnbindContextActions()
			self:DisconnectFocusEventListeners()
		end
	
		self.enabled = enable
		return true
	end
	
	function Keyboard:UpdateMovement(inputState)
		if inputState == Enum.UserInputState.Cancel then
			self.moveVector = ZERO_VECTOR3
		else
			self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
		end
	end
	
	function Keyboard:UpdateJump()
		self.isJumping = self.jumpRequested
	end
	
	function Keyboard:BindContextActions()
	
		-- Note: In the previous version of this code, the movement values were not zeroed-out on UserInputState. Cancel, now they are,
		-- which fixes them from getting stuck on.
		-- We return ContextActionResult.Pass here for legacy reasons.
		-- Many games rely on gameProcessedEvent being false on UserInputService.InputBegan for these control actions.
		local handleMoveForward = function(actionName, inputState, inputObject)
			self.forwardValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
			self:UpdateMovement(inputState)
			return Enum.ContextActionResult.Pass
		end
	
		local handleMoveBackward = function(actionName, inputState, inputObject)
			self.backwardValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
			self:UpdateMovement(inputState)
			return Enum.ContextActionResult.Pass
		end
	
		local handleMoveLeft = function(actionName, inputState, inputObject)
			self.leftValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
			self:UpdateMovement(inputState)
			return Enum.ContextActionResult.Pass
		end
	
		local handleMoveRight = function(actionName, inputState, inputObject)
			self.rightValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
			self:UpdateMovement(inputState)
			return Enum.ContextActionResult.Pass
		end
	
		local handleJumpAction = function(actionName, inputState, inputObject)
			self.jumpRequested = self.jumpEnabled and (inputState == Enum.UserInputState.Begin)
			self:UpdateJump()
			return Enum.ContextActionResult.Pass
		end
	
		-- TODO: Revert to KeyCode bindings so that in the future the abstraction layer from actual keys to
		-- movement direction is done in Lua
		ContextActionService:BindActionAtPriority("moveForwardAction", handleMoveForward, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterForward)
		ContextActionService:BindActionAtPriority("moveBackwardAction", handleMoveBackward, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterBackward)
		ContextActionService:BindActionAtPriority("moveLeftAction", handleMoveLeft, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterLeft)
		ContextActionService:BindActionAtPriority("moveRightAction", handleMoveRight, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterRight)
		ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterJump)
	end
	
	function Keyboard:UnbindContextActions()
		ContextActionService:UnbindAction("moveForwardAction")
		ContextActionService:UnbindAction("moveBackwardAction")
		ContextActionService:UnbindAction("moveLeftAction")
		ContextActionService:UnbindAction("moveRightAction")
		ContextActionService:UnbindAction("jumpAction")
	end
	
	function Keyboard:ConnectFocusEventListeners()
		local function onFocusReleased()
			self.moveVector = ZERO_VECTOR3
			self.forwardValue  = 0
			self.backwardValue = 0
			self.leftValue = 0
			self.rightValue = 0
			self.jumpRequested = false
			self:UpdateJump()
		end
	
		local function onTextFocusGained(textboxFocused)
			self.jumpRequested = false
			self:UpdateJump()
		end
	
		self.textFocusReleasedConn = UserInputService.TextBoxFocusReleased:Connect(onFocusReleased)
		self.textFocusGainedConn = UserInputService.TextBoxFocused:Connect(onTextFocusGained)
		self.windowFocusReleasedConn = UserInputService.WindowFocused:Connect(onFocusReleased)
	end
	
	function Keyboard:DisconnectFocusEventListeners()
		if self.textFocusReleasedCon then
			self.textFocusReleasedCon:Disconnect()
			self.textFocusReleasedCon = nil
		end
		if self.textFocusGainedConn then
			self.textFocusGainedConn:Disconnect()
			self.textFocusGainedConn = nil
		end
		if self.windowFocusReleasedConn then
			self.windowFocusReleasedConn:Disconnect()
			self.windowFocusReleasedConn = nil
		end
	end
	
	return Keyboard
end

function _ControlModule()
	local ControlModule = {}
	ControlModule.__index = ControlModule
	
	--[[ Roblox Services ]]--
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local Workspace = game:GetService("Workspace")
	local UserGameSettings = UserSettings():GetService("UserGameSettings")
	
	-- Roblox User Input Control Modules - each returns a new() constructor function used to create controllers as needed
	local Keyboard = _Keyboard()
	local Gamepad = _Gamepad()
	local DynamicThumbstick = _DynamicThumbstick()
	
	local FFlagUserMakeThumbstickDynamic do
		local success, value = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserMakeThumbstickDynamic")
		end)
		FFlagUserMakeThumbstickDynamic = success and value
	end
	
	local TouchThumbstick = FFlagUserMakeThumbstickDynamic and DynamicThumbstick or _TouchThumbstick()
	
	-- These controllers handle only walk/run movement, jumping is handled by the
	-- TouchJump controller if any of these are active
	local ClickToMove = _ClickToMoveController()
	local TouchJump = _TouchJump()
	
	local VehicleController = _VehicleController()
	
	local CONTROL_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
	
	-- Mapping from movement mode and lastInputType enum values to control modules to avoid huge if elseif switching
	local movementEnumToModuleMap = {
		[Enum.TouchMovementMode.DPad] = DynamicThumbstick,
		[Enum.DevTouchMovementMode.DPad] = DynamicThumbstick,
		[Enum.TouchMovementMode.Thumbpad] = DynamicThumbstick,
		[Enum.DevTouchMovementMode.Thumbpad] = DynamicThumbstick,
		[Enum.TouchMovementMode.Thumbstick] = TouchThumbstick,
		[Enum.DevTouchMovementMode.Thumbstick] = TouchThumbstick,
		[Enum.TouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
		[Enum.DevTouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
		[Enum.TouchMovementMode.ClickToMove] = ClickToMove,
		[Enum.DevTouchMovementMode.ClickToMove] = ClickToMove,
	
		-- Current default
		[Enum.TouchMovementMode.Default] = DynamicThumbstick,
	
		[Enum.ComputerMovementMode.Default] = Keyboard,
		[Enum.ComputerMovementMode.KeyboardMouse] = Keyboard,
		[Enum.DevComputerMovementMode.KeyboardMouse] = Keyboard,
		[Enum.DevComputerMovementMode.Scriptable] = nil,
		[Enum.ComputerMovementMode.ClickToMove] = ClickToMove,
		[Enum.DevComputerMovementMode.ClickToMove] = ClickToMove,
	}
	
	-- Keyboard controller is really keyboard and mouse controller
	local computerInputTypeToModuleMap = {
		[Enum.UserInputType.Keyboard] = Keyboard,
		[Enum.UserInputType.MouseButton1] = Keyboard,
		[Enum.UserInputType.MouseButton2] = Keyboard,
		[Enum.UserInputType.MouseButton3] = Keyboard,
		[Enum.UserInputType.MouseWheel] = Keyboard,
		[Enum.UserInputType.MouseMovement] = Keyboard,
		[Enum.UserInputType.Gamepad1] = Gamepad,
		[Enum.UserInputType.Gamepad2] = Gamepad,
		[Enum.UserInputType.Gamepad3] = Gamepad,
		[Enum.UserInputType.Gamepad4] = Gamepad,
	}
	
	local lastInputType
	
	function ControlModule.new()
		local self = setmetatable({},ControlModule)
	
		-- The Modules above are used to construct controller instances as-needed, and this
		-- table is a map from Module to the instance created from it
		self.controllers = {}
	
		self.activeControlModule = nil	-- Used to prevent unnecessarily expensive checks on each input event
		self.activeController = nil
		self.touchJumpController = nil
		self.moveFunction = Players.LocalPlayer.Move
		self.humanoid = nil
		self.lastInputType = Enum.UserInputType.None
	
		-- For Roblox self.vehicleController
		self.humanoidSeatedConn = nil
		self.vehicleController = nil
	
		self.touchControlFrame = nil
	
		self.vehicleController = VehicleController.new(CONTROL_ACTION_PRIORITY)
	
		Players.LocalPlayer.CharacterAdded:Connect(function(char) self:OnCharacterAdded(char) end)
		Players.LocalPlayer.CharacterRemoving:Connect(function(char) self:OnCharacterRemoving(char) end)
		if Players.LocalPlayer.Character then
			self:OnCharacterAdded(Players.LocalPlayer.Character)
		end
	
		RunService:BindToRenderStep("ControlScriptRenderstep", Enum.RenderPriority.Input.Value, function(dt)
			self:OnRenderStepped(dt)
		end)
	
		UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
			self:OnLastInputTypeChanged(newLastInputType)
		end)
	
	
		UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
			self:OnTouchMovementModeChange()
		end)
		Players.LocalPlayer:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
			self:OnTouchMovementModeChange()
		end)
	
		UserGameSettings:GetPropertyChangedSignal("ComputerMovementMode"):Connect(function()
			self:OnComputerMovementModeChange()
		end)
		Players.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
			self:OnComputerMovementModeChange()
		end)
	
		--[[ Touch Device UI ]]--
		self.playerGui = nil
		self.touchGui = nil
		self.playerGuiAddedConn = nil
	
		if UserInputService.TouchEnabled then
			self.playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
			if self.playerGui then
				self:CreateTouchGuiContainer()
				self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
			else
				self.playerGuiAddedConn = Players.LocalPlayer.ChildAdded:Connect(function(child)
					if child:IsA("PlayerGui") then
						self.playerGui = child
						self:CreateTouchGuiContainer()
						self.playerGuiAddedConn:Disconnect()
						self.playerGuiAddedConn = nil
						self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
					end
				end)
			end
		else
			self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
		end
	
		return self
	end
	
	-- Convenience function so that calling code does not have to first get the activeController
	-- and then call GetMoveVector on it. When there is no active controller, this function returns
	-- nil so that this case can be distinguished from no current movement (which returns zero vector).
	function ControlModule:GetMoveVector()
		if self.activeController then
			return self.activeController:GetMoveVector()
		end
		return Vector3.new(0,0,0)
	end
	
	function ControlModule:GetActiveController()
		return self.activeController
	end
	
	function ControlModule:EnableActiveControlModule()
		if self.activeControlModule == ClickToMove then
			-- For ClickToMove, when it is the player's choice, we also enable the full keyboard controls.
			-- When the developer is forcing click to move, the most keyboard controls (WASD) are not available, only jump.
			self.activeController:Enable(
				true,
				Players.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.UserChoice,
				self.touchJumpController
			)
		elseif self.touchControlFrame then
			self.activeController:Enable(true, self.touchControlFrame)
		else
			self.activeController:Enable(true)
		end
	end
	
	function ControlModule:Enable(enable)
		if not self.activeController then
			return
		end
	
		if enable == nil then
			enable = true
		end
		if enable then
			self:EnableActiveControlModule()
		else
			self:Disable()
		end
	end
	
	-- For those who prefer distinct functions
	function ControlModule:Disable()
		if self.activeController then
			self.activeController:Enable(false)
	
			if self.moveFunction then
				self.moveFunction(Players.LocalPlayer, Vector3.new(0,0,0), true)
			end
		end
	end
	
	
	-- Returns module (possibly nil) and success code to differentiate returning nil due to error vs Scriptable
	function ControlModule:SelectComputerMovementModule()
		if not (UserInputService.KeyboardEnabled or UserInputService.GamepadEnabled) then
			return nil, false
		end
	
		local computerModule
		local DevMovementMode = Players.LocalPlayer.DevComputerMovementMode
	
		if DevMovementMode == Enum.DevComputerMovementMode.UserChoice then
			computerModule = computerInputTypeToModuleMap[lastInputType]
			if UserGameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove and computerModule == Keyboard then
				-- User has ClickToMove set in Settings, prefer ClickToMove controller for keyboard and mouse lastInputTypes
				computerModule = ClickToMove
			end
		else
			-- Developer has selected a mode that must be used.
			computerModule = movementEnumToModuleMap[DevMovementMode]
	
			-- computerModule is expected to be nil here only when developer has selected Scriptable
			if (not computerModule) and DevMovementMode ~= Enum.DevComputerMovementMode.Scriptable then
				warn("No character control module is associated with DevComputerMovementMode ", DevMovementMode)
			end
		end
	
		if computerModule then
			return computerModule, true
		elseif DevMovementMode == Enum.DevComputerMovementMode.Scriptable then
			-- Special case where nil is returned and we actually want to set self.activeController to nil for Scriptable
			return nil, true
		else
			-- This case is for when computerModule is nil because of an error and no suitable control module could
			-- be found.
			return nil, false
		end
	end
	
	-- Choose current Touch control module based on settings (user, dev)
	-- Returns module (possibly nil) and success code to differentiate returning nil due to error vs Scriptable
	function ControlModule:SelectTouchModule()
		if not UserInputService.TouchEnabled then
			return nil, false
		end
		local touchModule
		local DevMovementMode = Players.LocalPlayer.DevTouchMovementMode
		if DevMovementMode == Enum.DevTouchMovementMode.UserChoice then
			touchModule = movementEnumToModuleMap[UserGameSettings.TouchMovementMode]
		elseif DevMovementMode == Enum.DevTouchMovementMode.Scriptable then
			return nil, true
		else
			touchModule = movementEnumToModuleMap[DevMovementMode]
		end
		return touchModule, true
	end
	
	local function calculateRawMoveVector(humanoid, cameraRelativeMoveVector)
		local camera = Workspace.CurrentCamera
		if not camera then
			return cameraRelativeMoveVector
		end
	
		if humanoid:GetState() == Enum.HumanoidStateType.Swimming then
			return camera.CFrame:VectorToWorldSpace(cameraRelativeMoveVector)
		end
	
		local c, s
		local _, _, _, R00, R01, R02, _, _, R12, _, _, R22 = camera.CFrame:GetComponents()
		if R12 < 1 and R12 > -1 then
			-- X and Z components from back vector.
			c = R22
			s = R02
		else
			-- In this case the camera is looking straight up or straight down.
			-- Use X components from right and up vectors.
			c = R00
			s = -R01*math.sign(R12)
		end
		local norm = math.sqrt(c*c + s*s)
		return Vector3.new(
			(c*cameraRelativeMoveVector.x + s*cameraRelativeMoveVector.z)/norm,
			0,
			(c*cameraRelativeMoveVector.z - s*cameraRelativeMoveVector.x)/norm
		)
	end
	
	function ControlModule:OnRenderStepped(dt)
		if self.activeController and self.activeController.enabled and self.humanoid then
			-- Give the controller a chance to adjust its state
			self.activeController:OnRenderStepped(dt)
	
			-- Now retrieve info from the controller
			local moveVector = self.activeController:GetMoveVector()
			local cameraRelative = self.activeController:IsMoveVectorCameraRelative()
	
			local clickToMoveController = self:GetClickToMoveController()
			if self.activeController ~= clickToMoveController then
				if moveVector.magnitude > 0 then
					-- Clean up any developer started MoveTo path
					clickToMoveController:CleanupPath()
				else
					-- Get move vector for developer started MoveTo
					clickToMoveController:OnRenderStepped(dt)
					moveVector = clickToMoveController:GetMoveVector()
					cameraRelative = clickToMoveController:IsMoveVectorCameraRelative()
				end
			end
	
			-- Are we driving a vehicle ?
			local vehicleConsumedInput = false
			if self.vehicleController then
				moveVector, vehicleConsumedInput = self.vehicleController:Update(moveVector, cameraRelative, self.activeControlModule==Gamepad)
			end
	
			-- If not, move the player
			-- Verification of vehicleConsumedInput is commented out to preserve legacy behavior,
			-- in case some game relies on Humanoid.MoveDirection still being set while in a VehicleSeat
			--if not vehicleConsumedInput then
				if cameraRelative then
					moveVector = calculateRawMoveVector(self.humanoid, moveVector)
				end
				self.moveFunction(Players.LocalPlayer, moveVector, false)
			--end
	
			-- And make them jump if needed
			self.humanoid.Jump = self.activeController:GetIsJumping() or (self.touchJumpController and self.touchJumpController:GetIsJumping())
		end
	end
	
	function ControlModule:OnHumanoidSeated(active, currentSeatPart)
		if active then
			if currentSeatPart and currentSeatPart:IsA("VehicleSeat") then
				if not self.vehicleController then
					self.vehicleController = self.vehicleController.new(CONTROL_ACTION_PRIORITY)
				end
				self.vehicleController:Enable(true, currentSeatPart)
			end
		else
			if self.vehicleController then
				self.vehicleController:Enable(false, currentSeatPart)
			end
		end
	end
	
	function ControlModule:OnCharacterAdded(char)
		self.humanoid = char:FindFirstChildOfClass("Humanoid")
		while not self.humanoid do
			char.ChildAdded:wait()
			self.humanoid = char:FindFirstChildOfClass("Humanoid")
		end
	
		if self.touchGui then
			self.touchGui.Enabled = true
		end
	
		if self.humanoidSeatedConn then
			self.humanoidSeatedConn:Disconnect()
			self.humanoidSeatedConn = nil
		end
		self.humanoidSeatedConn = self.humanoid.Seated:Connect(function(active, currentSeatPart)
			self:OnHumanoidSeated(active, currentSeatPart)
		end)
	end
	
	function ControlModule:OnCharacterRemoving(char)
		self.humanoid = nil
	
		if self.touchGui then
			self.touchGui.Enabled = false
		end
	end
	
	-- Helper function to lazily instantiate a controller if it does not yet exist,
	-- disable the active controller if it is different from the on being switched to,
	-- and then enable the requested controller. The argument to this function must be
	-- a reference to one of the control modules, i.e. Keyboard, Gamepad, etc.
	function ControlModule:SwitchToController(controlModule)
		if not controlModule then
			if self.activeController then
				self.activeController:Enable(false)
			end
			self.activeController = nil
			self.activeControlModule = nil
		else
			if not self.controllers[controlModule] then
				self.controllers[controlModule] = controlModule.new(CONTROL_ACTION_PRIORITY)
			end
	
			if self.activeController ~= self.controllers[controlModule] then
				if self.activeController then
					self.activeController:Enable(false)
				end
				self.activeController = self.controllers[controlModule]
				self.activeControlModule = controlModule -- Only used to check if controller switch is necessary
	
				if self.touchControlFrame and (self.activeControlModule == ClickToMove
							or self.activeControlModule == TouchThumbstick
							or self.activeControlModule == DynamicThumbstick) then
					if not self.controllers[TouchJump] then
						self.controllers[TouchJump] = TouchJump.new()
					end
					self.touchJumpController = self.controllers[TouchJump]
					self.touchJumpController:Enable(true, self.touchControlFrame)
				else
					if self.touchJumpController then
						self.touchJumpController:Enable(false)
					end
				end
	
				self:EnableActiveControlModule()
			end
		end
	end
	
	function ControlModule:OnLastInputTypeChanged(newLastInputType)
		if lastInputType == newLastInputType then
			warn("LastInputType Change listener called with current type.")
		end
		lastInputType = newLastInputType
	
		if lastInputType == Enum.UserInputType.Touch then
			-- TODO: Check if touch module already active
			local touchModule, success = self:SelectTouchModule()
			if success then
				while not self.touchControlFrame do
					wait()
				end
				self:SwitchToController(touchModule)
			end
		elseif computerInputTypeToModuleMap[lastInputType] ~= nil then
			local computerModule = self:SelectComputerMovementModule()
			if computerModule then
				self:SwitchToController(computerModule)
			end
		end
	end
	
	-- Called when any relevant values of GameSettings or LocalPlayer change, forcing re-evalulation of
	-- current control scheme
	function ControlModule:OnComputerMovementModeChange()
		local controlModule, success =  self:SelectComputerMovementModule()
		if success then
			self:SwitchToController(controlModule)
		end
	end
	
	function ControlModule:OnTouchMovementModeChange()
		local touchModule, success = self:SelectTouchModule()
		if success then
			while not self.touchControlFrame do
				wait()
			end
			self:SwitchToController(touchModule)
		end
	end
	
	function ControlModule:CreateTouchGuiContainer()
		if self.touchGui then self.touchGui:Destroy() end
	
		-- Container for all touch device guis
		self.touchGui = Instance.new("ScreenGui")
		self.touchGui.Name = "TouchGui"
		self.touchGui.ResetOnSpawn = false
		self.touchGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
		self.touchGui.Enabled = self.humanoid ~= nil
	
		self.touchControlFrame = Instance.new("Frame")
		self.touchControlFrame.Name = "TouchControlFrame"
		self.touchControlFrame.Size = UDim2.new(1, 0, 1, 0)
		self.touchControlFrame.BackgroundTransparency = 1
		self.touchControlFrame.Parent = self.touchGui
	
		self.touchGui.Parent = self.playerGui
	end
	
	function ControlModule:GetClickToMoveController()
		if not self.controllers[ClickToMove] then
			self.controllers[ClickToMove] = ClickToMove.new(CONTROL_ACTION_PRIORITY)
		end
		return self.controllers[ClickToMove]
	end
	
	function ControlModule:IsJumping()
		if self.activeController then
			return self.activeController:GetIsJumping() or (self.touchJumpController and self.touchJumpController:GetIsJumping())
		end
		return false
	end
	
	return ControlModule.new()
end

function _PlayerModule()
	local PlayerModule = {}
	PlayerModule.__index = PlayerModule
	function PlayerModule.new()
		local self = setmetatable({},PlayerModule)
		self.cameras = _CameraModule()
		self.controls = _ControlModule()
		return self
	end
	function PlayerModule:GetCameras()
		return self.cameras
	end
	function PlayerModule:GetControls()
		return self.controls
	end
	function PlayerModule:GetClickToMoveController()
		return self.controls:GetClickToMoveController()
	end
	return PlayerModule.new()
end

function _sounds()
	
	local SetState = Instance.new("BindableEvent",script)
	
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	
	local SOUND_DATA = {
		Climbing = {
			SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
			Looped = true,
		},
		Died = {
			SoundId = "rbxasset://sounds/uuhhh.mp3",
		},
		FreeFalling = {
			SoundId = "rbxasset://sounds/action_falling.mp3",
			Looped = true,
		},
		GettingUp = {
			SoundId = "rbxasset://sounds/action_get_up.mp3",
		},
		Jumping = {
			SoundId = "rbxasset://sounds/action_jump.mp3",
		},
		Landing = {
			SoundId = "rbxasset://sounds/action_jump_land.mp3",
		},
		Running = {
			SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
			Looped = true,
			Pitch = 1.85,
		},
		Splash = {
			SoundId = "rbxasset://sounds/impact_water.mp3",
		},
		Swimming = {
			SoundId = "rbxasset://sounds/action_swim.mp3",
			Looped = true,
			Pitch = 1.6,
		},
	}
	
	 -- wait for the first of the passed signals to fire
	local function waitForFirst(...)
		local shunt = Instance.new("BindableEvent")
		local slots = {...}
	
		local function fire(...)
			for i = 1, #slots do
				slots[i]:Disconnect()
			end
	
			return shunt:Fire(...)
		end
	
		for i = 1, #slots do
			slots[i] = slots[i]:Connect(fire)
		end
	
		return shunt.Event:Wait()
	end
	
	-- map a value from one range to another
	local function map(x, inMin, inMax, outMin, outMax)
		return (x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin
	end
	
	local function playSound(sound)
		sound.TimePosition = 0
		sound.Playing = true
	end
	
	local function stopSound(sound)
		sound.Playing = false
		sound.TimePosition = 0
	end
	
	local function shallowCopy(t)
		local out = {}
		for k, v in pairs(t) do
			out[k] = v
		end
		return out
	end
	
	local function initializeSoundSystem(player, humanoid, rootPart)
		local sounds = {}
	
		-- initialize sounds
		for name, props in pairs(SOUND_DATA) do
			local sound = Instance.new("Sound")
			sound.Name = name
	
			-- set default values
			sound.Archivable = false
			sound.EmitterSize = 5
			sound.MaxDistance = 150
			sound.Volume = 0.65
	
			for propName, propValue in pairs(props) do
				sound[propName] = propValue
			end
	
			sound.Parent = rootPart
			sounds[name] = sound
		end
	
		local playingLoopedSounds = {}
	
		local function stopPlayingLoopedSounds(except)
			for sound in pairs(shallowCopy(playingLoopedSounds)) do
				if sound ~= except then
					sound.Playing = false
					playingLoopedSounds[sound] = nil
				end
			end
		end
	
		-- state transition callbacks
		local stateTransitions = {
			[Enum.HumanoidStateType.FallingDown] = function()
				stopPlayingLoopedSounds()
			end,
	
			[Enum.HumanoidStateType.GettingUp] = function()
				stopPlayingLoopedSounds()
				playSound(sounds.GettingUp)
			end,
	
			[Enum.HumanoidStateType.Jumping] = function()
				stopPlayingLoopedSounds()
				playSound(sounds.Jumping)
			end,
	
			[Enum.HumanoidStateType.Swimming] = function()
				local verticalSpeed = math.abs(rootPart.Velocity.Y)
				if verticalSpeed > 0.1 then
					sounds.Splash.Volume = math.clamp(map(verticalSpeed, 100, 350, 0.28, 1), 0, 1)
					playSound(sounds.Splash)
				end
				stopPlayingLoopedSounds(sounds.Swimming)
				sounds.Swimming.Playing = true
				playingLoopedSounds[sounds.Swimming] = true
			end,
	
			[Enum.HumanoidStateType.Freefall] = function()
				sounds.FreeFalling.Volume = 0
				stopPlayingLoopedSounds(sounds.FreeFalling)
				playingLoopedSounds[sounds.FreeFalling] = true
			end,
	
			[Enum.HumanoidStateType.Landed] = function()
				stopPlayingLoopedSounds()
				local verticalSpeed = math.abs(rootPart.Velocity.Y)
				if verticalSpeed > 75 then
					sounds.Landing.Volume = math.clamp(map(verticalSpeed, 50, 100, 0, 1), 0, 1)
					playSound(sounds.Landing)
				end
			end,
	
			[Enum.HumanoidStateType.Running] = function()
				stopPlayingLoopedSounds(sounds.Running)
				sounds.Running.Playing = true
				playingLoopedSounds[sounds.Running] = true
			end,
	
			[Enum.HumanoidStateType.Climbing] = function()
				local sound = sounds.Climbing
				if math.abs(rootPart.Velocity.Y) > 0.1 then
					sound.Playing = true
					stopPlayingLoopedSounds(sound)
				else
					stopPlayingLoopedSounds()
				end
				playingLoopedSounds[sound] = true
			end,
	
			[Enum.HumanoidStateType.Seated] = function()
				stopPlayingLoopedSounds()
			end,
	
			[Enum.HumanoidStateType.Dead] = function()
				stopPlayingLoopedSounds()
				playSound(sounds.Died)
			end,
		}
	
		-- updaters for looped sounds
		local loopedSoundUpdaters = {
			[sounds.Climbing] = function(dt, sound, vel)
				sound.Playing = vel.Magnitude > 0.1
			end,
	
			[sounds.FreeFalling] = function(dt, sound, vel)
				if vel.Magnitude > 75 then
					sound.Volume = math.clamp(sound.Volume + 0.9*dt, 0, 1)
				else
					sound.Volume = 0
				end
			end,
	
			[sounds.Running] = function(dt, sound, vel)
				sound.Playing = vel.Magnitude > 0.5 and humanoid.MoveDirection.Magnitude > 0.5
			end,
		}
	
		-- state substitutions to avoid duplicating entries in the state table
		local stateRemap = {
			[Enum.HumanoidStateType.RunningNoPhysics] = Enum.HumanoidStateType.Running,
		}
	
		local activeState = stateRemap[humanoid:GetState()] or humanoid:GetState()
		local activeConnections = {}
	
		local stateChangedConn = humanoid.StateChanged:Connect(function(_, state)
			state = stateRemap[state] or state
	
			if state ~= activeState then
				local transitionFunc = stateTransitions[state]
	
				if transitionFunc then
					transitionFunc()
				end
	
				activeState = state
			end
		end)
		
		local customStateChangedConn = SetState.Event:Connect(function(state)
			state = stateRemap[state] or state
	
			if state ~= activeState then
				local transitionFunc = stateTransitions[state]
	
				if transitionFunc then
					transitionFunc()
				end
	
				activeState = state
			end
		end)
	
		local steppedConn = RunService.Stepped:Connect(function(_, worldDt)
			-- update looped sounds on stepped
			for sound in pairs(playingLoopedSounds) do
				local updater = loopedSoundUpdaters[sound]
	
				if updater then
					updater(worldDt, sound, rootPart.Velocity)
				end
			end
		end)
	
		local humanoidAncestryChangedConn
		local rootPartAncestryChangedConn
		local characterAddedConn
	
		local function terminate()
			stateChangedConn:Disconnect()
			customStateChangedConn:Disconnect()
			steppedConn:Disconnect()
			humanoidAncestryChangedConn:Disconnect()
			rootPartAncestryChangedConn:Disconnect()
			characterAddedConn:Disconnect()
		end
	
		humanoidAncestryChangedConn = humanoid.AncestryChanged:Connect(function(_, parent)
			if not parent then
				terminate()
			end
		end)
	
		rootPartAncestryChangedConn = rootPart.AncestryChanged:Connect(function(_, parent)
			if not parent then
				terminate()
			end
		end)
	
		characterAddedConn = player.CharacterAdded:Connect(terminate)
	end
	
	local function playerAdded(player)
		local function characterAdded(character)
			-- Avoiding memory leaks in the face of Character/Humanoid/RootPart lifetime has a few complications:
			-- * character deparenting is a Remove instead of a Destroy, so signals are not cleaned up automatically.
			-- ** must use a waitForFirst on everything and listen for hierarchy changes.
			-- * the character might not be in the dm by the time CharacterAdded fires
			-- ** constantly check consistency with player.Character and abort if CharacterAdded is fired again
			-- * Humanoid may not exist immediately, and by the time it's inserted the character might be deparented.
			-- * RootPart probably won't exist immediately.
			-- ** by the time RootPart is inserted and Humanoid.RootPart is set, the character or the humanoid might be deparented.
	
			if not character.Parent then
				waitForFirst(character.AncestryChanged, player.CharacterAdded)
			end
	
			if player.Character ~= character or not character.Parent then
				return
			end
	
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			while character:IsDescendantOf(game) and not humanoid do
				waitForFirst(character.ChildAdded, character.AncestryChanged, player.CharacterAdded)
				humanoid = character:FindFirstChildOfClass("Humanoid")
			end
	
			if player.Character ~= character or not character:IsDescendantOf(game) then
				return
			end
	
			-- must rely on HumanoidRootPart naming because Humanoid.RootPart does not fire changed signals
			local rootPart = character:FindFirstChild("HumanoidRootPart")
			while character:IsDescendantOf(game) and not rootPart do
				waitForFirst(character.ChildAdded, character.AncestryChanged, humanoid.AncestryChanged, player.CharacterAdded)
				rootPart = character:FindFirstChild("HumanoidRootPart")
			end
	
			if rootPart and humanoid:IsDescendantOf(game) and character:IsDescendantOf(game) and player.Character == character then
				initializeSoundSystem(player, humanoid, rootPart)
			end
		end
	
		if player.Character then
			characterAdded(player.Character)
		end
		player.CharacterAdded:Connect(characterAdded)
	end
	
	Players.PlayerAdded:Connect(playerAdded)
	for _, player in ipairs(Players:GetPlayers()) do
		playerAdded(player)
	end
	return SetState
end

function _StateTracker()
	local EPSILON = 0.1
	
	local SPEED = {
		["onRunning"] = true,
		["onClimbing"] = true 
	}
	
	local INAIR = {
		["onFreeFall"] = true,
		["onJumping"] = true
	}
	
	local STATEMAP = {
		["onRunning"] = Enum.HumanoidStateType.Running,
		["onJumping"] = Enum.HumanoidStateType.Jumping,
		["onFreeFall"] = Enum.HumanoidStateType.Freefall
	}
	
	local StateTracker = {}
	StateTracker.__index = StateTracker
	
	function StateTracker.new(humanoid, soundState)
		local self = setmetatable({}, StateTracker)
		
		self.Humanoid = humanoid
		self.HRP = humanoid.RootPart
		
		self.Speed = 0
		self.State = "onRunning"
		self.Jumped = false
		self.JumpTick = tick()
		
		self.SoundState = soundState
		
		self._ChangedEvent = Instance.new("BindableEvent")
		self.Changed = self._ChangedEvent.Event
		
		return self
	end
	
	function StateTracker:Destroy()
		self._ChangedEvent:Destroy()
	end
	
	function StateTracker:RequestedJump()
		self.Jumped = true
		self.JumpTick = tick()
	end
	
	function StateTracker:OnStep(gravityUp, grounded, isMoving)
		local cVelocity = self.HRP.Velocity
		local gVelocity = cVelocity:Dot(gravityUp)
		
		local oldState, oldSpeed = self.State, self.Speed
		
		local newState
		local newSpeed = cVelocity.Magnitude
	
		if (not grounded) then
			if (gVelocity > 0) then
				if (self.Jumped) then
					newState = "onJumping"
				else
					newState = "onFreeFall"
				end
			else
				if (self.Jumped) then
					self.Jumped = false
				end
				newState = "onFreeFall"
			end
		else
			if (self.Jumped and tick() - self.JumpTick > 0.1) then
				self.Jumped = false
			end
			newSpeed = (cVelocity - gVelocity*gravityUp).Magnitude
			newState = "onRunning"
		end
		
		newSpeed = isMoving and newSpeed or 0
		
		if (oldState ~= newState or (SPEED[newState] and math.abs(oldSpeed - newSpeed) > EPSILON)) then
			self.State = newState
			self.Speed = newSpeed
			self.SoundState:Fire(STATEMAP[newState])
			self._ChangedEvent:Fire(self.State, self.Speed)
		end
	end
	
	return StateTracker
end
function _InitObjects()
	local model = workspace:FindFirstChild("objects") or game:GetObjects("rbxassetid://5045408489")[1]
	local SPHERE = model:WaitForChild("Sphere")
	local FLOOR = model:WaitForChild("Floor")
	local VFORCE = model:WaitForChild("VectorForce")
	local BGYRO = model:WaitForChild("BodyGyro")
	local function initObjects(self)
		local hrp = self.HRP
		local humanoid = self.Humanoid
		local sphere = SPHERE:Clone()
		sphere.Parent = self.Character
		local floor = FLOOR:Clone()
		floor.Parent = self.Character
		local isR15 = (humanoid.RigType == Enum.HumanoidRigType.R15)
		local height = isR15 and (humanoid.HipHeight + 0.05) or 2
		local weld = Instance.new("Weld")
		weld.C0 = CFrame.new(0, -height, 0.1)
		weld.Part0 = hrp
		weld.Part1 = sphere
		weld.Parent = sphere
		local weld2 = Instance.new("Weld")
		weld2.C0 = CFrame.new(0, -(height + 1.5), 0)
		weld2.Part0 = hrp
		weld2.Part1 = floor
		weld2.Parent = floor
		local gyro = BGYRO:Clone()
		gyro.CFrame = hrp.CFrame
		gyro.Parent = hrp
		local vForce = VFORCE:Clone()
		vForce.Attachment0 = isR15 and hrp:WaitForChild("RootRigAttachment") or hrp:WaitForChild("RootAttachment")
		vForce.Parent = hrp
		return sphere, gyro, vForce, floor
	end
	return initObjects
end
local plr = game.Players.LocalPlayer
local ms = plr:GetMouse()
local char
plr.CharacterAdded:Connect(function(c)
	char = c
end)
function _R6()
	function r6()
	local Figure = char
	local Torso = Figure:WaitForChild("Torso")
	local RightShoulder = Torso:WaitForChild("Right Shoulder")
	local LeftShoulder = Torso:WaitForChild("Left Shoulder")
	local RightHip = Torso:WaitForChild("Right Hip")
	local LeftHip = Torso:WaitForChild("Left Hip")
	local Neck = Torso:WaitForChild("Neck")
	local Humanoid = Figure:WaitForChild("Humanoid")
	local pose = "Standing"
	local currentAnim = ""
	local currentAnimInstance = nil
	local currentAnimTrack = nil
	local currentAnimKeyframeHandler = nil
	local currentAnimSpeed = 1.0
	local animTable = {}
	local animNames = { 
		idle = 	{	
					{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
					{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
				},
		walk = 	{ 	
					{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
				}, 
		run = 	{
					{ id = "run.xml", weight = 10 } 
				}, 
		jump = 	{
					{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
				}, 
		fall = 	{
					{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
				}, 
		climb = {
					{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
				}, 
		sit = 	{
					{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
				},	
		toolnone = {
					{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
				},
		toolslash = {
					{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
	--				{ id = "slash.xml", weight = 10 } 
				},
		toollunge = {
					{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
				},
		wave = {
					{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
				},
		point = {
					{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
				},
		dance1 = {
					{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
				},
		dance2 = {
					{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
				},
		dance3 = {
					{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
				},
		laugh = {
					{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
				},
		cheer = {
					{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
				},
	}
	local dances = {"dance1", "dance2", "dance3"}
	-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
	local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}
	function configureAnimationSet(name, fileList)
		if (animTable[name] ~= nil) then
			for _, connection in pairs(animTable[name].connections) do
				connection:disconnect()
			end
		end
		animTable[name] = {}
		animTable[name].count = 0
		animTable[name].totalWeight = 0	
		animTable[name].connections = {}
		-- check for config values
		local config = script:FindFirstChild(name)
		if (config ~= nil) then
	--		print("Loading anims " .. name)
			table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
			table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
			local idx = 1
			for _, childPart in pairs(config:GetChildren()) do
				if (childPart:IsA("Animation")) then
					table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
					animTable[name][idx] = {}
					animTable[name][idx].anim = childPart
					local weightObject = childPart:FindFirstChild("Weight")
					if (weightObject == nil) then
						animTable[name][idx].weight = 1
					else
						animTable[name][idx].weight = weightObject.Value
					end
					animTable[name].count = animTable[name].count + 1
					animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
		--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
					idx = idx + 1
				end
			end
		end
		-- fallback to defaults
		if (animTable[name].count <= 0) then
			for idx, anim in pairs(fileList) do
				animTable[name][idx] = {}
				animTable[name][idx].anim = Instance.new("Animation")
				animTable[name][idx].anim.Name = name
				animTable[name][idx].anim.AnimationId = anim.id
				animTable[name][idx].weight = anim.weight
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
	--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
			end
		end
	end
	-- Setup animation objects
	function scriptChildModified(child)
		local fileList = animNames[child.Name]
		if (fileList ~= nil) then
			configureAnimationSet(child.Name, fileList)
		end	
	end
	
	script.ChildAdded:connect(scriptChildModified)
	script.ChildRemoved:connect(scriptChildModified)
	
	
	for name, fileList in pairs(animNames) do 
		configureAnimationSet(name, fileList)
	end	
	
	-- ANIMATION
	
	-- declarations
	local toolAnim = "None"
	local toolAnimTime = 0
	
	local jumpAnimTime = 0
	local jumpAnimDuration = 0.3
	
	local toolTransitionTime = 0.1
	local fallTransitionTime = 0.3
	local jumpMaxLimbVelocity = 0.75
	
	-- functions
	
	function stopAllAnimations()
		local oldAnim = currentAnim
	
		-- return to idle if finishing an emote
		if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
			oldAnim = "idle"
		end
	
		currentAnim = ""
		currentAnimInstance = nil
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
	
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop()
			currentAnimTrack:Destroy()
			currentAnimTrack = nil
		end
		return oldAnim
	end
	
	function setAnimationSpeed(speed)
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
	
	function keyFrameReachedFunc(frameName)
		if (frameName == "End") then
	
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.0, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
	
	-- Preload animations
	function playAnimation(animName, transitionTime, humanoid) 
			
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
	--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim
	
		-- switch animation		
		if (anim ~= currentAnimInstance) then
			
			if (currentAnimTrack ~= nil) then
				currentAnimTrack:Stop(transitionTime)
				currentAnimTrack:Destroy()
			end
	
			currentAnimSpeed = 1.0
		
			-- load it to the humanoid; get AnimationTrack
			currentAnimTrack = humanoid:LoadAnimation(anim)
			currentAnimTrack.Priority = Enum.AnimationPriority.Core
			 
			-- play the animation
			currentAnimTrack:Play(transitionTime)
			currentAnim = animName
			currentAnimInstance = anim
	
			-- set up keyframe name triggers
			if (currentAnimKeyframeHandler ~= nil) then
				currentAnimKeyframeHandler:disconnect()
			end
			currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
			
		end
	
	end
	
	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	
	local toolAnimName = ""
	local toolAnimTrack = nil
	local toolAnimInstance = nil
	local currentToolAnimKeyframeHandler = nil
	
	function toolKeyFrameReachedFunc(frameName)
		if (frameName == "End") then
	--		print("Keyframe : ".. frameName)	
			playToolAnimation(toolAnimName, 0.0, Humanoid)
		end
	end
	
	
	function playToolAnimation(animName, transitionTime, humanoid, priority)	 
			
			local roll = math.random(1, animTable[animName].totalWeight) 
			local origRoll = roll
			local idx = 1
			while (roll > animTable[animName][idx].weight) do
				roll = roll - animTable[animName][idx].weight
				idx = idx + 1
			end
	--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
			local anim = animTable[animName][idx].anim
	
			if (toolAnimInstance ~= anim) then
				
				if (toolAnimTrack ~= nil) then
					toolAnimTrack:Stop()
					toolAnimTrack:Destroy()
					transitionTime = 0
				end
						
				-- load it to the humanoid; get AnimationTrack
				toolAnimTrack = humanoid:LoadAnimation(anim)
				if priority then
					toolAnimTrack.Priority = priority
				end
				 
				-- play the animation
				toolAnimTrack:Play(transitionTime)
				toolAnimName = animName
				toolAnimInstance = anim
	
				currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
			end
	end
	
	function stopToolAnimations()
		local oldAnim = toolAnimName
	
		if (currentToolAnimKeyframeHandler ~= nil) then
			currentToolAnimKeyframeHandler:disconnect()
		end
	
		toolAnimName = ""
		toolAnimInstance = nil
		if (toolAnimTrack ~= nil) then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			toolAnimTrack = nil
		end
	
	
		return oldAnim
	end
	
	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	
	
	function onRunning(speed)
		if speed > 0.01 then
			playAnimation("walk", 0.1, Humanoid)
			if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
				setAnimationSpeed(speed / 14.5)
			end
			pose = "Running"
		else
			if emoteNames[currentAnim] == nil then
				playAnimation("idle", 0.1, Humanoid)
				pose = "Standing"
			end
		end
	end
	
	function onDied()
		pose = "Dead"
	end
	
	function onJumping()
		playAnimation("jump", 0.1, Humanoid)
		jumpAnimTime = jumpAnimDuration
		pose = "Jumping"
	end
	
	function onClimbing(speed)
		playAnimation("climb", 0.1, Humanoid)
		setAnimationSpeed(speed / 12.0)
		pose = "Climbing"
	end
	
	function onGettingUp()
		pose = "GettingUp"
	end
	
	function onFreeFall()
		if (jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		end
		pose = "FreeFall"
	end
	
	function onFallingDown()
		pose = "FallingDown"
	end
	
	function onSeated()
		pose = "Seated"
	end
	
	function onPlatformStanding()
		pose = "PlatformStanding"
	end
	
	function onSwimming(speed)
		if speed > 0 then
			pose = "Running"
		else
			pose = "Standing"
		end
	end
	
	function getTool()	
		for _, kid in ipairs(Figure:GetChildren()) do
			if kid.className == "Tool" then return kid end
		end
		return nil
	end
	
	function getToolAnim(tool)
		for _, c in ipairs(tool:GetChildren()) do
			if c.Name == "toolanim" and c.className == "StringValue" then
				return c
			end
		end
		return nil
	end
	
	function animateTool()
		
		if (toolAnim == "None") then
			playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
			return
		end
	
		if (toolAnim == "Slash") then
			playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end
	
		if (toolAnim == "Lunge") then
			playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end
	end
	
	function moveSit()
		RightShoulder.MaxVelocity = 0.15
		LeftShoulder.MaxVelocity = 0.15
		RightShoulder:SetDesiredAngle(3.14 /2)
		LeftShoulder:SetDesiredAngle(-3.14 /2)
		RightHip:SetDesiredAngle(3.14 /2)
		LeftHip:SetDesiredAngle(-3.14 /2)
	end
	
	local lastTick = 0
	
	function move(time)
		local amplitude = 1
		local frequency = 1
	  	local deltaTime = time - lastTick
	  	lastTick = time
	
		local climbFudge = 0
		local setAngles = false
	
	  	if (jumpAnimTime > 0) then
	  		jumpAnimTime = jumpAnimTime - deltaTime
	  	end
	
		if (pose == "FreeFall" and jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		elseif (pose == "Seated") then
			playAnimation("sit", 0.5, Humanoid)
			return
		elseif (pose == "Running") then
			playAnimation("walk", 0.1, Humanoid)
		elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
	--		print("Wha " .. pose)
			stopAllAnimations()
			amplitude = 0.1
			frequency = 1
			setAngles = true
		end
	
		if (setAngles) then
			local desiredAngle = amplitude * math.sin(time * frequency)
	
			RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
			LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
			RightHip:SetDesiredAngle(-desiredAngle)
			LeftHip:SetDesiredAngle(-desiredAngle)
		end
	
		-- Tool Animation handling
		local tool = getTool()
		if tool and tool:FindFirstChild("Handle") then
		
			local animStringValueObject = getToolAnim(tool)
	
			if animStringValueObject then
				toolAnim = animStringValueObject.Value
				-- message recieved, delete StringValue
				animStringValueObject.Parent = nil
				toolAnimTime = time + .3
			end
	
			if time > toolAnimTime then
				toolAnimTime = 0
				toolAnim = "None"
			end
	
			animateTool()		
		else
			stopToolAnimations()
			toolAnim = "None"
			toolAnimInstance = nil
			toolAnimTime = 0
		end
	end
	
	
	local events = {}
	local eventHum = Humanoid
	
	local function onUnhook()
		for i = 1, #events do
			events[i]:Disconnect()
		end
		events = {}
	end
	
	local function onHook()
		onUnhook()
		
		pose = eventHum.Sit and "Seated" or "Standing"
		
		events = {
			eventHum.Died:connect(onDied),
			eventHum.Running:connect(onRunning),
			eventHum.Jumping:connect(onJumping),
			eventHum.Climbing:connect(onClimbing),
			eventHum.GettingUp:connect(onGettingUp),
			eventHum.FreeFalling:connect(onFreeFall),
			eventHum.FallingDown:connect(onFallingDown),
			eventHum.Seated:connect(onSeated),
			eventHum.PlatformStanding:connect(onPlatformStanding),
			eventHum.Swimming:connect(onSwimming)
		}
	end
	
	
	onHook()
	
	-- setup emote chat hook
	game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
		local emote = ""
		if msg == "/e dance" then
			emote = dances[math.random(1, #dances)]
		elseif (string.sub(msg, 1, 3) == "/e ") then
			emote = string.sub(msg, 4)
		elseif (string.sub(msg, 1, 7) == "/emote ") then
			emote = string.sub(msg, 8)
		end
		
		if (pose == "Standing" and emoteNames[emote] ~= nil) then
			playAnimation(emote, 0.1, Humanoid)
		end
	
	end)
	
	
	-- main program
	
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
	
	spawn(function()
		while Figure.Parent ~= nil do
			local _, time = wait(0.1)
			move(time)
		end
	end)
	
	return {
		onRunning = onRunning, 
		onDied = onDied, 
		onJumping = onJumping, 
		onClimbing = onClimbing, 
		onGettingUp = onGettingUp, 
		onFreeFall = onFreeFall, 
		onFallingDown = onFallingDown, 
		onSeated = onSeated, 
		onPlatformStanding = onPlatformStanding,
		onHook = onHook,
		onUnhook = onUnhook
	}
	
	end
	return r6()
end

function _R15()
	local function r15()
		
	local Character = char
	local Humanoid = Character:WaitForChild("Humanoid")
	local pose = "Standing"
	
	local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
	local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue
	local userAnimationSpeedDampeningSuccess, userAnimationSpeedDampeningValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimationSpeedDampening") end)
	local userAnimationSpeedDampening = userAnimationSpeedDampeningSuccess and userAnimationSpeedDampeningValue
	
	local animateScriptEmoteHookFlagExists, animateScriptEmoteHookFlagEnabled = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserAnimateScriptEmoteHook")
	end)
	local FFlagAnimateScriptEmoteHook = animateScriptEmoteHookFlagExists and animateScriptEmoteHookFlagEnabled
	
	local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
	local HumanoidHipHeight = 2
	
	local EMOTE_TRANSITION_TIME = 0.1
	
	local currentAnim = ""
	local currentAnimInstance = nil
	local currentAnimTrack = nil
	local currentAnimKeyframeHandler = nil
	local currentAnimSpeed = 1.0
	
	local runAnimTrack = nil
	local runAnimKeyframeHandler = nil
	
	local animTable = {}
	local animNames = { 
		idle = 	{	
					{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
					{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
					{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
				},
		walk = 	{ 	
					{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
				}, 
		run = 	{
					{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
				}, 
		swim = 	{
					{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
				}, 
		swimidle = 	{
					{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
				}, 
		jump = 	{
					{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
				}, 
		fall = 	{
					{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
				}, 
		climb = {
					{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
				}, 
		sit = 	{
					{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
				},	
		toolnone = {
					{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
				},
		toolslash = {
					{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
				},
		toollunge = {
					{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
				},
		wave = {
					{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
				},
		point = {
					{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
				},
		dance = {
					{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
				},
		dance2 = {
					{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
				},
		dance3 = {
					{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
				},
		laugh = {
					{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
				},
		cheer = {
					{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
				},
	}
	
	-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
	local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}
	
	local PreloadAnimsUserFlag = false
	local PreloadedAnims = {}
	local successPreloadAnim, msgPreloadAnim = pcall(function()
		PreloadAnimsUserFlag = UserSettings():IsUserFeatureEnabled("UserPreloadAnimations")
	end)
	if not successPreloadAnim then
		PreloadAnimsUserFlag = false
	end
	
	math.randomseed(tick())
	
	function findExistingAnimationInSet(set, anim)
		if set == nil or anim == nil then
			return 0
		end
		
		for idx = 1, set.count, 1 do 
			if set[idx].anim.AnimationId == anim.AnimationId then
				return idx
			end
		end
		
		return 0
	end
	
	function configureAnimationSet(name, fileList)
		if (animTable[name] ~= nil) then
			for _, connection in pairs(animTable[name].connections) do
				connection:disconnect()
			end
		end
		animTable[name] = {}
		animTable[name].count = 0
		animTable[name].totalWeight = 0	
		animTable[name].connections = {}
	
		local allowCustomAnimations = true
	
		local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
		if not success then
			allowCustomAnimations = true
		end
	
		-- check for config values
		local config = script:FindFirstChild(name)
		if (allowCustomAnimations and config ~= nil) then
			table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
			table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
			
			local idx = 0
			for _, childPart in pairs(config:GetChildren()) do
				if (childPart:IsA("Animation")) then
					local newWeight = 1
					local weightObject = childPart:FindFirstChild("Weight")
					if (weightObject ~= nil) then
						newWeight = weightObject.Value
					end
					animTable[name].count = animTable[name].count + 1
					idx = animTable[name].count
					animTable[name][idx] = {}
					animTable[name][idx].anim = childPart
					animTable[name][idx].weight = newWeight
					animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
					table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
					table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
					table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
				end
			end
		end
		
		-- fallback to defaults
		if (animTable[name].count <= 0) then
			for idx, anim in pairs(fileList) do
				animTable[name][idx] = {}
				animTable[name][idx].anim = Instance.new("Animation")
				animTable[name][idx].anim.Name = name
				animTable[name][idx].anim.AnimationId = anim.id
				animTable[name][idx].weight = anim.weight
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			end
		end
		
		-- preload anims
		if PreloadAnimsUserFlag then
			for i, animType in pairs(animTable) do
				for idx = 1, animType.count, 1 do
					if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
						Humanoid:LoadAnimation(animType[idx].anim)
						PreloadedAnims[animType[idx].anim.AnimationId] = true
					end				
				end
			end
		end
	end
	
	------------------------------------------------------------------------------------------------------------
	
	function configureAnimationSetOld(name, fileList)
		if (animTable[name] ~= nil) then
			for _, connection in pairs(animTable[name].connections) do
				connection:disconnect()
			end
		end
		animTable[name] = {}
		animTable[name].count = 0
		animTable[name].totalWeight = 0	
		animTable[name].connections = {}
	
		local allowCustomAnimations = true
	
		local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
		if not success then
			allowCustomAnimations = true
		end
	
		-- check for config values
		local config = script:FindFirstChild(name)
		if (allowCustomAnimations and config ~= nil) then
			table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
			table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
			local idx = 1
			for _, childPart in pairs(config:GetChildren()) do
				if (childPart:IsA("Animation")) then
					table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
					animTable[name][idx] = {}
					animTable[name][idx].anim = childPart
					local weightObject = childPart:FindFirstChild("Weight")
					if (weightObject == nil) then
						animTable[name][idx].weight = 1
					else
						animTable[name][idx].weight = weightObject.Value
					end
					animTable[name].count = animTable[name].count + 1
					animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
					idx = idx + 1
				end
			end
		end
	
		-- fallback to defaults
		if (animTable[name].count <= 0) then
			for idx, anim in pairs(fileList) do
				animTable[name][idx] = {}
				animTable[name][idx].anim = Instance.new("Animation")
				animTable[name][idx].anim.Name = name
				animTable[name][idx].anim.AnimationId = anim.id
				animTable[name][idx].weight = anim.weight
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
				-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
			end
		end
		
		-- preload anims
		if PreloadAnimsUserFlag then
			for i, animType in pairs(animTable) do
				for idx = 1, animType.count, 1 do 
					Humanoid:LoadAnimation(animType[idx].anim)
				end
			end
		end
	end
	
	-- Setup animation objects
	function scriptChildModified(child)
		local fileList = animNames[child.Name]
		if (fileList ~= nil) then
			configureAnimationSet(child.Name, fileList)
		end	
	end
	
	script.ChildAdded:connect(scriptChildModified)
	script.ChildRemoved:connect(scriptChildModified)
	
	
	for name, fileList in pairs(animNames) do 
		configureAnimationSet(name, fileList)
	end	
	
	-- ANIMATION
	
	-- declarations
	local toolAnim = "None"
	local toolAnimTime = 0
	
	local jumpAnimTime = 0
	local jumpAnimDuration = 0.31
	
	local toolTransitionTime = 0.1
	local fallTransitionTime = 0.2
	
	local currentlyPlayingEmote = false
	
	-- functions
	
	function stopAllAnimations()
		local oldAnim = currentAnim
	
		-- return to idle if finishing an emote
		if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
			oldAnim = "idle"
		end
		
		if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
			oldAnim = "idle"
			currentlyPlayingEmote = false
		end
	
		currentAnim = ""
		currentAnimInstance = nil
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
	
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop()
			currentAnimTrack:Destroy()
			currentAnimTrack = nil
		end
	
		-- clean up walk if there is one
		if (runAnimKeyframeHandler ~= nil) then
			runAnimKeyframeHandler:disconnect()
		end
		
		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop()
			runAnimTrack:Destroy()
			runAnimTrack = nil
		end
		
		return oldAnim
	end
	
	function getHeightScale()
		if Humanoid then
			if not Humanoid.AutomaticScalingEnabled then
				return 1
			end
			
			local scale = Humanoid.HipHeight / HumanoidHipHeight
			if userAnimationSpeedDampening then
				if AnimationSpeedDampeningObject == nil then
					AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
				end
				if AnimationSpeedDampeningObject ~= nil then
					scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
				end
			end
			return scale
		end	
		return 1
	end
	
	local smallButNotZero = 0.0001
	function setRunSpeed(speed)
		local speedScaled = speed * 1.25
		local heightScale = getHeightScale()
		local runSpeed = speedScaled / heightScale
	
		if runSpeed ~= currentAnimSpeed then
			if runSpeed < 0.33 then
				currentAnimTrack:AdjustWeight(1.0)		
				runAnimTrack:AdjustWeight(smallButNotZero)
			elseif runSpeed < 0.66 then
				local weight = ((runSpeed - 0.33) / 0.33)
				currentAnimTrack:AdjustWeight(1.0 - weight + smallButNotZero)
				runAnimTrack:AdjustWeight(weight + smallButNotZero)
			else
				currentAnimTrack:AdjustWeight(smallButNotZero)
				runAnimTrack:AdjustWeight(1.0)
			end
			currentAnimSpeed = runSpeed
			runAnimTrack:AdjustSpeed(runSpeed)
			currentAnimTrack:AdjustSpeed(runSpeed)
		end	
	end
	
	function setAnimationSpeed(speed)
		if currentAnim == "walk" then
				setRunSpeed(speed)
		else
			if speed ~= currentAnimSpeed then
				currentAnimSpeed = speed
				currentAnimTrack:AdjustSpeed(currentAnimSpeed)
			end
		end
	end
	
	function keyFrameReachedFunc(frameName)
		if (frameName == "End") then
			if currentAnim == "walk" then
				if userNoUpdateOnLoop == true then
					if runAnimTrack.Looped ~= true then
						runAnimTrack.TimePosition = 0.0
					end
					if currentAnimTrack.Looped ~= true then
						currentAnimTrack.TimePosition = 0.0
					end
				else
					runAnimTrack.TimePosition = 0.0
					currentAnimTrack.TimePosition = 0.0
				end
			else
				local repeatAnim = currentAnim
				-- return to idle if finishing an emote
				if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
					repeatAnim = "idle"
				end
				
				if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
					if currentAnimTrack.Looped then
						-- Allow the emote to loop
						return
					end
					
					repeatAnim = "idle"
					currentlyPlayingEmote = false
				end
				
				local animSpeed = currentAnimSpeed
				playAnimation(repeatAnim, 0.15, Humanoid)
				setAnimationSpeed(animSpeed)
			end
		end
	end
	
	function rollAnimation(animName)
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
		return idx
	end
	
	local function switchToAnim(anim, animName, transitionTime, humanoid)
		-- switch animation		
		if (anim ~= currentAnimInstance) then
			
			if (currentAnimTrack ~= nil) then
				currentAnimTrack:Stop(transitionTime)
				currentAnimTrack:Destroy()
			end
	
			if (runAnimTrack ~= nil) then
				runAnimTrack:Stop(transitionTime)
				runAnimTrack:Destroy()
				if userNoUpdateOnLoop == true then
					runAnimTrack = nil
				end
			end
	
			currentAnimSpeed = 1.0
		
			-- load it to the humanoid; get AnimationTrack
			currentAnimTrack = humanoid:LoadAnimation(anim)
			currentAnimTrack.Priority = Enum.AnimationPriority.Core
			 
			-- play the animation
			currentAnimTrack:Play(transitionTime)
			currentAnim = animName
			currentAnimInstance = anim
	
			-- set up keyframe name triggers
			if (currentAnimKeyframeHandler ~= nil) then
				currentAnimKeyframeHandler:disconnect()
			end
			currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
			
			-- check to see if we need to blend a walk/run animation
			if animName == "walk" then
				local runAnimName = "run"
				local runIdx = rollAnimation(runAnimName)
	
				runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
				runAnimTrack.Priority = Enum.AnimationPriority.Core
				runAnimTrack:Play(transitionTime)		
				
				if (runAnimKeyframeHandler ~= nil) then
					runAnimKeyframeHandler:disconnect()
				end
				runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
			end
		end
	end
	
	function playAnimation(animName, transitionTime, humanoid) 	
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim
	
		switchToAnim(anim, animName, transitionTime, humanoid)
		currentlyPlayingEmote = false
	end
	
	function playEmote(emoteAnim, transitionTime, humanoid)
		switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
		currentlyPlayingEmote = true
	end
	
	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	
	local toolAnimName = ""
	local toolAnimTrack = nil
	local toolAnimInstance = nil
	local currentToolAnimKeyframeHandler = nil
	
	function toolKeyFrameReachedFunc(frameName)
		if (frameName == "End") then
			playToolAnimation(toolAnimName, 0.0, Humanoid)
		end
	end
	
	
	function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
			local idx = rollAnimation(animName)
			local anim = animTable[animName][idx].anim
	
			if (toolAnimInstance ~= anim) then
				
				if (toolAnimTrack ~= nil) then
					toolAnimTrack:Stop()
					toolAnimTrack:Destroy()
					transitionTime = 0
				end
						
				-- load it to the humanoid; get AnimationTrack
				toolAnimTrack = humanoid:LoadAnimation(anim)
				if priority then
					toolAnimTrack.Priority = priority
				end
				 
				-- play the animation
				toolAnimTrack:Play(transitionTime)
				toolAnimName = animName
				toolAnimInstance = anim
	
				currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
			end
	end
	
	function stopToolAnimations()
		local oldAnim = toolAnimName
	
		if (currentToolAnimKeyframeHandler ~= nil) then
			currentToolAnimKeyframeHandler:disconnect()
		end
	
		toolAnimName = ""
		toolAnimInstance = nil
		if (toolAnimTrack ~= nil) then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			toolAnimTrack = nil
		end
	
		return oldAnim
	end
	
	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	-- STATE CHANGE HANDLERS
	
	function onRunning(speed)
		if speed > 0.75 then
			local scale = 16.0
			playAnimation("walk", 0.2, Humanoid)
			setAnimationSpeed(speed / scale)
			pose = "Running"
		else
			if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
				playAnimation("idle", 0.2, Humanoid)
				pose = "Standing"
			end
		end
	end
	
	function onDied()
		pose = "Dead"
	end
	
	function onJumping()
		playAnimation("jump", 0.1, Humanoid)
		jumpAnimTime = jumpAnimDuration
		pose = "Jumping"
	end
	
	function onClimbing(speed)
		local scale = 5.0
		playAnimation("climb", 0.1, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Climbing"
	end
	
	function onGettingUp()
		pose = "GettingUp"
	end
	
	function onFreeFall()
		if (jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		end
		pose = "FreeFall"
	end
	
	function onFallingDown()
		pose = "FallingDown"
	end
	
	function onSeated()
		pose = "Seated"
	end
	
	function onPlatformStanding()
		pose = "PlatformStanding"
	end
	
	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	
	function onSwimming(speed)
		if speed > 1.00 then
			local scale = 10.0
			playAnimation("swim", 0.4, Humanoid)
			setAnimationSpeed(speed / scale)
			pose = "Swimming"
		else
			playAnimation("swimidle", 0.4, Humanoid)
			pose = "Standing"
		end
	end
	
	function animateTool()
		if (toolAnim == "None") then
			playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
			return
		end
	
		if (toolAnim == "Slash") then
			playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end
	
		if (toolAnim == "Lunge") then
			playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end
	end
	
	function getToolAnim(tool)
		for _, c in ipairs(tool:GetChildren()) do
			if c.Name == "toolanim" and c.className == "StringValue" then
				return c
			end
		end
		return nil
	end
	
	local lastTick = 0
	
	function stepAnimate(currentTime)
		local amplitude = 1
		local frequency = 1
	  	local deltaTime = currentTime - lastTick
	  	lastTick = currentTime
	
		local climbFudge = 0
		local setAngles = false
	
	  	if (jumpAnimTime > 0) then
	  		jumpAnimTime = jumpAnimTime - deltaTime
	  	end
	
		if (pose == "FreeFall" and jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		elseif (pose == "Seated") then
			playAnimation("sit", 0.5, Humanoid)
			return
		elseif (pose == "Running") then
			playAnimation("walk", 0.2, Humanoid)
		elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
			stopAllAnimations()
			amplitude = 0.1
			frequency = 1
			setAngles = true
		end
	
		-- Tool Animation handling
		local tool = Character:FindFirstChildOfClass("Tool")
		if tool and tool:FindFirstChild("Handle") then
			local animStringValueObject = getToolAnim(tool)
	
			if animStringValueObject then
				toolAnim = animStringValueObject.Value
				-- message recieved, delete StringValue
				animStringValueObject.Parent = nil
				toolAnimTime = currentTime + .3
			end
	
			if currentTime > toolAnimTime then
				toolAnimTime = 0
				toolAnim = "None"
			end
	
			animateTool()		
		else
			stopToolAnimations()
			toolAnim = "None"
			toolAnimInstance = nil
			toolAnimTime = 0
		end
	end
	
	-- connect events
	
	local events = {}
	local eventHum = Humanoid
	
	local function onUnhook()
		for i = 1, #events do
			events[i]:Disconnect()
		end
		events = {}
	end
	
	local function onHook()
		onUnhook()
		
		pose = eventHum.Sit and "Seated" or "Standing"
		
		events = {
			eventHum.Died:connect(onDied),
			eventHum.Running:connect(onRunning),
			eventHum.Jumping:connect(onJumping),
			eventHum.Climbing:connect(onClimbing),
			eventHum.GettingUp:connect(onGettingUp),
			eventHum.FreeFalling:connect(onFreeFall),
			eventHum.FallingDown:connect(onFallingDown),
			eventHum.Seated:connect(onSeated),
			eventHum.PlatformStanding:connect(onPlatformStanding),
			eventHum.Swimming:connect(onSwimming)
		}
	end
	
	
	onHook()
	
	-- setup emote chat hook
	game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
		local emote = ""
		if (string.sub(msg, 1, 3) == "/e ") then
			emote = string.sub(msg, 4)
		elseif (string.sub(msg, 1, 7) == "/emote ") then
			emote = string.sub(msg, 8)
		end
		
		if (pose == "Standing" and emoteNames[emote] ~= nil) then
			playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		end
	end)
	
	--[[ emote bindable hook
	if FFlagAnimateScriptEmoteHook then
		script:WaitForChild("PlayEmote").OnInvoke = function(emote)
			-- Only play emotes when idling
			if pose ~= "Standing" then
				return
			end
			if emoteNames[emote] ~= nil then
				-- Default emotes
				playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
				return true
			elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
				-- Non-default emotes
				playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)
				return true
			end
			-- Return false to indicate that the emote could not be played
			return false
		end
	end
	]]
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
	-- loop to handle timed state transitions and tool animations
	spawn(function()
		while Character.Parent ~= nil do
			local _, currentGameTime = wait(0.1)
			stepAnimate(currentGameTime)
		end
	end)
	return {
		onRunning = onRunning, 
		onDied = onDied, 
		onJumping = onJumping, 
		onClimbing = onClimbing, 
		onGettingUp = onGettingUp, 
		onFreeFall = onFreeFall, 
		onFallingDown = onFallingDown, 
		onSeated = onSeated, 
		onPlatformStanding = onPlatformStanding,
		onHook = onHook,
		onUnhook = onUnhook
	}
	end
	return r15()
end
while true do
	wait(.1)
	if plr.Character ~= nil then
		char = plr.Character
		break
	end
end
function _Controller()
	local humanoid = char:WaitForChild("Humanoid")
	local animFuncs = {}
	if (humanoid.RigType == Enum.HumanoidRigType.R6) then
		animFuncs = _R6()
	else
		animFuncs = _R15()
	end
	print("Animation succes")
	return animFuncs
end
function _AnimationHandler()
local AnimationHandler = {}
AnimationHandler.__index = AnimationHandler

function AnimationHandler.new(humanoid, animate)
	local self = setmetatable({}, AnimationHandler)
	
	self._AnimFuncs = _Controller()
	self.Humanoid = humanoid
	
	return self
end

function AnimationHandler:EnableDefault(bool)
	if (bool) then
		self._AnimFuncs.onHook()
	else
		self._AnimFuncs.onUnhook()
	end
end

function AnimationHandler:Run(name, ...)
	self._AnimFuncs[name](...)
end

return AnimationHandler
end

function _GravityController()

local ZERO = Vector3.new(0, 0, 0)
local UNIT_X = Vector3.new(1, 0, 0)
local UNIT_Y = Vector3.new(0, 1, 0)
local UNIT_Z = Vector3.new(0, 0, 1)
local VEC_XY = Vector3.new(1, 0, 1)

local IDENTITYCF = CFrame.new()

local JUMPMODIFIER = 1.2
local TRANSITION = 0.15
local WALKF = 200 / 3

local UIS = game:GetService("UserInputService")
local RUNSERVICE = game:GetService("RunService")

local InitObjects = _InitObjects()
local AnimationHandler = _AnimationHandler()
local StateTracker = _StateTracker()

-- Class

local GravityController = {}
GravityController.__index = GravityController

-- Private Functions

local function getRotationBetween(u, v, axis)
	local dot, uxv = u:Dot(v), u:Cross(v)
	if (dot < -0.99999) then return CFrame.fromAxisAngle(axis, math.pi) end
	return CFrame.new(0, 0, 0, uxv.x, uxv.y, uxv.z, 1 + dot)
end

local function lookAt(pos, forward, up)
	local r = forward:Cross(up)
	local u = r:Cross(forward)
	return CFrame.fromMatrix(pos, r.Unit, u.Unit)
end

local function getMass(array)
	local mass = 0
	for _, part in next, array do
		if (part:IsA("BasePart")) then
			mass = mass + part:GetMass()
		end
	end
	return mass
end

-- Public Constructor
local ExecutedPlayerModule = _PlayerModule()
local ExecutedSounds = _sounds()
function GravityController.new(player)
	local self = setmetatable({}, GravityController)

	--[[ Camera
	local loaded = player.PlayerScripts:WaitForChild("PlayerScriptsLoader"):WaitForChild("Loaded")
	if (not loaded.Value) then
		--loaded.Changed:Wait()
	end
	]]
	local playerModule = ExecutedPlayerModule
	self.Controls = playerModule:GetControls()
	self.Camera = playerModule:GetCameras()
	
	-- Player and character
	self.Player = player
	self.Character = player.Character
	self.Humanoid = player.Character:WaitForChild("Humanoid")
	self.HRP = player.Character:WaitForChild("HumanoidRootPart")
	
	-- Animation
	self.AnimationHandler = AnimationHandler.new(self.Humanoid)
	self.AnimationHandler:EnableDefault(false)
	local ssss = game:GetService("Players").LocalPlayer.PlayerScripts:FindFirstChild("SetState") or Instance.new("BindableEvent",game:GetService("Players").LocalPlayer.PlayerScripts)
	local soundState = ExecutedSounds
	ssss.Name = "SetState"
	
	self.StateTracker = StateTracker.new(self.Humanoid, soundState)
	self.StateTracker.Changed:Connect(function(name, speed)
		self.AnimationHandler:Run(name, speed)
	end)
	
	-- Collider and forces
	local collider, gyro, vForce, floor = InitObjects(self)
	
	floor.Touched:Connect(function() end)
	collider.Touched:Connect(function() end)
	
	self.Collider = collider
	self.VForce = vForce
	self.Gyro = gyro
	self.Floor = floor
	
	-- Attachment to parts
	self.LastPart = workspace.Terrain
	self.LastPartCFrame = IDENTITYCF
	
	-- Gravity properties
	self.GravityUp = UNIT_Y
	self.Ignores = {self.Character}
	
	function self.Camera.GetUpVector(this, oldUpVector)
		return self.GravityUp
	end
	
	-- Events etc
	self.Humanoid.PlatformStand = true
	
	self.CharacterMass = getMass(self.Character:GetDescendants())
	self.Character.AncestryChanged:Connect(function() self.CharacterMass = getMass(self.Character:GetDescendants()) end)
	
	self.JumpCon = RUNSERVICE.RenderStepped:Connect(function(dt) 
		if (self.Controls:IsJumping()) then
			self:OnJumpRequest()
		end
	end)
	
	self.DeathCon = self.Humanoid.Died:Connect(function() self:Destroy() end)
	self.SeatCon = self.Humanoid.Seated:Connect(function(active) if (active) then self:Destroy() end end)
	self.HeartCon = RUNSERVICE.Heartbeat:Connect(function(dt) self:OnHeartbeatStep(dt) end)
	RUNSERVICE:BindToRenderStep("GravityStep", Enum.RenderPriority.Input.Value + 1, function(dt) self:OnGravityStep(dt) end)
	
	
	return self
end

-- Public Methods

function GravityController:Destroy()
	self.JumpCon:Disconnect()
	self.DeathCon:Disconnect()
	self.SeatCon:Disconnect()
	self.HeartCon:Disconnect()
	
	RUNSERVICE:UnbindFromRenderStep("GravityStep")
	
	self.Collider:Destroy()
	self.VForce:Destroy()
	self.Gyro:Destroy()
	self.StateTracker:Destroy()
	
	self.Humanoid.PlatformStand = false
	self.AnimationHandler:EnableDefault(true)
	
	self.GravityUp = UNIT_Y
end

function GravityController:GetGravityUp(oldGravity)
	return oldGravity
end

function GravityController:IsGrounded(isJumpCheck)
	if (not isJumpCheck) then
		local parts = self.Floor:GetTouchingParts()
		for _, part in next, parts do
			if (not part:IsDescendantOf(self.Character)) then
				return true
			end
		end
	else
		if (self.StateTracker.Jumped) then
			return false
		end
	
		-- 1. check we are touching something with the collider
		local valid = {}
		local parts = self.Collider:GetTouchingParts()
		for _, part in next, parts do
			if (not part:IsDescendantOf(self.Character)) then
				table.insert(valid, part)
			end
		end
		
		if (#valid > 0) then
			-- 2. do a decently long downwards raycast
			local max = math.cos(self.Humanoid.MaxSlopeAngle)
			local ray = Ray.new(self.Collider.Position, -10 * self.GravityUp)
			local hit, pos, normal = workspace:FindPartOnRayWithWhitelist(ray, valid, true)
			
			-- 3. use slope to decide on jump
			if (hit and max <= self.GravityUp:Dot(normal)) then
				return true
			end
		end
	end
	return false
end

function GravityController:OnJumpRequest()
	if (not self.StateTracker.Jumped and self:IsGrounded(true)) then
		local hrpVel = self.HRP.Velocity
		self.HRP.Velocity = hrpVel + self.GravityUp*self.Humanoid.JumpPower*JUMPMODIFIER
		self.StateTracker:RequestedJump()
	end
end

function GravityController:GetMoveVector()
	return self.Controls:GetMoveVector()
end

function GravityController:OnHeartbeatStep(dt)
	local ray = Ray.new(self.Collider.Position, -1.1*self.GravityUp)
	local hit, pos, normal = workspace:FindPartOnRayWithIgnoreList(ray, self.Ignores)
	local lastPart = self.LastPart
	
	if (hit and lastPart and lastPart == hit) then
		local offset = self.LastPartCFrame:ToObjectSpace(self.HRP.CFrame)
		self.HRP.CFrame = hit.CFrame:ToWorldSpace(offset)
	end
	
	self.LastPart = hit
	self.LastPartCFrame = hit and hit.CFrame
end

function GravityController:OnGravityStep(dt)
	-- update gravity up vector
	local oldGravity = self.GravityUp
	local newGravity = self:GetGravityUp(oldGravity)
	
	local rotation = getRotationBetween(oldGravity, newGravity, workspace.CurrentCamera.CFrame.RightVector)
	rotation = IDENTITYCF:Lerp(rotation, TRANSITION)
	
	self.GravityUp = rotation * oldGravity
	
	-- get world move vector
	local camCF = workspace.CurrentCamera.CFrame
	local fDot = camCF.LookVector:Dot(newGravity)
	local cForward = math.abs(fDot) > 0.5 and -math.sign(fDot)*camCF.UpVector or camCF.LookVector
	
	local left = cForward:Cross(-newGravity).Unit
	local forward = -left:Cross(newGravity).Unit
	
	local move = self:GetMoveVector()
	local worldMove = forward*move.z - left*move.x
	worldMove = worldMove:Dot(worldMove) > 1 and worldMove.Unit or worldMove
	
	local isInputMoving = worldMove:Dot(worldMove) > 0
	
	-- get the desired character cframe
	local hrpCFLook = self.HRP.CFrame.LookVector
	local charF = hrpCFLook:Dot(forward)*forward + hrpCFLook:Dot(left)*left
	local charR = charF:Cross(newGravity).Unit
	local newCharCF = CFrame.fromMatrix(ZERO, charR, newGravity, -charF)
	
	local newCharRotation = IDENTITYCF
	if (isInputMoving) then
		newCharRotation = IDENTITYCF:Lerp(getRotationBetween(charF, worldMove, newGravity), 0.7)	
	end
	
	-- calculate forces
	local g = workspace.Gravity
	local gForce = g * self.CharacterMass * (UNIT_Y - newGravity)
	
	local cVelocity = self.HRP.Velocity
	local tVelocity = self.Humanoid.WalkSpeed * worldMove
	local gVelocity = cVelocity:Dot(newGravity)*newGravity
	local hVelocity = cVelocity - gVelocity
	
	if (hVelocity:Dot(hVelocity) < 1) then
		hVelocity = ZERO
	end
	
	local dVelocity = tVelocity - hVelocity
	local walkForceM = math.min(10000, WALKF * self.CharacterMass * dVelocity.Magnitude / (dt*60))
	local walkForce = walkForceM > 0 and dVelocity.Unit*walkForceM or ZERO
	
	-- mouse lock
	local charRotation = newCharRotation * newCharCF
	
	if (self.Camera:IsCamRelative()) then
		local lv = workspace.CurrentCamera.CFrame.LookVector
		local hlv = lv - charRotation.UpVector:Dot(lv)*charRotation.UpVector
		charRotation = lookAt(ZERO, hlv, charRotation.UpVector)
	end
	
	-- get state
	self.StateTracker:OnStep(self.GravityUp, self:IsGrounded(), isInputMoving)

	-- update values
	self.VForce.Force = walkForce + gForce
	self.Gyro.CFrame = charRotation
end
return GravityController
end
function _Draw3D()
	local module = {}
	
	-- Style Guide
	
	module.StyleGuide = {
		Point = {
			Thickness = 0.5;
			Color = Color3.new(0, 1, 0);
		},
		
		Line = {
			Thickness = 0.1;
			Color = Color3.new(1, 1, 0);
		},
		
		Ray = {
			Thickness = 0.1;
			Color = Color3.new(1, 0, 1);
		},
		
		Triangle = {
			Thickness = 0.05;
		};
		
		CFrame = {
			Thickness = 0.1;
			RightColor3 = Color3.new(1, 0, 0);
			UpColor3 = Color3.new(0, 1, 0);
			BackColor3 = Color3.new(0, 0, 1);
			PartProperties = {
				Material = Enum.Material.SmoothPlastic;
			};
		}
	}
	
	-- CONSTANTS
	
	local WEDGE = Instance.new("WedgePart")
	WEDGE.Material = Enum.Material.SmoothPlastic
	WEDGE.Anchored = true
	WEDGE.CanCollide = false
	
	local PART = Instance.new("Part")
	PART.Size = Vector3.new(0.1, 0.1, 0.1)
	PART.Anchored = true
	PART.CanCollide = false
	PART.TopSurface = Enum.SurfaceType.Smooth
	PART.BottomSurface = Enum.SurfaceType.Smooth
	PART.Material = Enum.Material.SmoothPlastic
	
	-- Functions
	
	local function draw(properties, style)
		local part = PART:Clone()
		for k, v in next, properties do
			part[k] = v
		end
		if (style) then
			for k, v in next, style do
				if (k ~= "Thickness") then
					part[k] = v
				end
			end
		end
		return part
	end
	
	function module.Draw(parent, properties)
		properties.Parent = parent
		return draw(properties, nil)
	end
	
	function module.Point(parent, cf_v3)
		local thickness = module.StyleGuide.Point.Thickness
		return draw({
			Size = Vector3.new(thickness, thickness, thickness);
			CFrame = (typeof(cf_v3) == "CFrame" and cf_v3 or CFrame.new(cf_v3));
			Parent = parent;
		}, module.StyleGuide.Point)
	end
	
	function module.Line(parent, a, b)
		local thickness = module.StyleGuide.Line.Thickness
		return draw({
			CFrame = CFrame.new((a + b)/2, b);
			Size = Vector3.new(thickness, thickness, (b - a).Magnitude);
			Parent = parent;
		}, module.StyleGuide.Line)
	end
	
	function module.Ray(parent, origin, direction)
		local thickness = module.StyleGuide.Ray.Thickness
		return draw({
			CFrame = CFrame.new(origin + direction/2, origin + direction);
			Size = Vector3.new(thickness, thickness, direction.Magnitude);
			Parent = parent;
		}, module.StyleGuide.Ray)
	end
	
	function module.Triangle(parent, a, b, c)
		local ab, ac, bc = b - a, c - a, c - b
		local abd, acd, bcd = ab:Dot(ab), ac:Dot(ac), bc:Dot(bc)
		
		if (abd > acd and abd > bcd) then
			c, a = a, c
		elseif (acd > bcd and acd > abd) then
			a, b = b, a
		end
		
		ab, ac, bc = b - a, c - a, c - b
		
		local right = ac:Cross(ab).Unit
		local up = bc:Cross(right).Unit
		local back = bc.Unit
		
		local height = math.abs(ab:Dot(up))
		local width1 = math.abs(ab:Dot(back))
		local width2 = math.abs(ac:Dot(back))
		
		local thickness = module.StyleGuide.Triangle.Thickness
		
		local w1 = WEDGE:Clone()
		w1.Size = Vector3.new(thickness, height, width1)
		w1.CFrame = CFrame.fromMatrix((a + b)/2, right, up, back)
		w1.Parent = parent
		
		local w2 = WEDGE:Clone()
		w2.Size = Vector3.new(thickness, height, width2)
		w2.CFrame = CFrame.fromMatrix((a + c)/2, -right, up, -back)
		w2.Parent = parent
		
		for k, v in next, module.StyleGuide.Triangle do
			if (k ~= "Thickness") then
				w1[k] = v
				w2[k] = v
			end
		end
		
		return w1, w2
	end
	
	function module.CFrame(parent, cf)
		local origin = cf.Position
		local r = cf.RightVector
		local u = cf.UpVector
		local b = -cf.LookVector
		
		local thickness = module.StyleGuide.CFrame.Thickness
		
		local right = draw({
			CFrame = CFrame.new(origin + r/2, origin + r);
			Size = Vector3.new(thickness, thickness, r.Magnitude);
			Color = module.StyleGuide.CFrame.RightColor3;
			Parent = parent;
		}, module.StyleGuide.CFrame.PartProperties)
		
		local up = draw({
			CFrame = CFrame.new(origin + u/2, origin + u);
			Size = Vector3.new(thickness, thickness, r.Magnitude);
			Color = module.StyleGuide.CFrame.UpColor3;
			Parent = parent;
		}, module.StyleGuide.CFrame.PartProperties)
		
		local back = draw({
			CFrame = CFrame.new(origin + b/2, origin + b);
			Size = Vector3.new(thickness, thickness, u.Magnitude);
			Color = module.StyleGuide.CFrame.BackColor3;
			Parent = parent;
		}, module.StyleGuide.CFrame.PartProperties)
		
		return right, up, back
	end
	
	-- Return
	
	return module
end
function _Draw2D()
	local module = {}
	
	-- Style Guide
	
	module.StyleGuide = {
		Point = {
			BorderSizePixel = 0;
			Size = UDim2.new(0, 4, 0, 4);
			BorderColor3 = Color3.new(0, 0, 0);
			BackgroundColor3 = Color3.new(0, 1, 0);
		},
		
		Line = {
			Thickness = 1;
			BorderSizePixel = 0;
			BorderColor3 = Color3.new(0, 0, 0);
			BackgroundColor3 = Color3.new(0, 1, 0);
		},
		
		Ray = {
			Thickness = 1;
			BorderSizePixel = 0;
			BorderColor3 = Color3.new(0, 0, 0);
			BackgroundColor3 = Color3.new(0, 1, 0);
		},
		
		Triangle = {
			ImageTransparency = 0;
			ImageColor3 = Color3.new(0, 1, 0);
		}
	}
	
	-- CONSTANTS
	
	local HALF = Vector2.new(0.5, 0.5)
	
	local RIGHT = "rbxassetid://2798177521"
	local LEFT = "rbxassetid://2798177955"
	
	local IMG = Instance.new("ImageLabel")
	IMG.BackgroundTransparency = 1
	IMG.AnchorPoint = HALF
	IMG.BorderSizePixel = 0
	
	local FRAME = Instance.new("Frame")
	FRAME.BorderSizePixel = 0
	FRAME.Size = UDim2.new(0, 0, 0, 0)
	FRAME.BackgroundColor3 = Color3.new(1, 1, 1)
	
	-- Functions
	
	function draw(properties, style)
		local frame = FRAME:Clone()
		for k, v in next, properties do
			frame[k] = v
		end
		if (style) then
			for k, v in next, style do
				if (k ~= "Thickness") then
					frame[k] = v
				end
			end
		end
		return frame
	end
	
	function module.Draw(parent, properties)
		properties.Parent = parent
		return draw(properties, nil)
	end
	
	function module.Point(parent, v2)
		return draw({
			AnchorPoint = HALF;
			Position = UDim2.new(0, v2.x, 0, v2.y);
			Parent = parent;
		}, module.StyleGuide.Point)
	end
	
	function module.Line(parent, a, b)
		local v = (b - a)
		local m = (a + b)/2
		
		return draw({
			AnchorPoint = HALF;
			Position = UDim2.new(0, m.x, 0, m.y);
			Size = UDim2.new(0, module.StyleGuide.Line.Thickness, 0, v.magnitude);
			Rotation = math.deg(math.atan2(v.y, v.x)) - 90;
			BackgroundColor3 = Color3.new(1, 1, 0);
			Parent = parent;
		}, module.StyleGuide.Line)
	end
	
	function module.Ray(parent, origin, direction)
		local a, b = origin, origin + direction
		local v = (b - a)
		local m = (a + b)/2
		
		return draw({
			AnchorPoint = HALF;
			Position = UDim2.new(0, m.x, 0, m.y);
			Size = UDim2.new(0, module.StyleGuide.Ray.Thickness, 0, v.magnitude);
			Rotation = math.deg(math.atan2(v.y, v.x)) - 90;
			Parent = parent;
		}, module.StyleGuide.Ray)
	end
	
	function module.Triangle(parent, a, b, c)
		local ab, ac, bc = b - a, c - a, c - b
		local abd, acd, bcd = ab:Dot(ab), ac:Dot(ac), bc:Dot(bc)
		
		if (abd > acd and abd > bcd) then
			c, a = a, c
		elseif (acd > bcd and acd > abd) then
			a, b = b, a
		end
		
		ab, ac, bc = b - a, c - a, c - b
		
		local unit = bc.unit
		local height = unit:Cross(ab)
		local flip = (height >= 0)
		local theta = math.deg(math.atan2(unit.y, unit.x)) + (flip and 0 or 180)
		
		local m1 = (a + b)/2
		local m2 = (a + c)/2
		
		local w1 = IMG:Clone()
		w1.Image = flip and RIGHT or LEFT
		w1.AnchorPoint = HALF
		w1.Size = UDim2.new(0, math.abs(unit:Dot(ab)), 0, height)
		w1.Position = UDim2.new(0, m1.x, 0, m1.y)
		w1.Rotation = theta
		w1.Parent = parent
		
		local w2 = IMG:Clone()
		w2.Image = flip and LEFT or RIGHT
		w2.AnchorPoint = HALF
		w2.Size = UDim2.new(0, math.abs(unit:Dot(ac)), 0, height)
		w2.Position = UDim2.new(0, m2.x, 0, m2.y)
		w2.Rotation = theta
		w2.Parent = parent
		
		for k, v in next, module.StyleGuide.Triangle do
			w1[k] = v
			w2[k] = v
		end
		
		return w1, w2
	end
	
	-- Return
	
	return module
end
function _DrawClass()
	local Draw2DModule = _Draw2D()
	local Draw3DModule = _Draw3D()
	
	--
	
	local DrawClass = {}
	local DrawClassStorage = setmetatable({}, {__mode = "k"})
	DrawClass.__index = DrawClass
	
	function DrawClass.new(parent)
		local self = setmetatable({}, DrawClass)
		
		self.Parent = parent
		DrawClassStorage[self] = {}
		
		self.Draw3D = {}
		for key, func in next, Draw3DModule do
			self.Draw3D[key] = function(...)
				local returns = {func(self.Parent, ...)}
				for i = 1, #returns do
					table.insert(DrawClassStorage[self], returns[i])
				end
				return unpack(returns)
			end
		end
		
		self.Draw2D = {}
		for key, func in next, Draw2DModule do
			self.Draw2D[key] = function(...)
				local returns = {func(self.Parent, ...)}
				for i = 1, #returns do
					table.insert(DrawClassStorage[self], returns[i])
				end
				return unpack(returns)
			end
		end
		
		return self
	end
	
	--
	
	function DrawClass:Clear()
		local t = DrawClassStorage[self]
		while (#t > 0) do
			local part = table.remove(t)
			if (part) then
				part:Destroy()
			end
		end
		DrawClassStorage[self] = {}
	end
	
	--
	
	return DrawClass
end


--END TEST

local PLAYERS = game:GetService("Players")

local GravityController = _GravityController()
local Controller = GravityController.new(PLAYERS.LocalPlayer)

local DrawClass = _DrawClass()

local PI2 = math.pi*2
local ZERO = Vector3.new(0, 0, 0)

local LOWER_RADIUS_OFFSET = 3 
local NUM_DOWN_RAYS = 24
local ODD_DOWN_RAY_START_RADIUS = 3	
local EVEN_DOWN_RAY_START_RADIUS = 2
local ODD_DOWN_RAY_END_RADIUS = 1.66666
local EVEN_DOWN_RAY_END_RADIUS = 1

local NUM_FEELER_RAYS = 9
local FEELER_LENGTH = 2
local FEELER_START_OFFSET = 2
local FEELER_RADIUS = 3.5
local FEELER_APEX_OFFSET = 1
local FEELER_WEIGHTING = 8

function GetGravityUp(self, oldGravityUp)
	local ignoreList = {}
	for i, player in next, PLAYERS:GetPlayers() do
		ignoreList[i] = player.Character
	end
	
	-- get the normal
	
	local hrpCF = self.HRP.CFrame
	local isR15 = (self.Humanoid.RigType == Enum.HumanoidRigType.R15)
	
	local origin = isR15 and hrpCF.p or hrpCF.p + 0.35*oldGravityUp
	local radialVector = math.abs(hrpCF.LookVector:Dot(oldGravityUp)) < 0.999 and hrpCF.LookVector:Cross(oldGravityUp) or hrpCF.RightVector:Cross(oldGravityUp)
	
	local centerRayLength = 25
	local centerRay = Ray.new(origin, -centerRayLength * oldGravityUp)
	local centerHit, centerHitPoint, centerHitNormal = workspace:FindPartOnRayWithIgnoreList(centerRay, ignoreList)
	
	--[[disable
	DrawClass:Clear()
	DrawClass.Draw3D.Ray(centerRay.Origin, centerRay.Direction)
	]]
	local downHitCount = 0
	local totalHitCount = 0
	local centerRayHitCount = 0
	local evenRayHitCount = 0
	local oddRayHitCount = 0
	
	local mainDownNormal = ZERO
	if (centerHit) then
		mainDownNormal = centerHitNormal
		centerRayHitCount = 0
	end
	
	local downRaySum = ZERO
	for i = 1, NUM_DOWN_RAYS do
		local dtheta = PI2 * ((i-1)/NUM_DOWN_RAYS)
		
		local angleWeight = 0.25 + 0.75 * math.abs(math.cos(dtheta))
		local isEvenRay = (i%2 == 0)
		local startRadius = isEvenRay and EVEN_DOWN_RAY_START_RADIUS or ODD_DOWN_RAY_START_RADIUS	
		local endRadius = isEvenRay and EVEN_DOWN_RAY_END_RADIUS or ODD_DOWN_RAY_END_RADIUS
		local downRayLength = centerRayLength
		
		local offset = CFrame.fromAxisAngle(oldGravityUp, dtheta) * radialVector
		local dir = (LOWER_RADIUS_OFFSET * -oldGravityUp + (endRadius - startRadius) * offset)
		local ray = Ray.new(origin + startRadius * offset, downRayLength * dir.unit)
		local hit, hitPoint, hitNormal = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
		--[[disable
		DrawClass.Draw3D.Ray(ray.Origin, ray.Direction)
		]]
		if (hit) then
			downRaySum = downRaySum + angleWeight * hitNormal
			downHitCount = downHitCount + 1
			if isEvenRay then
				evenRayHitCount = evenRayHitCount + 1					
			else
				oddRayHitCount = oddRayHitCount + 1
			end
		end
	end
	
	local feelerHitCount = 0	
	local feelerNormalSum = ZERO
	
	for i = 1, NUM_FEELER_RAYS do
		local dtheta = 2 * math.pi * ((i-1)/NUM_FEELER_RAYS)
		local angleWeight =  0.25 + 0.75 * math.abs(math.cos(dtheta))	
		local offset = CFrame.fromAxisAngle(oldGravityUp, dtheta) * radialVector
		local dir = (FEELER_RADIUS * offset + LOWER_RADIUS_OFFSET * -oldGravityUp).unit
		local feelerOrigin = origin - FEELER_APEX_OFFSET * -oldGravityUp + FEELER_START_OFFSET * dir
		local ray = Ray.new(feelerOrigin, FEELER_LENGTH * dir)
		local hit, hitPoint, hitNormal = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
		--[[disable
		DrawClass.Draw3D.Ray(ray.Origin, ray.Direction)
		]]
		if (hit) then
			feelerNormalSum = feelerNormalSum + FEELER_WEIGHTING * angleWeight * hitNormal --* hitDistSqInv
			feelerHitCount = feelerHitCount + 1
		end
	end
	
	if (centerRayHitCount + downHitCount + feelerHitCount > 0) then
		local normalSum = mainDownNormal + downRaySum + feelerNormalSum
		if (normalSum ~= ZERO) then
			return normalSum.unit
		end
	end
	
	return oldGravityUp
end

Controller.GetGravityUp = GetGravityUp

-- E is toggle
game:GetService("ContextActionService"):BindAction("Toggle", function(action, state, input)
	if not (state == Enum.UserInputState.Begin) then
		return
	end
	
	if (Controller) then
		Controller:Destroy()
		Controller = nil
	else
		Controller = GravityController.new(PLAYERS.LocalPlayer)
		Controller.GetGravityUp = GetGravityUp
	end
end, false, Enum.KeyCode.Z)
print("end")
end
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or r.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or hicolor)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local posC = (Table.posC or nil)
	local oriC = (Table.oriC or nil)
	local SizeC = (Table.SizeC or Vector3.new(0,0,0))
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,hicolor,randomstring(),Vector3.new(1,1,1),true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = Vector3.new(SIZE.X,SIZE.Y,SIZE.Z)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","1051557","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			EFFECT.CFrame = CFRAME
			if SizeC then
				MSH.Scale = MSH.Scale+SizeC*(0.01*TIME)
			end
			for LOOP = 1,TIME+1 do
				swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = Vector3.new(0,0,-MSH.Scale.X/8)
				end
				if oriC and posC then
					EFFECT.CFrame = EFFECT.CFrame * (posC * oriC)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				debris:AddItem(EFFECT, 0)
			else
				debris:AddItem(EFFECT, 0)
			end
		else
			if PLAYSSOUND == false then
				debris:AddItem(EFFECT, 0)
			else
				debris:AddItem(EFFECT, 0)
			end
		end
	end))
end
if HYPERISA then
local cn,euler,rad,random,c3,v3,clamp,sin,cos = CFrame.new,CFrame.fromEulerAnglesYXZ,math.rad,math.random,Color3.fromRGB,Vector3.new,math.clamp,math.sin,math.cos
local plrs,run,insert,rf,debris,workspace,ts,uis,pps = game:GetService("Players"),game:GetService("RunService"),game:GetService("InsertService"),game:GetService("ReplicatedFirst"),game:GetService("Debris"),game:GetService("Workspace"),game:GetService("TweenService"),game:GetService("UserInputService"),game:GetService("ProximityPromptService")
function tween(instance,properties,duration,easingdirection,easingstyle)
	spawn(function()
		if easingstyle == nil then easingstyle = Enum.EasingStyle.Quad end
		ts:Create(instance,TweenInfo.new(duration,easingstyle,easingdirection),properties):Play()
	end)
end

local backups = game:GetObjects("rbxassetid://10792926860")[1]
local r = game.Players.LocalPlayer.Character.HumanoidRootPart
chat = Instance.new("Part")
		chat.Color = c3()
		chat.Transparency = 0.5
		chat.Size = v3(8.625,5,0.125)
		chat.Name = "SDGUI"
		chat.Parent = workspace
		chat.CanCollide = false
		chat.Archivable = false
        chat.Anchored = true
		chat.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
		surfacegui = backups.chat:Clone()
		surfacegui.Parent = chat
		chatinput = surfacegui.input
		chatbox = surfacegui.chatbox
local VideoFrame = Instance.new("VideoFrame")
	VideoFrame.Parent = surfacegui.chatbox
	VideoFrame.AnchorPoint = Vector2.new(1, 1)
	VideoFrame.BorderSizePixel = 0
	VideoFrame.Position = UDim2.new(1, 1, 1, 1)
	VideoFrame.Size = UDim2.new(0, 411.25, 0, 230)
if HeadFollowSD then
spawn(function()
task.wait(3)
local MainLoop = game:GetService("RunService").Heartbeat:Connect(function()
game.Players.LocalPlayer.Character.Model.Head.CFrame = chat.CFrame
end)
end)
end
local char = game.Players.LocalPlayer.Character
local Chillmusic = Instance.new("Sound", char)
Chillmusic.Parent = char
Chillmusic.Volume = 10
Chillmusic.SoundId = "rbxassetid://0"
Chillmusic.Looped = true
Chillmusic:Play()

local txt = Instance.new("BillboardGui", char)
txt.Adornee = char.Head
txt.Name = "_status"
txt.Size = UDim2.new(2, 0, 1.2, 0)
txt.StudsOffset = Vector3.new(-9, 8, 0)
local text = Instance.new("TextLabel", txt)
text.Size = UDim2.new(10, 0, 7, 0)
text.FontSize = "Size24"
text.TextScaled = true
text.TextTransparency = 0
text.BackgroundTransparency = 1
text.TextTransparency = 0
text.TextStrokeTransparency = 0
text.Font = "Arcade"
text.TextStrokeColor3 = Color3.new(0, 0, 0)
local v = Instance.new("Part")
v.Name = "ColorBrick"
v.Parent = char
v.FormFactor = "Symmetric"
v.Anchored = true
v.CanCollide = false
v.BottomSurface = "Smooth"
v.TopSurface = "Smooth"
v.Size = Vector3.new(10, 5, 3)
v.Transparency = 1
v.CFrame = char.Torso.CFrame
v.BrickColor = BrickColor.new("Really black")
v.Transparency = 1
spawn(function()
TweenService = game:GetService("TweenService")
Colours = {Color3.fromRGB(0,100,200),Color3.fromRGB(4, 175, 236)}
Int = 0
while wait(2) do
    if Int == #Colours then Int = 0 end
    Int = Int+1
    TweenService:Create(text,TweenInfo.new(1),{TextColor3 = Colours[Int]}):Play()
end
end)
v.Shape = "Block"
text.Text = "~»ISA«~"

-- Objects

local Chill_Gui_Bro = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
local Header = Instance.new("Frame")
local BackGround = Instance.new("Frame")
local Chill_Gui_Label = Instance.new("TextLabel")
local Play_ID_Button = Instance.new("TextButton")
local ID_Box = Instance.new("TextBox")
local Set_Vol_Button = Instance.new("TextButton")
local Vol_Box = Instance.new("TextBox")
local Set_Tpos_Button = Instance.new("TextButton")
local Tpos_Box = Instance.new("TextBox")
local Set_Text_Button = Instance.new("TextButton")
local Tpos_Box_2 = Instance.new("TextBox")
local Toggle_Chat_Button = Instance.new("TextButton")
local Chat_Toggle_Label = Instance.new("TextLabel")
local Current_Song_Label = Instance.new("TextLabel")

-- Properties

Chill_Gui_Bro.Name = "Chill_Gui_Bro"

Header.Name = "Header"
Header.Parent = Chill_Gui_Bro
Header.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Header.BorderSizePixel = 0
Header.Draggable = true
Header.Active = true
Header.Selectable = true
Header.Position = UDim2.new(0.469539374, 0, 0.147921771, 0)
Header.Size = UDim2.new(0, 250, 0, 45)

BackGround.Name = "BackGround"
BackGround.Parent = Header
BackGround.BackgroundColor3 = Color3.new(0.196078, 0.196078, 0.196078)
BackGround.BorderSizePixel = 0
BackGround.Draggable = true
BackGround.Position = UDim2.new(0, 0, 1, 0)
BackGround.Size = UDim2.new(0, 250, 0, 299)

Chill_Gui_Label.Name = "Chill_Gui_Label"
Chill_Gui_Label.Parent = Header
Chill_Gui_Label.BackgroundColor3 = Color3.new(1, 1, 1)
Chill_Gui_Label.BackgroundTransparency = 1
Chill_Gui_Label.BorderSizePixel = 0
Chill_Gui_Label.Draggable = true
Chill_Gui_Label.Size = UDim2.new(0, 250, 0, 45)
Chill_Gui_Label.Font = Enum.Font.Arcade
Chill_Gui_Label.Text = "~»ISA«~"
Chill_Gui_Label.TextColor3 = Color3.new(1, 1, 1)
Chill_Gui_Label.TextScaled = true
Chill_Gui_Label.TextSize = 14
Chill_Gui_Label.TextWrapped = true

Play_ID_Button.Name = "Play_ID_Button"
Play_ID_Button.Parent = Header
Play_ID_Button.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Play_ID_Button.BorderColor3 = Color3.new(0, 0, 0)
Play_ID_Button.BorderSizePixel = 0
Play_ID_Button.Position = UDim2.new(0.0520000011, 0, 1.22222221, 0)
Play_ID_Button.Size = UDim2.new(0, 68, 0, 35)
Play_ID_Button.Font = Enum.Font.Arcade
Play_ID_Button.Text = "Play ID"
Play_ID_Button.TextColor3 = Color3.new(1, 1, 1)
Play_ID_Button.TextSize = 20
Play_ID_Button.TextWrapped = true

ID_Box.Name = "ID_Box"
ID_Box.Parent = Header
ID_Box.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
ID_Box.BorderColor3 = Color3.new(0, 0, 0)
ID_Box.BorderSizePixel = 0
ID_Box.Position = UDim2.new(0.356000006, 0, 1.22222221, 0)
ID_Box.Size = UDim2.new(0, 140, 0, 35)
ID_Box.Font = Enum.Font.Arcade
ID_Box.Text = "ID here"
ID_Box.TextColor3 = Color3.new(1, 1, 1)
ID_Box.TextSize = 35
ID_Box.TextWrapped = true

Set_Vol_Button.Name = "Set_Vol_Button"
Set_Vol_Button.Parent = Header
Set_Vol_Button.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Set_Vol_Button.BorderColor3 = Color3.new(0, 0, 0)
Set_Vol_Button.BorderSizePixel = 0
Set_Vol_Button.Position = UDim2.new(0.0520000011, 0, 2.20000005, 0)
Set_Vol_Button.Size = UDim2.new(0, 68, 0, 35)
Set_Vol_Button.Font = Enum.Font.Arcade
Set_Vol_Button.Text = "Set Vol"
Set_Vol_Button.TextColor3 = Color3.new(1, 1, 1)
Set_Vol_Button.TextSize = 20
Set_Vol_Button.TextWrapped = true

Vol_Box.Name = "Vol_Box"
Vol_Box.Parent = Header
Vol_Box.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Vol_Box.BorderColor3 = Color3.new(0, 0, 0)
Vol_Box.BorderSizePixel = 0
Vol_Box.Position = UDim2.new(0.356000006, 0, 2.20000005, 0)
Vol_Box.Size = UDim2.new(0, 140, 0, 35)
Vol_Box.Font = Enum.Font.Arcade
Vol_Box.Text = "Volume"
Vol_Box.TextColor3 = Color3.new(1, 1, 1)
Vol_Box.TextSize = 35
Vol_Box.TextWrapped = true

Set_Tpos_Button.Name = "Set_Tpos_Button"
Set_Tpos_Button.Parent = Header
Set_Tpos_Button.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Set_Tpos_Button.BorderColor3 = Color3.new(0, 0, 0)
Set_Tpos_Button.BorderSizePixel = 0
Set_Tpos_Button.Position = UDim2.new(0.0520000011, 0, 3.24444437, 0)
Set_Tpos_Button.Size = UDim2.new(0, 68, 0, 35)
Set_Tpos_Button.Font = Enum.Font.Arcade
Set_Tpos_Button.Text = "Set Tpos"
Set_Tpos_Button.TextColor3 = Color3.new(1, 1, 1)
Set_Tpos_Button.TextSize = 18
Set_Tpos_Button.TextWrapped = true

Tpos_Box.Name = "Tpos_Box"
Tpos_Box.Parent = Header
Tpos_Box.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Tpos_Box.BorderColor3 = Color3.new(0, 0, 0)
Tpos_Box.BorderSizePixel = 0
Tpos_Box.Position = UDim2.new(0.356000006, 0, 3.24444437, 0)
Tpos_Box.Size = UDim2.new(0, 140, 0, 35)
Tpos_Box.Font = Enum.Font.Arcade
Tpos_Box.Text = "Time Position"
Tpos_Box.TextColor3 = Color3.new(1, 1, 1)
Tpos_Box.TextSize = 20
Tpos_Box.TextWrapped = true

Set_Text_Button.Name = "Set_Text_Button"
Set_Text_Button.Parent = Header
Set_Text_Button.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Set_Text_Button.BorderColor3 = Color3.new(0, 0, 0)
Set_Text_Button.BorderSizePixel = 0
Set_Text_Button.Position = UDim2.new(0.0600000024, 0, 4.22222233, 0)
Set_Text_Button.Size = UDim2.new(0, 68, 0, 35)
Set_Text_Button.Font = Enum.Font.Arcade
Set_Text_Button.Text = "Set Text"
Set_Text_Button.TextColor3 = Color3.new(1, 1, 1)
Set_Text_Button.TextSize = 18
Set_Text_Button.TextWrapped = true

Tpos_Box_2.Name = "Tpos_Box"
Tpos_Box_2.Parent = Header
Tpos_Box_2.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Tpos_Box_2.BorderColor3 = Color3.new(0, 0, 0)
Tpos_Box_2.BorderSizePixel = 0
Tpos_Box_2.Position = UDim2.new(0.356000006, 0, 4.22222233, 0)
Tpos_Box_2.Size = UDim2.new(0, 140, 0, 35)
Tpos_Box_2.Font = Enum.Font.Arcade
Tpos_Box_2.Text = "Text"
Tpos_Box_2.TextColor3 = Color3.new(1, 1, 1)
Tpos_Box_2.TextSize = 20
Tpos_Box_2.TextWrapped = true

Toggle_Chat_Button.Name = "Toggle_Chat_Button"
Toggle_Chat_Button.Parent = Header
Toggle_Chat_Button.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Toggle_Chat_Button.BorderColor3 = Color3.new(0, 0, 0)
Toggle_Chat_Button.BorderSizePixel = 0
Toggle_Chat_Button.Position = UDim2.new(0.0579999983, 0, 5.26666689, 0)
Toggle_Chat_Button.Size = UDim2.new(0, 97, 0, 35)
Toggle_Chat_Button.Font = Enum.Font.Arcade
Toggle_Chat_Button.Text = "Toggle Chat"
Toggle_Chat_Button.TextColor3 = Color3.new(1, 1, 1)
Toggle_Chat_Button.TextSize = 20
Toggle_Chat_Button.TextWrapped = true

Chat_Toggle_Label.Name = "Chat_Toggle_Label"
Chat_Toggle_Label.Parent = Header
Chat_Toggle_Label.BackgroundColor3 = Color3.new(1, 1, 1)
Chat_Toggle_Label.BackgroundTransparency = 0.89999997615814
Chat_Toggle_Label.BorderColor3 = Color3.new(1, 1, 1)
Chat_Toggle_Label.Position = UDim2.new(0.540000021, 0, 5.26666689, 0)
Chat_Toggle_Label.Size = UDim2.new(0, 94, 0, 35)
Chat_Toggle_Label.Font = Enum.Font.Arcade
Chat_Toggle_Label.Text = "~»False«~"
Chat_Toggle_Label.TextColor3 = Color3.new(1, 1, 1)
Chat_Toggle_Label.TextScaled = true
Chat_Toggle_Label.TextSize = 14
Chat_Toggle_Label.TextWrapped = true

Current_Song_Label.Name = "Current_Song_Label"
Current_Song_Label.Parent = Header
Current_Song_Label.BackgroundColor3 = Color3.new(1, 1, 1)
Current_Song_Label.BackgroundTransparency = 0.89999997615814
Current_Song_Label.BorderColor3 = Color3.new(1, 1, 1)
Current_Song_Label.Position = UDim2.new(0.0520000011, 0, 6.64444447, 0)
Current_Song_Label.Size = UDim2.new(0, 225, 0, 35)
Current_Song_Label.Font = Enum.Font.Arcade
Current_Song_Label.Text = "~»Current Song: None«~"
Current_Song_Label.TextColor3 = Color3.new(1, 1, 1)
Current_Song_Label.TextScaled = true
Current_Song_Label.TextSize = 14
Current_Song_Label.TextWrapped = true

Play_ID_Button.MouseButton1Down:Connect(function()
if tonumber(ID_Box.Text) then
	Chillmusic:Stop()
	Chillmusic.SoundId='rbxassetid://'..tonumber(ID_Box.Text)
	Chillmusic:Play()
end
end)
local ischatting = false

Set_Vol_Button.MouseButton1Down:Connect(function()

	Chillmusic.Volume = tonumber(Vol_Box.Text)
end)

Set_Tpos_Button.MouseButton1Down:Connect(function()

	Chillmusic.TimePosition = tonumber(Tpos_Box.Text)
end)

Set_Text_Button.MouseButton1Down:Connect(function()

	text.Text = "~»"..Tpos_Box_2.Text.."«~"
end)

Toggle_Chat_Button.MouseButton1Down:Connect(function()
if ischatting == false then
ischatting = true
Chat_Toggle_Label.Text = "~»True«~"
spawn(function()
game.Players.LocalPlayer.Chatted:connect(function(msg)
for i = 0, msg:len(), 1 do
	text.Text = "~»"..msg:sub(0, i).."«~"
end

text.Text = "~»Fell Apart AF«~"
end)
end)
else
ischatting = false
Chat_Toggle_Label.Text = "~»False«~"
end
end)
local CurrentColor = Color3.new(0.5,0,0)
local doColors = true
coroutine.resume(coroutine.create(function()
	while doColors == true do
		for i = 0,1,0.06 do
			for bruh = 1,3 do
				game:GetService("RunService").Heartbeat:Wait()
			end
			CurrentColor = Color3.fromHSV(i,1,1)
		end
	end
end))
--[[Check Animations Folder]]
if not isfolder("Animations") then
    print("Missing Animations folder. Adding...")
    makefolder("Animations")
    print("Animations folder created")
end

--[[ Requirements:

SYNAPSE X,

REANIMATION SCRIPT,

R6 RIG TYPE,

.anim PACKS,

GOOBER BEHAVIOR

]]

--Made by (Nostalgia boy#4514)
--If you'd like help understanding anything don't be afraid to DM me. Enjoy my third rewrite of this!
--To summarize it. This script can play specialized exported jsons of keyframesequence objects.

--[[GUI to LuaC]]
local ScreenGui = Instance.new("ScreenGui")
local Background = Instance.new("Frame")
local dragger = Instance.new("TextButton")
local ScrollingFrame = Instance.new("ScrollingFrame")
local UIListLayout = Instance.new("UIListLayout")
local BackButton = Instance.new("TextButton")
local Exit = Instance.new("TextButton")
local SpeedTextBox = Instance.new("TextBox")
local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
Background.Name = "Background"
Background.Parent = ScreenGui
Background.BackgroundColor3 = Color3.fromRGB(29, 29, 29)
Background.BackgroundTransparency = 0.500
Background.BorderSizePixel = 0
Background.Position = UDim2.new(0.411409855, 0, 0.298029155, 0)
Background.Size = UDim2.new(0.176684886, 0, 0.402692765, 0)
dragger.Name = "dragger"
dragger.Parent = Background
dragger.AnchorPoint = Vector2.new(1, 1)
dragger.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
dragger.BackgroundTransparency = 0.500
dragger.BorderSizePixel = 0
dragger.Position = UDim2.new(1, 0, 1, 0)
dragger.Size = UDim2.new(0, 21, 0, 22)
dragger.Font = Enum.Font.SourceSans
dragger.Text = ""
dragger.TextColor3 = Color3.fromRGB(0, 0, 0)
dragger.TextSize = 14.000
ScrollingFrame.Parent = Background
ScrollingFrame.Active = true
ScrollingFrame.BackgroundColor3 = Color3.fromRGB(29, 29, 29)
ScrollingFrame.BackgroundTransparency = 1.000
ScrollingFrame.BorderSizePixel = 0
ScrollingFrame.Position = UDim2.new(0.0274914093, 0, 0.0668693036, 0)
ScrollingFrame.Size = UDim2.new(0.950928807, 0, 0.863221884, 0)
ScrollingFrame.ScrollBarThickness = 7
ScrollingFrame.ScrollBarImageColor3 = Color3.new(0, 0, 0)
UIListLayout.Parent = ScrollingFrame
UIListLayout.Padding = UDim.new(0.0149999997, 0)
BackButton.Name = "BackButton"
BackButton.Parent = Background
BackButton.BackgroundColor3 = Color3.fromRGB(94, 120, 184)
BackButton.BackgroundTransparency = 0.500
BackButton.BorderSizePixel = 0
BackButton.Size = UDim2.new(0.216494843, 0, 0.0668693036, 0)
BackButton.Font = Enum.Font.SourceSans
BackButton.Text = ""
BackButton.TextColor3 = Color3.fromRGB(0, 0, 0)
BackButton.TextSize = 14.000
Exit.Name = "Exit"
Exit.Parent = Background
Exit.AnchorPoint = Vector2.new(1, 1)
Exit.BackgroundColor3 = Color3.fromRGB(157, 42, 42)
Exit.BackgroundTransparency = 0.500
Exit.BorderSizePixel = 0
Exit.Position = UDim2.new(1, 0, 0.0668693036, 0)
Exit.Size = UDim2.new(0.0721649453, 0, 0.0668693036, 0)
Exit.Font = Enum.Font.SourceSans
Exit.Text = ""
Exit.TextColor3 = Color3.fromRGB(0, 0, 0)
Exit.TextSize = 14.000
SpeedTextBox.Name = "SpeedTextBox"
SpeedTextBox.Parent = Background
SpeedTextBox.AnchorPoint = Vector2.new(0.5, 1)
SpeedTextBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
SpeedTextBox.BackgroundTransparency = 0.500
SpeedTextBox.BorderSizePixel = 0
SpeedTextBox.Position = UDim2.new(0.501718163, 0, 1, 0)
SpeedTextBox.Size = UDim2.new(0, 63, 0, 22)
SpeedTextBox.Font = Enum.Font.SourceSans
SpeedTextBox.Text = "1"
SpeedTextBox.TextColor3 = Color3.fromRGB(0, 0, 0)
SpeedTextBox.TextScaled = true
SpeedTextBox.TextSize = 14.000
SpeedTextBox.TextWrapped = true
UIAspectRatioConstraint.Parent = ScreenGui
UIAspectRatioConstraint.AspectRatio = 2.016


--[[Variables]]
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInput = game:GetService("UserInputService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local Mouse = player:GetMouse()
local c = player.Character
local stopanim = true
local animspeed = 1

local AnimPacks = {}

local Joints = {
	['Head'] = c.Torso['Neck'],
	['Torso'] = c.HumanoidRootPart['RootJoint'],
	['Left Arm'] = c.Torso['Left Shoulder'],
	['Right Arm'] = c.Torso['Right Shoulder'],
	['Left Leg'] = c.Torso['Left Hip'],
	['Right Leg'] = c.Torso['Right Hip']
}

local lastC0s = {
	['Head'] = Joints['Head'].C0,
	['Torso'] = Joints['Torso'].C0,
	['Left Arm'] = Joints['Left Arm'].C0,
	['Right Arm'] = Joints['Right Arm'].C0,
	['Left Leg'] = Joints['Left Leg'].C0,
	['Right Leg'] = Joints['Right Leg'].C0
}

local lastRoAnims = {

}

if not RunService:FindFirstChild('Delta') then
	local Delta = Instance.new("BindableEvent")
	Delta.Parent = RunService
	Delta.Name = "Delta"
	local A, B = 0, tick()
	RunService.Delta:Fire(); RunService.Heartbeat:Connect(function(C, D)
		A = A + C
		if A >= (1/60) then
			for I = 1, math.floor(A / (1/60)) do
				RunService.Delta:Fire()
			end
			B = tick()
			A = A - (1/60) * math.floor(A / (1/60))
		end
	end)
end
local Delta = RunService.Delta["Event"]


--[[Functions]]
local function Yield(Seconds)
	local Time = Seconds * (60.8) --+ Keyframes[#Keyframes].Time)
	if (1/Time) > 1 then Time = 1 end
	for I = 1,Time,1 do 
		Delta:Wait()
		--task.wait(1/60.8)
	end
end

local function defaultAnimsOFF()

end

local function defaultAnimsON()

end

local function fixc()
	Joints['Head'].C0 = lastC0s["Head"]
	Joints['Torso'].C0 = lastC0s["Torso"]
	Joints['Left Arm'].C0 = lastC0s["Left Arm"]
	Joints['Right Arm'].C0 = lastC0s["Right Arm"]
	Joints['Left Leg'].C0 = lastC0s["Left Leg"]
	Joints['Right Leg'].C0 = lastC0s["Right Leg"]
end

function DecodeCFrame(tbl)
    return CFrame.new(unpack(tbl))
end

local function EditCFrame(Data)
	if Data.Part and Joints[Data.Part.Name] then
		local cframe = (lastC0s[Data.Part.Name] * Data.CFrame)
		local goal = {}
		goal.C0 = cframe
		
		
		
		local tween = TweenService:Create(Joints[Data.Part.Name], TweenInfo.new(Data.Duration, Data.Style, Data.Direction), goal)
		tween:Play()
	end
end

local function PlayAnimfromPath(filepath)
    local json = readfile(filepath)
    local keyframes = HttpService:JSONDecode(json)
    defaultAnimsOFF()
    while true do
        if stopanim == true then
            break
        end
        for k, keyframe in pairs(keyframes) do
            if stopanim == true then
                break
            end
            local yieldtime
            for p, pose in pairs(keyframe) do
                if c:FindFirstChild(pose.Part) then
                    local Data = {}
                    Data.Part = c[pose.Part]
                    Data.CFrame = DecodeCFrame(pose.CFrame)
                    Data.Duration = pose.Duration / animspeed
                    yieldtime = Data.Duration
                    Data.Style = Enum['EasingStyle'][pose.Style]
                    Data.Direction = Enum['EasingDirection'][pose.Direction]
                    if pose.Part == "Torso" and Data.CFrame == CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) then
    				else
    					task.spawn(function()
    						EditCFrame(Data)
    					end)
    				end
                end
            end
            if not stopanim then
                Yield(yieldtime)
            end
        end
    end
    wait()
    fixc()
    defaultAnimsON()
end

local function DisplayAnims(FolderPath)
    for _, buttonUI in ipairs(ScrollingFrame:GetDescendants()) do
        if buttonUI:IsA("TextButton") then
            buttonUI:Destroy()
        end
    end
    
    local files = listfiles(FolderPath)
    for f, file in ipairs(files) do
        if string.lower(tostring(file:split('.')[2])) == "anim" then
            local animsnamesplit = file:split("\\")[3] or file:split("\\")[2]
            local animname = animsnamesplit:split('.')[1]
            local textbutton = Instance.new("TextButton")
            textbutton.Parent = ScrollingFrame
            textbutton.BackgroundTransparency = 0.5
            textbutton.BorderSizePixel = 0
            textbutton.Size = UDim2.new(1, 0, 0.035, 0)
            textbutton.Font = "Roboto"
            textbutton.Text = animname
            textbutton.TextScaled = true
            textbutton.TextTransparency = 0.5
            textbutton.MouseButton1Down:Connect(function()
                if stopanim == true then
                    stopanim = false
                else
                    stopanim = true
                end
                PlayAnimfromPath(file)
            end)
        end
    end
end

local function DisplayFolders()
    for _, buttonUI in pairs(ScrollingFrame:GetDescendants()) do
        if buttonUI:IsA("TextButton") then
            buttonUI:Destroy()
        end
    end
    
    AnimPacks = {}
    table.insert(AnimPacks, {["Path"] = "Animations"})
    for _, folder in ipairs(listfiles("Animations")) do
        if isfolder(folder) then 
            local Data = {}
            Data.Path = folder
            table.insert(AnimPacks, Data)
        end
    end
    for _, folder in ipairs(AnimPacks) do
        local foldername = folder.Path:split('\\')[2] or tostring(folder.Path)
        local textbutton = Instance.new("TextButton")
        textbutton.Parent = ScrollingFrame
        textbutton.BackgroundTransparency = 0.5
        textbutton.BorderSizePixel = 0
        textbutton.Size = UDim2.new(1, 0, 0.035, 0)
        textbutton.Font = "Roboto"
        textbutton.Text = foldername
        textbutton.TextScaled = true
        textbutton.TextTransparency = 0.5
        textbutton.BackgroundColor3 = Color3.fromRGB(255, 234, 192)
        textbutton.MouseButton1Down:Connect(function()
            DisplayAnims(folder.Path)
        end)
    end
end


--[[Meat and Potatos]]
DisplayFolders()

BackButton.MouseButton1Down:Connect(function()
    DisplayFolders()
end)

Exit.MouseButton1Down:Connect(function()
    stopanim = true
    ScreenGui:Destroy()
end)

SpeedTextBox.FocusLost:Connect(function(enterPressed, inputObject)
    if enterPressed and tonumber(SpeedTextBox.Text) > 0 and tonumber(SpeedTextBox.Text) < 5.1 then
        animspeed = tonumber(SpeedTextBox.Text)
    else
        SpeedTextBox.Text = "1"
        animspeed = 1
    end
end)

--[[Dragify script]]
do
    local dragToggle = nil
    local dragSpeed = 0
    local dragInput = nil
    local dragStart = nil
	local dragPos = nil
	local startPos = nil
    local function updateInput(input)
        local Delta = input.Position - dragStart
        local Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)
        game:GetService("TweenService"):Create(Background, TweenInfo.new(0.25), {Position = Position}):Play()
    end
    Background.InputBegan:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and UserInput:GetFocusedTextBox() == nil then
            dragToggle = true
            dragStart = input.Position
            startPos = Background.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragToggle = false
                end
            end)
        end
    end)
    Background.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if input == dragInput and dragToggle then
            updateInput(input)
        end
    end)
end

--[[Dragger Script]]
do
	local MinimumSize = {X = 0,Y = 0}
	local StartSize,StartDrag
	local MouseDown = false
	dragger.InputBegan:Connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and not UserInput:GetFocusedTextBox() then
			MouseDown = true
			StartSize = Background.AbsoluteSize
			StartDrag = input.Position
		end
	end)
	dragger.InputEnded:Connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and not UserInput:GetFocusedTextBox() then
			MouseDown = false
			StartSize = nil
			StartDrag = nil
		end
	end)
	UserInput.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement and MouseDown or input.UserInputType == Enum.UserInputType.Touch and MouseDown then
			Background.Size = UDim2.fromOffset(math.max(MinimumSize.X, (StartSize.X + (Mouse.X - StartDrag.X))), math.max(MinimumSize.Y, (StartSize.Y + (Mouse.Y - StartDrag.Y))))
		end
	end)
end

local VISUALS = game.Lighting
local VISUALSSz = game.Lighting:FindFirstChildOfClass("Sky")
local song = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Sound") --select where your sound parented
local number = 90 -- :mike:
run.RenderStepped:Connect(function()
	sine = workspace.DistributedGameTime * 60
    tween(chat,{CFrame=r.CFrame*cn(3.13899994+sin(sine/30)/2,5.16800022+sin(sine/20)/2,-1.19099998+sin(sine/40)/2)*euler(rad(-14.48+cos(sine/30)*10),rad(127+cos(sine/20)*10),rad(-3.97+cos(sine/40)*10))},0.5,Enum.EasingDirection.Out)
end)
local MainLoop = game:GetService("RunService").Heartbeat:Connect(function()
game.Lighting.Blur.Size = 1 + song.PlaybackLoudness/number --very cool blur moment makes you have broken glasses
game.Lighting.FogEnd = math.clamp(song.PlaybackLoudness,5000,10000)
workspace.CurrentCamera.FieldOfView = 100 + song.PlaybackLoudness/number --very cool field of view moment makes screen go wee woo
			VISUALS.FogColor = CurrentColor
			VISUALS.ClockTime = 10 + song.PlaybackLoudness/number
			VISUALS.ExposureCompensation = math.clamp((0 + song.PlaybackLoudness/250),0,5)
            VISUALSSz.MoonAngularSize = 6 + song.PlaybackLoudness/50
			VISUALSSz.SunAngularSize = 6 + song.PlaybackLoudness/25
end)
end
if TIER8 then
local RunService = game:GetService("RunService")
RunService.Heartbeat:Connect(function()
    game.Players.LocalPlayer.Character.Model.HumanoidRootPart.CFrame = CFrame.new(math.random(10000, 100000),999999999,math.random(10000, 100000))
end)
end
if BitControllerEffect then
local Player = game:GetService("Players").LocalPlayer
local Character = Player.Character

function weld(parent,part0,part1,c0,c1)
local weld=Instance.new("Weld")
weld.Parent=parent
weld.Part0=part0
weld.Part1=part1
weld.C0=c0
weld.C1=c1
return weld
end
local mlok = Character["8BitController"]
mlok.Handle.AccessoryWeld:Destroy()
handle=mlok.Handle
Character.Model["8BitController"].Handle.Transparency = 1
handleweld=weld(handle,Character["Torso"],handle,CFrame.new(0, 0, 0),CFrame.new(0, 0, 0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)))
end
if Watermelon then
local Player = game:GetService("Players").LocalPlayer
local Character = Player.Character

function weld(parent,part0,part1,c0,c1)
local weld=Instance.new("Weld")
weld.Parent=parent
weld.Part0=part0
weld.Part1=part1
weld.C0=c0
weld.C1=c1
return weld
end
local mlok = Character["WatermelonHat"]
mlok.Handle.AccessoryWeld:Destroy()
handle=mlok.Handle
Character.Model["WatermelonHat"].Handle.Transparency = 1
handleweld=weld(handle,Character["Torso"],handle,CFrame.new(0, 0, 0),CFrame.new(0, 0, 0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)))
end
if ISATheme then
local ScreenGui = Instance.new("ScreenGui", gethui())
----------------------------
local Bar = Instance.new("ImageLabel", ScreenGui)
Bar.Name = "Bar"
Bar.BackgroundTransparency = 1
Bar.AnchorPoint = Vector2.new(0.5, 0.5)
Bar.Position = UDim2.new(0.5, 0, 0.1, 0)
Bar.Size = UDim2.new(0, 640, 0, 60)
Bar.Image = getcustomasset("ISA/Bar.png")

local SystemError = Instance.new("ImageLabel", ScreenGui)
SystemError.Name = "SystemError"
SystemError.BackgroundTransparency = 1
SystemError.AnchorPoint = Vector2.new(0.5, 0.5)
SystemError.Position = UDim2.new(0.5, 0, 0.1, 0)
SystemError.Size = UDim2.new(0, 202, 0, 51)
SystemError.Image = getcustomasset("ISA/ProJ.png")
end
if AnimationTest then
		local Frame = (60)
		
		Service = setmetatable(
			{
				Get = function(Self, Serv)
					if Service[Serv] then return Service[Serv] end
					local S = game:GetService(Serv)
					if S then Service[Serv] = S end
					return S
				end;
			}, {
				__index = function(Self, Index)
					local S = game:GetService(Index)
					if S then Service[Index] = S end
					return S
				end;
			})
		
		local LP = Service['Players'].LocalPlayer; local Char = LP['Character']
		local Torso, Root, Humanoid = Char['Torso'], Char['HumanoidRootPart'], Char['Humanoid']
		local TService, UIS = Service['TweenService'], Service['UserInputService']
		
		coroutine.wrap(function()
			Root['Anchored'] = true;
			wait(.8)
			Root['Anchored'] = false;
		end)()
		
		

		
		
		
		local Create = function(Obj,Parent)
			local I = Instance.new(Obj); I['Parent'] = Parent; return I
		end
		
		local Contains = function(Table,KV)
			for K,V in next, Table do 
				if rawequal(KV,K) or rawequal(KV,V) then 
					return true;
				end
			end
			return false
		end
		
		local PoseToCF = function(Pose,Motor)
			return (Motor['Part0'].CFrame * Motor['C0'] * Pose['CFrame'] * Motor['C1']:Inverse()):ToObjectSpace(Motor['Part0'].CFrame)
		end
		
		local Joints = {
			['Torso'] = Root['RootJoint'];
			['Left Arm'] = Torso['Left Shoulder'];
			['Right Arm'] = Torso['Right Shoulder'];
			['Left Leg'] = Torso['Left Hip'];
			['Right Leg'] = Torso['Right Hip'];
		}
		
		for K,V in next, Char:GetChildren() do 
			if V:IsA('BasePart') then 
				coroutine.wrap(function()
					repeat V['CanCollide'] = false
						Service['RunService'].Stepped:Wait() until Humanoid['Health'] < 1
				end)()
			end
		end
		
		for K,V in next, Joints do 
			local AP, AO, A0, A1 = Create('AlignPosition',V['Part1']), Create('AlignOrientation',V['Part1']), Create('Attachment',V['Part1']), Create('Attachment',V['Part0'])
			AP['RigidityEnabled'] = true; AO['RigidityEnabled'] = true; AP['Attachment0'] = A0; AP['Attachment1'] = A1; AO['Attachment0'] = A0; AO['Attachment1'] = A1;
			A0['Name'] = 'CFAttachment0'; A1['Name'] = 'CFAttachment1'; A0['CFrame'] = V['C1'] * V['C0']:Inverse(); V:Remove()
		end
		
		local Edit = function(Part,Value,Duration,Style,Direction)
			Style = Style or 'Enum.EasingStyle.Linear'; Direction = Direction or 'Enum.EasingDirection.In'
			local Attachment = Part:FindFirstChild('CFAttachment0')
			if Attachment ~= nil then
				TService:Create(Attachment,TweenInfo.new(Duration,Enum['EasingStyle'][tostring(Style):split('.')[3]],Enum['EasingDirection'][tostring(Direction):split('.')[3]],0,false,0),{CFrame = Value}):Play()
			end
		end
		
		if not Service['RunService']:FindFirstChild('Delta') then
			local Delta = Create('BindableEvent',Service['RunService']); Delta['Name'] = 'Delta'
			local A, B = 0, tick()
			Service['RunService'].Delta:Fire(); Service['RunService'].Heartbeat:Connect(function(C, D)
				A = A + C
				if A >= (1/Frame) then
					for I = 1, math.floor(A / (1/Frame)) do
						Service['RunService'].Delta:Fire()
					end
					B = tick()
					A = A - (1/Frame) * math.floor(A / (1/Frame))
				end
			end)
		end
		
		coroutine.wrap(function()
			Humanoid['Died']:Wait()
			for K,V in next, Char:GetDescendants() do 
				if V['Name']:match('Align') then 
					V:Destroy()
				end
			end
		end)()
		
		local PreloadAnimation = function(AssetId)
			local Sequence = game:GetObjects('rbxassetid://'..AssetId)[1]; assert(Sequence:IsA('KeyframeSequence'),'Instance is not a KeyframeSequence.')
			wait(.06)
			local Class = {}
			Class['Speed'] = 1
			local Yield = function(Seconds)
				local Time = Seconds * (Frame + Sequence:GetKeyframes()[#Sequence:GetKeyframes()].Time)
				for I = 1,Time,Class['Speed'] do 
					Service['RunService'].Delta['Event']:Wait()
				end
			end
			Class['Stopped'] = false;
			Class['Complete'] = Instance.new('BindableEvent')
			Class['Play'] = function()
				Class['Stopped'] = false
				coroutine.wrap(function()
					repeat
						for K = 1,#Sequence:GetKeyframes() do 
							local K0, K1, K2 = Sequence:GetKeyframes()[K-1], Sequence:GetKeyframes()[K], Sequence:GetKeyframes()[K+1]
							if Class['Stopped'] ~= true and Humanoid['Health'] > 0 then
								if K0 ~= nil then 
									Yield(K1['Time'] - K0['Time'])
								end
								coroutine.wrap(function()
									for I = 1,#K1:GetDescendants() do 
										local Pose = K1:GetDescendants()[I]
										if Contains(Joints,Pose['Name']) then 
											local Duration = K2 ~= nil and (K2['Time'] - K1['Time'])/Class['Speed'] or .5
											Edit(Char[Pose['Name']],PoseToCF(Pose,Joints[Pose['Name']]),Duration,Pose['EasingStyle'],Pose['EasingDirection'])
										end
									end
								end)()
							end
						end
						Class['Complete']:Fire()
					until Sequence['Loop'] ~= true or Class['Stopped'] ~= false or Humanoid['Health'] < 1
				end)()
			end
			Class['Stop'] = function()
				Class['Stopped'] = true;
			end
			Class['Reset'] = function()
				coroutine.wrap(function()
					wait(.02)
					assert(Class['Stopped'],'Track Must Be Stopped First!')
					for K,V in next, Joints do 
						local Part = Char[K]
						if Part ~= nil then 
							local Attachment = Part:FindFirstChild('CFAttachment0')
							if Attachment ~= nil then 
								Attachment['CFrame'] = V['C1'] * V['C0']:Inverse()
							end
						end
					end
				end)()
			end
			return Class
		end
		
		Humanoid.WalkSpeed = 11
		
		local Anims = {
			['Idle'] = PreloadAnimation(5183986020);
			['Walk'] = PreloadAnimation(5053650512);
			['Run'] = PreloadAnimation(5053715968);
			['Jump'] = PreloadAnimation(4073859368);
			['Fall'] = PreloadAnimation(3323393688);
		}
		
		wait(1)
		local Connections = {};
		
		Mouse = LP:GetMouse()
		local Dancing, Running = false, false;
		
		local StopAll = function()
			for K,V in next, Anims do 
				if V['Stopped'] ~= true then 
					V:Stop()
				end
			end
		end
		
		Anims['Idle']:Play(); Dancing = false; Anims['Walk'].Stopped = true; Anims['Run'].Stopped = true
		
		Connections['Run'] = Humanoid['Running']:Connect(function(Speed)
			if Speed > 6 and Dancing ~= true and Anims['Walk'].Stopped ~= false and runnning ~= true then
				Anims['Idle']:Stop()
				Anims['Jump']:Stop()
				Anims['Fall']:Stop()
				Anims['Run']:Stop()
				Anims['Walk']:Play()
			elseif Speed < 5 and Dancing ~= true and Anims['Walk'].Stopped ~= true and runnning ~= true then
				Anims['Walk']:Stop()
				Anims['Jump']:Stop()
				Anims['Fall']:Stop()
				Anims['Run']:Stop()
				Anims['Idle']:Play()
			elseif Speed < 5 and Dancing ~= true and Anims['Jump'].Stopped ~= true or Anims['Fall'].Stopped ~= true then
				Anims['Walk']:Stop()
				Anims['Jump']:Stop()
				Anims['Fall']:Stop()
				Anims['Run']:Stop()
				Anims['Idle']:Play()
			end
		end)
		Connections['Jumping'] = Humanoid['Jumping']:Connect(function(active)
			if active and Dancing ~= true and Anims['Jump'].Stopped ~= false then
				Anims['Idle']:Stop()
				Anims['Walk']:Stop()
				Anims['Fall']:Stop()
				Anims['Run']:Stop()
				Anims['Jump']:Play()
			end
		end)
		Connections['FreeFalling'] = Humanoid['FreeFalling']:Connect(function(active)
			if active and Dancing ~= true and Anims['Jump'].Stopped ~= false then
				Anims['Idle']:Stop()
				Anims['Walk']:Stop()
				Anims['Jump']:Stop()
				Anims['Run']:Stop()
				Anims['Fall']:Play()
			end
		end)
		
		Mouse.KeyDown:connect(function(key)
			if key:lower() == string.char(48) then --string.char(48) is just shift
				if Humanoid and Anims['Walk'].Stopped ~= true then
					Anims['Walk']:Stop()
					Anims['Jump']:Stop()
					Anims['Fall']:Stop()
					Anims['Idle']:Stop()
					Anims['Run']:Play()
					runnning = true
					Humanoid.WalkSpeed = 40
				end
			end
		end)
		
		--When button is lifted
		Mouse.KeyUp:connect(function(key)
			if key:lower() == string.char(48) then --string.char(48) is just shift
				if Humanoid then
					runnning = false
					Humanoid.WalkSpeed = 11
				end
			end
		end)
		
		wait(1)
		local Bind = function(Id,Key,Speed)
			Speed = Speed or 1
			local Animation = PreloadAnimation(Id)
			table.insert(Anims,Animation)
			local V = UIS.InputBegan:Connect(function(Input,P)
				if Input.KeyCode == Enum.KeyCode[Key] and P ~= true then 
					if Dancing ~= true then Dancing = true;
						StopAll(); wait(.1); Animation:Play() Animation['Speed'] = Speed
					else Dancing = false;
						StopAll(); wait(.1); Anims['Idle']:Play()
					end
				end
			end)
		end
		
		Bind(4686555525,'Q',1)
		wait(0.1)
		Bind(4558409610,'Y',1)
		wait(0.1)
		Bind(3259216638,'R',1)
		wait(0.1)
		Bind(3450125501,'T',1)
		wait(0.1)
		Bind(4109162757,'U',1)
		wait(0.1)
		Bind(4835795413,'P',1)
		wait(0.1)
		Bind(3623215692,'F',1)
		wait(0.1)
		Bind(3619935462,'G',1)
		wait(0.1)
		Bind(3643129020,'H',1)
		wait(0.1)
		Bind(5238669868,'J',1)
		wait(0.1)
		Bind(3262592866,'K',1)
		wait(0.1)
		Bind(5069868968,'L',1)
		wait(0.1)
		Bind(5713461790, 'Z',1)
		wait(0.1)
		Bind(5362230261, 'X',1)
		wait(0.1)
		Bind(5713511509, 'C',1)
		wait(0.1)
		Bind(5011408603, 'V',1)
		wait(0.1)
		Bind(4300223810, 'B',1)
		wait(0.1)
		Bind(4787449997, 'N',1)
		wait(0.1)
		Bind(5863173275, 'E',1)
end





























for i,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
    if v.Name == "Hit" or v.Name == "InTimeStop" then
        v:Destroy()
        game.Players.LocalPlayer.Character.Head.Anchored = false
        game.Players.LocalPlayer.Character.Torso.Anchored = false
        game.Players.LocalPlayer.Character["Right Arm"].Anchored = false
        game.Players.LocalPlayer.Character["Left Arm"].Anchored = false
        game.Players.LocalPlayer.Character["Right Leg"].Anchored = false
        game.Players.LocalPlayer.Character["Left Leg"].Anchored = false
        game.Players.LocalPlayer.Character["HumanoidRootPart"].Anchored = false
        game.Players.LocalPlayer.Character.Model.Head.Anchored = false
        game.Players.LocalPlayer.Character.Model.Torso.Anchored = false
        game.Players.LocalPlayer.Character.Model["Right Arm"].Anchored = false
        game.Players.LocalPlayer.Character.Model["Left Arm"].Anchored = false
        game.Players.LocalPlayer.Character.Model["Right Leg"].Anchored = false
        game.Players.LocalPlayer.Character.Model["Left Leg"].Anchored = false
        game.Players.LocalPlayer.Character.Model["HumanoidRootPart"].Anchored = false

    end
end












--------------------------------------------
elseif game.PlaceId == 8573962925 then
game.Players.LocalPlayer.Character.Head.Display.Frame.TextLabel:Destroy()

end
